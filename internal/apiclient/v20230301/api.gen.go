// Package v20230301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20230301

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AcmeAttestationProvisionerAttestationFormats.
const (
	Apple AcmeAttestationProvisionerAttestationFormats = "apple"
	Step  AcmeAttestationProvisionerAttestationFormats = "step"
	Tpm   AcmeAttestationProvisionerAttestationFormats = "tpm"
)

// Defines values for AcmeProvisionerChallenges.
const (
	Dns01     AcmeProvisionerChallenges = "dns-01"
	Http01    AcmeProvisionerChallenges = "http-01"
	TlsAlpn01 AcmeProvisionerChallenges = "tls-alpn-01"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for ProvisionerType.
const (
	ACME            ProvisionerType = "ACME"
	ACMEATTESTATION ProvisionerType = "ACME_ATTESTATION"
	JWK             ProvisionerType = "JWK"
	OIDC            ProvisionerType = "OIDC"
	X5C             ProvisionerType = "X5C"
)

// Defines values for WebhookCertType.
const (
	ALL  WebhookCertType = "ALL"
	SSH  WebhookCertType = "SSH"
	X509 WebhookCertType = "X509"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// AcmeAttestationProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [device-attest-01 challenge of the ACME protocol](https://smallstep.com/blog/acme-managed-device-attestation-explained/).
type AcmeAttestationProvisioner struct {
	// AttestationFormats The allowed attestation formats for the device-attest-01 challenge. Valid values are apple, step, and tpm. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default.
	AttestationFormats []AcmeAttestationProvisionerAttestationFormats `json:"attestationFormats"`

	// AttestationRoots A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
	AttestationRoots *[]string `json:"attestationRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// AcmeAttestationProvisionerAttestationFormats defines model for AcmeAttestationProvisioner.AttestationFormats.
type AcmeAttestationProvisionerAttestationFormats string

// AcmeProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [ACME protocol](https://smallstep.com/docs/step-ca/acme-basics/#acme-challenges).
type AcmeProvisioner struct {
	// Challenges Which ACME challenge types are allowed.
	Challenges []AcmeProvisionerChallenges `json:"challenges"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be true for all new provisioners.
	RequireEAB bool `json:"requireEAB"`
}

// AcmeProvisionerChallenges defines model for AcmeProvisioner.Challenges.
type AcmeProvisionerChallenges string

// AttestationAuthority An attestation authority used with the device-attest-01 ACME challenge to verify a device's hardware identity. This object is experimental and subject to change.
type AttestationAuthority struct {
	// AttestorIntermediates The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by devices.
	AttestorIntermediates *string `json:"attestorIntermediates,omitempty"`

	// AttestorRoots The pem-encoded list of certificates used to verify the attestation certificates submitted by devices.
	AttestorRoots string `json:"attestorRoots"`

	// Catalog The slug of an inventory that holds the list of devices belonging to the team
	Catalog string `json:"catalog"`

	// CreatedAt Timestamp in RFC3339 format when the attestation authority was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this attestation authority. Generated server-side.
	Id *string `json:"id,omitempty"`

	// Name The name of the attestation authority
	Name string `json:"name"`

	// Root The pem-encoded root certificate of this attestation authority. This is generated server-side when the attestation authority is created. This certificate should be used in the `attestationRoots` field of an ACME_ATTESTATION provisioner with the `tpm` format.
	Root *string `json:"root,omitempty"`

	// Slug A short name for this attestation authority. Read only.
	Slug *string `json:"slug,omitempty"`
}

// Authority An X509 authority hosted by Smallstep
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only)
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority
	Id string `json:"id"`

	// Name The name of the authority
	Name string `json:"name"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error
	Message string `json:"message"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group
	Id *string `json:"id,omitempty"`

	// Name The name of the group
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp when the host was registered
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp when the host was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Inventory A collection of items
type Inventory struct {
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the inventory
	DisplayName string `json:"displayName"`

	// ItemCount The number of items in the inventory
	ItemCount int `json:"itemCount"`

	// Slug A lowercase name identifying the inventory.
	Slug      string    `json:"slug"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// InventoryItem An item in an inventory
type InventoryItem struct {
	// CreatedAt Timestamp of when the item was added to the inventory
	CreatedAt time.Time `json:"createdAt"`

	// Data The item data
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp of when the item was last changed
	UpdatedAt time.Time `json:"updatedAt"`
}

// JwkProvisioner defines model for jwkProvisioner.
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key
	Key interface{} `json:"key"`
}

// NameConstraints defines model for name-constraints.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewInventory A collection of items
type NewInventory struct {
	// DisplayName A user-friendly name for the inventory
	DisplayName *string `json:"displayName,omitempty"`

	// Slug A lowercase name identifying the inventory.
	Slug string `json:"slug"`
}

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// OidcProvisioner defines model for oidcProvisioner.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user
	Username *string `json:"username,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh *SshOptions `json:"ssh,omitempty"`

	// Webhooks Configuration for a webhook to be called when issuing certificates with this provisioner
	Webhooks *Webhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates
	X509 *X509Options `json:"x509,omitempty"`
}

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// Webhook Configuration for a webhook to be called when issuing certificates with this provisioner
type Webhook struct {
	// CertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
	CertType *WebhookCertType `json:"certType,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the webhook.
	Name *string `json:"name,omitempty"`

	// Url The URL of the webhook server.
	Url *string `json:"url,omitempty"`
}

// WebhookCertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
type WebhookCertType string

// X509Issuer A Customized X509 issuer for an authority
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer
	Name            string           `json:"name"`
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// X5cProvisioner Authenticate a certificate request with an existing x509 certificate.
type X5cProvisioner struct {
	// Roots A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
	Roots []string `json:"roots"`
}

// Accept defines model for accept.
type Accept = string

// AttestationAuthorityID defines model for attestationAuthorityID.
type AttestationAuthorityID = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InventorySlug defines model for inventorySlug.
type InventorySlug = string

// ItemID defines model for itemID.
type ItemID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N500 defines model for 500.
type N500 = Error

// GetAttestationAuthoritiesParams defines parameters for GetAttestationAuthorities.
type GetAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesParams defines parameters for PostAttestationAuthorities.
type PostAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAttestationAuthorityParams defines parameters for DeleteAttestationAuthority.
type DeleteAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAttestationAuthorityParams defines parameters for GetAttestationAuthority.
type GetAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to true the results will only include active hosts. If set to false the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to true the results will include only bastion hosts and if set to false the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoriesParams defines parameters for ListInventories.
type ListInventoriesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostInventoriesParams defines parameters for PostInventories.
type PostInventoriesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryParams defines parameters for DeleteInventory.
type DeleteInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryParams defines parameters for GetInventory.
type GetInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoryItemsParams defines parameters for ListInventoryItems.
type ListInventoryItemsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryItemParams defines parameters for DeleteInventoryItem.
type DeleteInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemParams defines parameters for GetInventoryItem.
type GetInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemJSONBody defines parameters for PutInventoryItem.
type PutInventoryItemJSONBody struct {
	Data interface{} `json:"data"`
}

// PutInventoryItemParams defines parameters for PutInventoryItem.
type PutInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemDataParams defines parameters for GetInventoryItemData.
type GetInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemDataJSONBody defines parameters for PutInventoryItemData.
type PutInventoryItemDataJSONBody = interface{}

// PutInventoryItemDataParams defines parameters for PutInventoryItemData.
type PutInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesJSONRequestBody defines body for PostAttestationAuthorities for application/json ContentType.
type PostAttestationAuthoritiesJSONRequestBody = AttestationAuthority

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PostInventoriesJSONRequestBody defines body for PostInventories for application/json ContentType.
type PostInventoriesJSONRequestBody = NewInventory

// PutInventoryItemJSONRequestBody defines body for PutInventoryItem for application/json ContentType.
type PutInventoryItemJSONRequestBody PutInventoryItemJSONBody

// PutInventoryItemDataJSONRequestBody defines body for PutInventoryItemData for application/json ContentType.
type PutInventoryItemDataJSONRequestBody = PutInventoryItemDataJSONBody

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeProvisioner returns the union data inside the Provisioner as a AcmeProvisioner
func (t Provisioner) AsAcmeProvisioner() (AcmeProvisioner, error) {
	var body AcmeProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeProvisioner overwrites any union data inside the Provisioner as the provided AcmeProvisioner
func (t *Provisioner) FromAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeProvisioner
func (t *Provisioner) MergeAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeAttestationProvisioner returns the union data inside the Provisioner as a AcmeAttestationProvisioner
func (t Provisioner) AsAcmeAttestationProvisioner() (AcmeAttestationProvisioner, error) {
	var body AcmeAttestationProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeAttestationProvisioner overwrites any union data inside the Provisioner as the provided AcmeAttestationProvisioner
func (t *Provisioner) FromAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeAttestationProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeAttestationProvisioner
func (t *Provisioner) MergeAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsX5cProvisioner returns the union data inside the Provisioner as a X5cProvisioner
func (t Provisioner) AsX5cProvisioner() (X5cProvisioner, error) {
	var body X5cProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX5cProvisioner overwrites any union data inside the Provisioner as the provided X5cProvisioner
func (t *Provisioner) FromX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX5cProvisioner performs a merge with any union data inside the Provisioner, using the provided X5cProvisioner
func (t *Provisioner) MergeX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAttestationAuthorities request
	GetAttestationAuthorities(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttestationAuthorities request with any body
	PostAttestationAuthoritiesWithBody(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttestationAuthorities(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttestationAuthority request
	DeleteAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttestationAuthority request
	GetAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuth request with any body
	PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorities request
	GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorities request with any body
	PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthoritiesCsr request with any body
	PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthority request
	DeleteAuthority(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthority request
	GetAuthority(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthorityProvisioners request
	ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityProvisioners request with any body
	PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProvisioner request
	DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProvisioner request
	GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityRoot request with any body
	PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGrants request
	GetSshGrants(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSshGrants request with any body
	PostSshGrantsWithBody(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSshGrants(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSshGrant request
	DeleteSshGrant(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGrant request
	GetSshGrant(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGroups request
	GetSshGroups(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGroup request
	GetSshGroup(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshHosts request
	GetSshHosts(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshHost request
	GetSshHost(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHostsHostIDTags request with any body
	PostHostsHostIDTagsWithBody(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHostsHostIDTags(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterSshHost request
	UnregisterSshHost(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInventories request
	ListInventories(ctx context.Context, params *ListInventoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventories request with any body
	PostInventoriesWithBody(ctx context.Context, params *PostInventoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventories(ctx context.Context, params *PostInventoriesParams, body PostInventoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInventory request
	DeleteInventory(ctx context.Context, inventorySlug InventorySlug, params *DeleteInventoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventory request
	GetInventory(ctx context.Context, inventorySlug InventorySlug, params *GetInventoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInventoryItems request
	ListInventoryItems(ctx context.Context, inventorySlug InventorySlug, params *ListInventoryItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInventoryItem request
	DeleteInventoryItem(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *DeleteInventoryItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItem request
	GetInventoryItem(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutInventoryItem request with any body
	PutInventoryItemWithBody(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutInventoryItem(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, body PutInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItemData request
	GetInventoryItemData(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutInventoryItemData request with any body
	PutInventoryItemDataWithBody(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutInventoryItemData(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, body PutInventoryItemDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshHostTags request
	GetSshHostTags(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshUsers request
	GetSshUsers(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAttestationAuthorities(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttestationAuthoritiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttestationAuthoritiesWithBody(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttestationAuthoritiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttestationAuthorities(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttestationAuthoritiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttestationAuthorityRequest(c.Server, attestationAuthorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttestationAuthorityRequest(c.Server, attestationAuthorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthoritiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthority(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorityRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthority(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorityRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthorityProvisionersRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGrants(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGrantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSshGrantsWithBody(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSshGrantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSshGrants(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSshGrantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSshGrant(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSshGrantRequest(c.Server, grantID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGrant(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGrantRequest(c.Server, grantID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGroups(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGroup(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGroupRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshHosts(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshHost(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshHostRequest(c.Server, hostID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostsHostIDTagsWithBody(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostsHostIDTagsRequestWithBody(c.Server, hostID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostsHostIDTags(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostsHostIDTagsRequest(c.Server, hostID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterSshHost(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterSshHostRequest(c.Server, hostID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInventories(ctx context.Context, params *ListInventoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInventoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoriesWithBody(ctx context.Context, params *PostInventoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventories(ctx context.Context, params *PostInventoriesParams, body PostInventoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInventory(ctx context.Context, inventorySlug InventorySlug, params *DeleteInventoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInventoryRequest(c.Server, inventorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventory(ctx context.Context, inventorySlug InventorySlug, params *GetInventoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryRequest(c.Server, inventorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInventoryItems(ctx context.Context, inventorySlug InventorySlug, params *ListInventoryItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInventoryItemsRequest(c.Server, inventorySlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInventoryItem(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *DeleteInventoryItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInventoryItemRequest(c.Server, inventorySlug, itemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItem(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemRequest(c.Server, inventorySlug, itemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutInventoryItemWithBody(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutInventoryItemRequestWithBody(c.Server, inventorySlug, itemID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutInventoryItem(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, body PutInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutInventoryItemRequest(c.Server, inventorySlug, itemID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItemData(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemDataRequest(c.Server, inventorySlug, itemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutInventoryItemDataWithBody(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutInventoryItemDataRequestWithBody(c.Server, inventorySlug, itemID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutInventoryItemData(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, body PutInventoryItemDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutInventoryItemDataRequest(c.Server, inventorySlug, itemID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshHostTags(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshHostTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshUsers(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAttestationAuthoritiesRequest generates requests for GetAttestationAuthorities
func NewGetAttestationAuthoritiesRequest(server string, params *GetAttestationAuthoritiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAttestationAuthoritiesRequest calls the generic PostAttestationAuthorities builder with application/json body
func NewPostAttestationAuthoritiesRequest(server string, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttestationAuthoritiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAttestationAuthoritiesRequestWithBody generates requests for PostAttestationAuthorities with any type of body
func NewPostAttestationAuthoritiesRequestWithBody(server string, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteAttestationAuthorityRequest generates requests for DeleteAttestationAuthority
func NewDeleteAttestationAuthorityRequest(server string, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, attestationAuthorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetAttestationAuthorityRequest generates requests for GetAttestationAuthority
func NewGetAttestationAuthorityRequest(server string, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, attestationAuthorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthRequest calls the generic PostAuth builder with application/json body
func NewPostAuthRequest(server string, body PostAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthRequestWithBody generates requests for PostAuth with any type of body
func NewPostAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthoritiesRequest generates requests for GetAuthorities
func NewGetAuthoritiesRequest(server string, params *GetAuthoritiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthoritiesRequest calls the generic PostAuthorities builder with application/json body
func NewPostAuthoritiesRequest(server string, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesRequestWithBody generates requests for PostAuthorities with any type of body
func NewPostAuthoritiesRequestWithBody(server string, params *PostAuthoritiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthoritiesCsrRequest calls the generic PostAuthoritiesCsr builder with application/json body
func NewPostAuthoritiesCsrRequest(server string, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesCsrRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesCsrRequestWithBody generates requests for PostAuthoritiesCsr with any type of body
func NewPostAuthoritiesCsrRequestWithBody(server string, params *PostAuthoritiesCsrParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/csr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteAuthorityRequest generates requests for DeleteAuthority
func NewDeleteAuthorityRequest(server string, authorityID AuthorityID, params *DeleteAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetAuthorityRequest generates requests for GetAuthority
func NewGetAuthorityRequest(server string, authorityID AuthorityID, params *GetAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewListAuthorityProvisionersRequest generates requests for ListAuthorityProvisioners
func NewListAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *ListAuthorityProvisionersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthorityProvisionersRequest calls the generic PostAuthorityProvisioners builder with application/json body
func NewPostAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityProvisionersRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityProvisionersRequestWithBody generates requests for PostAuthorityProvisioners with any type of body
func NewPostAuthorityProvisionersRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteProvisionerRequest generates requests for DeleteProvisioner
func NewDeleteProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetProvisionerRequest generates requests for GetProvisioner
func NewGetProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthorityRootRequest calls the generic PostAuthorityRoot builder with application/json body
func NewPostAuthorityRootRequest(server string, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityRootRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityRootRequestWithBody generates requests for PostAuthorityRoot with any type of body
func NewPostAuthorityRootRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/root", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGrantsRequest generates requests for GetSshGrants
func NewGetSshGrantsRequest(server string, params *GetSshGrantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostSshGrantsRequest calls the generic PostSshGrants builder with application/json body
func NewPostSshGrantsRequest(server string, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSshGrantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostSshGrantsRequestWithBody generates requests for PostSshGrants with any type of body
func NewPostSshGrantsRequestWithBody(server string, params *PostSshGrantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteSshGrantRequest generates requests for DeleteSshGrant
func NewDeleteSshGrantRequest(server string, grantID GrantID, params *DeleteSshGrantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grantID", runtime.ParamLocationPath, grantID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGrantRequest generates requests for GetSshGrant
func NewGetSshGrantRequest(server string, grantID GrantID, params *GetSshGrantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grantID", runtime.ParamLocationPath, grantID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGroupsRequest generates requests for GetSshGroups
func NewGetSshGroupsRequest(server string, params *GetSshGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGroupRequest generates requests for GetSshGroup
func NewGetSshGroupRequest(server string, groupID GroupID, params *GetSshGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupID", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshHostsRequest generates requests for GetSshHosts
func NewGetSshHostsRequest(server string, params *GetSshHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Bastion != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bastion", runtime.ParamLocationQuery, *params.Bastion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshHostRequest generates requests for GetSshHost
func NewGetSshHostRequest(server string, hostID HostID, params *GetSshHostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostID", runtime.ParamLocationPath, hostID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostHostsHostIDTagsRequest calls the generic PostHostsHostIDTags builder with application/json body
func NewPostHostsHostIDTagsRequest(server string, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostHostsHostIDTagsRequestWithBody(server, hostID, params, "application/json", bodyReader)
}

// NewPostHostsHostIDTagsRequestWithBody generates requests for PostHostsHostIDTags with any type of body
func NewPostHostsHostIDTagsRequestWithBody(server string, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostID", runtime.ParamLocationPath, hostID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewUnregisterSshHostRequest generates requests for UnregisterSshHost
func NewUnregisterSshHostRequest(server string, hostID HostID, params *UnregisterSshHostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostID", runtime.ParamLocationPath, hostID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/unregister", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewListInventoriesRequest generates requests for ListInventories
func NewListInventoriesRequest(server string, params *ListInventoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostInventoriesRequest calls the generic PostInventories builder with application/json body
func NewPostInventoriesRequest(server string, params *PostInventoriesParams, body PostInventoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostInventoriesRequestWithBody generates requests for PostInventories with any type of body
func NewPostInventoriesRequestWithBody(server string, params *PostInventoriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteInventoryRequest generates requests for DeleteInventory
func NewDeleteInventoryRequest(server string, inventorySlug InventorySlug, params *DeleteInventoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetInventoryRequest generates requests for GetInventory
func NewGetInventoryRequest(server string, inventorySlug InventorySlug, params *GetInventoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewListInventoryItemsRequest generates requests for ListInventoryItems
func NewListInventoryItemsRequest(server string, inventorySlug InventorySlug, params *ListInventoryItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteInventoryItemRequest generates requests for DeleteInventoryItem
func NewDeleteInventoryItemRequest(server string, inventorySlug InventorySlug, itemID ItemID, params *DeleteInventoryItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemID", runtime.ParamLocationPath, itemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetInventoryItemRequest generates requests for GetInventoryItem
func NewGetInventoryItemRequest(server string, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemID", runtime.ParamLocationPath, itemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutInventoryItemRequest calls the generic PutInventoryItem builder with application/json body
func NewPutInventoryItemRequest(server string, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, body PutInventoryItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutInventoryItemRequestWithBody(server, inventorySlug, itemID, params, "application/json", bodyReader)
}

// NewPutInventoryItemRequestWithBody generates requests for PutInventoryItem with any type of body
func NewPutInventoryItemRequestWithBody(server string, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemID", runtime.ParamLocationPath, itemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetInventoryItemDataRequest generates requests for GetInventoryItemData
func NewGetInventoryItemDataRequest(server string, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemID", runtime.ParamLocationPath, itemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s/items/%s/data", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutInventoryItemDataRequest calls the generic PutInventoryItemData builder with application/json body
func NewPutInventoryItemDataRequest(server string, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, body PutInventoryItemDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutInventoryItemDataRequestWithBody(server, inventorySlug, itemID, params, "application/json", bodyReader)
}

// NewPutInventoryItemDataRequestWithBody generates requests for PutInventoryItemData with any type of body
func NewPutInventoryItemDataRequestWithBody(server string, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, inventorySlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemID", runtime.ParamLocationPath, itemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inventories/%s/items/%s/data", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshHostTagsRequest generates requests for GetSshHostTags
func NewGetSshHostTagsRequest(server string, params *GetSshHostTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshUsersRequest generates requests for GetSshUsers
func NewGetSshUsersRequest(server string, params *GetSshUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAttestationAuthorities request
	GetAttestationAuthoritiesWithResponse(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthoritiesResponse, error)

	// PostAttestationAuthorities request with any body
	PostAttestationAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error)

	PostAttestationAuthoritiesWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error)

	// DeleteAttestationAuthority request
	DeleteAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAttestationAuthorityResponse, error)

	// GetAttestationAuthority request
	GetAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthorityResponse, error)

	// PostAuth request with any body
	PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	// GetAuthorities request
	GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error)

	// PostAuthorities request with any body
	PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	// PostAuthoritiesCsr request with any body
	PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	// DeleteAuthority request
	DeleteAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error)

	// GetAuthority request
	GetAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error)

	// ListAuthorityProvisioners request
	ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error)

	// PostAuthorityProvisioners request with any body
	PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	// DeleteProvisioner request
	DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error)

	// GetProvisioner request
	GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error)

	// PostAuthorityRoot request with any body
	PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	// GetSshGrants request
	GetSshGrantsWithResponse(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*GetSshGrantsResponse, error)

	// PostSshGrants request with any body
	PostSshGrantsWithBodyWithResponse(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error)

	PostSshGrantsWithResponse(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error)

	// DeleteSshGrant request
	DeleteSshGrantWithResponse(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*DeleteSshGrantResponse, error)

	// GetSshGrant request
	GetSshGrantWithResponse(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*GetSshGrantResponse, error)

	// GetSshGroups request
	GetSshGroupsWithResponse(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*GetSshGroupsResponse, error)

	// GetSshGroup request
	GetSshGroupWithResponse(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*GetSshGroupResponse, error)

	// GetSshHosts request
	GetSshHostsWithResponse(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*GetSshHostsResponse, error)

	// GetSshHost request
	GetSshHostWithResponse(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*GetSshHostResponse, error)

	// PostHostsHostIDTags request with any body
	PostHostsHostIDTagsWithBodyWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error)

	PostHostsHostIDTagsWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error)

	// UnregisterSshHost request
	UnregisterSshHostWithResponse(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*UnregisterSshHostResponse, error)

	// ListInventories request
	ListInventoriesWithResponse(ctx context.Context, params *ListInventoriesParams, reqEditors ...RequestEditorFn) (*ListInventoriesResponse, error)

	// PostInventories request with any body
	PostInventoriesWithBodyWithResponse(ctx context.Context, params *PostInventoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoriesResponse, error)

	PostInventoriesWithResponse(ctx context.Context, params *PostInventoriesParams, body PostInventoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoriesResponse, error)

	// DeleteInventory request
	DeleteInventoryWithResponse(ctx context.Context, inventorySlug InventorySlug, params *DeleteInventoryParams, reqEditors ...RequestEditorFn) (*DeleteInventoryResponse, error)

	// GetInventory request
	GetInventoryWithResponse(ctx context.Context, inventorySlug InventorySlug, params *GetInventoryParams, reqEditors ...RequestEditorFn) (*GetInventoryResponse, error)

	// ListInventoryItems request
	ListInventoryItemsWithResponse(ctx context.Context, inventorySlug InventorySlug, params *ListInventoryItemsParams, reqEditors ...RequestEditorFn) (*ListInventoryItemsResponse, error)

	// DeleteInventoryItem request
	DeleteInventoryItemWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *DeleteInventoryItemParams, reqEditors ...RequestEditorFn) (*DeleteInventoryItemResponse, error)

	// GetInventoryItem request
	GetInventoryItemWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemParams, reqEditors ...RequestEditorFn) (*GetInventoryItemResponse, error)

	// PutInventoryItem request with any body
	PutInventoryItemWithBodyWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutInventoryItemResponse, error)

	PutInventoryItemWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, body PutInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PutInventoryItemResponse, error)

	// GetInventoryItemData request
	GetInventoryItemDataWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemDataParams, reqEditors ...RequestEditorFn) (*GetInventoryItemDataResponse, error)

	// PutInventoryItemData request with any body
	PutInventoryItemDataWithBodyWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutInventoryItemDataResponse, error)

	PutInventoryItemDataWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, body PutInventoryItemDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PutInventoryItemDataResponse, error)

	// GetSshHostTags request
	GetSshHostTagsWithResponse(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*GetSshHostTagsResponse, error)

	// GetSshUsers request
	GetSshUsersWithResponse(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*GetSshUsersResponse, error)
}

type GetAttestationAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttestationAuthority
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAttestationAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttestationAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttestationAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AttestationAuthority
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAttestationAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttestationAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttestationAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAttestationAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttestationAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttestationAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttestationAuthority
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAttestationAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttestationAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Token *string `json:"token,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Authority
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Authority
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesCsrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthorityCsr
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesCsrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesCsrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Provisioner
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Provisioner
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Provisioner
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthorityRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Grant
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSshGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Grant
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSshGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSshGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSshGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSshGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSshGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Grant
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Host
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Host
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHostsHostIDTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Tag
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostHostsHostIDTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHostsHostIDTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterSshHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Host
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UnregisterSshHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterSshHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInventoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Inventory
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListInventoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInventoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Inventory
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostInventoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Inventory
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInventoryItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]InventoryItem
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListInventoryItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInventoryItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InventoryItem
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutInventoryItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InventoryItem
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutInventoryItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutInventoryItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutInventoryItemDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutInventoryItemDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutInventoryItemDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshHostTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tag
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshHostTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshHostTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAttestationAuthoritiesWithResponse request returning *GetAttestationAuthoritiesResponse
func (c *ClientWithResponses) GetAttestationAuthoritiesWithResponse(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthoritiesResponse, error) {
	rsp, err := c.GetAttestationAuthorities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttestationAuthoritiesResponse(rsp)
}

// PostAttestationAuthoritiesWithBodyWithResponse request with arbitrary body returning *PostAttestationAuthoritiesResponse
func (c *ClientWithResponses) PostAttestationAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error) {
	rsp, err := c.PostAttestationAuthoritiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttestationAuthoritiesResponse(rsp)
}

func (c *ClientWithResponses) PostAttestationAuthoritiesWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error) {
	rsp, err := c.PostAttestationAuthorities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttestationAuthoritiesResponse(rsp)
}

// DeleteAttestationAuthorityWithResponse request returning *DeleteAttestationAuthorityResponse
func (c *ClientWithResponses) DeleteAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAttestationAuthorityResponse, error) {
	rsp, err := c.DeleteAttestationAuthority(ctx, attestationAuthorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttestationAuthorityResponse(rsp)
}

// GetAttestationAuthorityWithResponse request returning *GetAttestationAuthorityResponse
func (c *ClientWithResponses) GetAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthorityResponse, error) {
	rsp, err := c.GetAttestationAuthority(ctx, attestationAuthorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttestationAuthorityResponse(rsp)
}

// PostAuthWithBodyWithResponse request with arbitrary body returning *PostAuthResponse
func (c *ClientWithResponses) PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

func (c *ClientWithResponses) PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

// GetAuthoritiesWithResponse request returning *GetAuthoritiesResponse
func (c *ClientWithResponses) GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error) {
	rsp, err := c.GetAuthorities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthoritiesResponse(rsp)
}

// PostAuthoritiesWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesResponse
func (c *ClientWithResponses) PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthoritiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthorities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

// PostAuthoritiesCsrWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesCsrResponse
func (c *ClientWithResponses) PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsrWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsr(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

// DeleteAuthorityWithResponse request returning *DeleteAuthorityResponse
func (c *ClientWithResponses) DeleteAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error) {
	rsp, err := c.DeleteAuthority(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorityResponse(rsp)
}

// GetAuthorityWithResponse request returning *GetAuthorityResponse
func (c *ClientWithResponses) GetAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error) {
	rsp, err := c.GetAuthority(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorityResponse(rsp)
}

// ListAuthorityProvisionersWithResponse request returning *ListAuthorityProvisionersResponse
func (c *ClientWithResponses) ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error) {
	rsp, err := c.ListAuthorityProvisioners(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthorityProvisionersResponse(rsp)
}

// PostAuthorityProvisionersWithBodyWithResponse request with arbitrary body returning *PostAuthorityProvisionersResponse
func (c *ClientWithResponses) PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisionersWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisioners(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

// DeleteProvisionerWithResponse request returning *DeleteProvisionerResponse
func (c *ClientWithResponses) DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error) {
	rsp, err := c.DeleteProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProvisionerResponse(rsp)
}

// GetProvisionerWithResponse request returning *GetProvisionerResponse
func (c *ClientWithResponses) GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error) {
	rsp, err := c.GetProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProvisionerResponse(rsp)
}

// PostAuthorityRootWithBodyWithResponse request with arbitrary body returning *PostAuthorityRootResponse
func (c *ClientWithResponses) PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRootWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRoot(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

// GetSshGrantsWithResponse request returning *GetSshGrantsResponse
func (c *ClientWithResponses) GetSshGrantsWithResponse(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*GetSshGrantsResponse, error) {
	rsp, err := c.GetSshGrants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGrantsResponse(rsp)
}

// PostSshGrantsWithBodyWithResponse request with arbitrary body returning *PostSshGrantsResponse
func (c *ClientWithResponses) PostSshGrantsWithBodyWithResponse(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error) {
	rsp, err := c.PostSshGrantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSshGrantsResponse(rsp)
}

func (c *ClientWithResponses) PostSshGrantsWithResponse(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error) {
	rsp, err := c.PostSshGrants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSshGrantsResponse(rsp)
}

// DeleteSshGrantWithResponse request returning *DeleteSshGrantResponse
func (c *ClientWithResponses) DeleteSshGrantWithResponse(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*DeleteSshGrantResponse, error) {
	rsp, err := c.DeleteSshGrant(ctx, grantID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSshGrantResponse(rsp)
}

// GetSshGrantWithResponse request returning *GetSshGrantResponse
func (c *ClientWithResponses) GetSshGrantWithResponse(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*GetSshGrantResponse, error) {
	rsp, err := c.GetSshGrant(ctx, grantID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGrantResponse(rsp)
}

// GetSshGroupsWithResponse request returning *GetSshGroupsResponse
func (c *ClientWithResponses) GetSshGroupsWithResponse(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*GetSshGroupsResponse, error) {
	rsp, err := c.GetSshGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGroupsResponse(rsp)
}

// GetSshGroupWithResponse request returning *GetSshGroupResponse
func (c *ClientWithResponses) GetSshGroupWithResponse(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*GetSshGroupResponse, error) {
	rsp, err := c.GetSshGroup(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGroupResponse(rsp)
}

// GetSshHostsWithResponse request returning *GetSshHostsResponse
func (c *ClientWithResponses) GetSshHostsWithResponse(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*GetSshHostsResponse, error) {
	rsp, err := c.GetSshHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshHostsResponse(rsp)
}

// GetSshHostWithResponse request returning *GetSshHostResponse
func (c *ClientWithResponses) GetSshHostWithResponse(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*GetSshHostResponse, error) {
	rsp, err := c.GetSshHost(ctx, hostID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshHostResponse(rsp)
}

// PostHostsHostIDTagsWithBodyWithResponse request with arbitrary body returning *PostHostsHostIDTagsResponse
func (c *ClientWithResponses) PostHostsHostIDTagsWithBodyWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error) {
	rsp, err := c.PostHostsHostIDTagsWithBody(ctx, hostID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostsHostIDTagsResponse(rsp)
}

func (c *ClientWithResponses) PostHostsHostIDTagsWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error) {
	rsp, err := c.PostHostsHostIDTags(ctx, hostID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostsHostIDTagsResponse(rsp)
}

// UnregisterSshHostWithResponse request returning *UnregisterSshHostResponse
func (c *ClientWithResponses) UnregisterSshHostWithResponse(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*UnregisterSshHostResponse, error) {
	rsp, err := c.UnregisterSshHost(ctx, hostID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterSshHostResponse(rsp)
}

// ListInventoriesWithResponse request returning *ListInventoriesResponse
func (c *ClientWithResponses) ListInventoriesWithResponse(ctx context.Context, params *ListInventoriesParams, reqEditors ...RequestEditorFn) (*ListInventoriesResponse, error) {
	rsp, err := c.ListInventories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInventoriesResponse(rsp)
}

// PostInventoriesWithBodyWithResponse request with arbitrary body returning *PostInventoriesResponse
func (c *ClientWithResponses) PostInventoriesWithBodyWithResponse(ctx context.Context, params *PostInventoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoriesResponse, error) {
	rsp, err := c.PostInventoriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoriesResponse(rsp)
}

func (c *ClientWithResponses) PostInventoriesWithResponse(ctx context.Context, params *PostInventoriesParams, body PostInventoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoriesResponse, error) {
	rsp, err := c.PostInventories(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoriesResponse(rsp)
}

// DeleteInventoryWithResponse request returning *DeleteInventoryResponse
func (c *ClientWithResponses) DeleteInventoryWithResponse(ctx context.Context, inventorySlug InventorySlug, params *DeleteInventoryParams, reqEditors ...RequestEditorFn) (*DeleteInventoryResponse, error) {
	rsp, err := c.DeleteInventory(ctx, inventorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryResponse(rsp)
}

// GetInventoryWithResponse request returning *GetInventoryResponse
func (c *ClientWithResponses) GetInventoryWithResponse(ctx context.Context, inventorySlug InventorySlug, params *GetInventoryParams, reqEditors ...RequestEditorFn) (*GetInventoryResponse, error) {
	rsp, err := c.GetInventory(ctx, inventorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryResponse(rsp)
}

// ListInventoryItemsWithResponse request returning *ListInventoryItemsResponse
func (c *ClientWithResponses) ListInventoryItemsWithResponse(ctx context.Context, inventorySlug InventorySlug, params *ListInventoryItemsParams, reqEditors ...RequestEditorFn) (*ListInventoryItemsResponse, error) {
	rsp, err := c.ListInventoryItems(ctx, inventorySlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInventoryItemsResponse(rsp)
}

// DeleteInventoryItemWithResponse request returning *DeleteInventoryItemResponse
func (c *ClientWithResponses) DeleteInventoryItemWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *DeleteInventoryItemParams, reqEditors ...RequestEditorFn) (*DeleteInventoryItemResponse, error) {
	rsp, err := c.DeleteInventoryItem(ctx, inventorySlug, itemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryItemResponse(rsp)
}

// GetInventoryItemWithResponse request returning *GetInventoryItemResponse
func (c *ClientWithResponses) GetInventoryItemWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemParams, reqEditors ...RequestEditorFn) (*GetInventoryItemResponse, error) {
	rsp, err := c.GetInventoryItem(ctx, inventorySlug, itemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemResponse(rsp)
}

// PutInventoryItemWithBodyWithResponse request with arbitrary body returning *PutInventoryItemResponse
func (c *ClientWithResponses) PutInventoryItemWithBodyWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutInventoryItemResponse, error) {
	rsp, err := c.PutInventoryItemWithBody(ctx, inventorySlug, itemID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutInventoryItemResponse(rsp)
}

func (c *ClientWithResponses) PutInventoryItemWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemParams, body PutInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PutInventoryItemResponse, error) {
	rsp, err := c.PutInventoryItem(ctx, inventorySlug, itemID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutInventoryItemResponse(rsp)
}

// GetInventoryItemDataWithResponse request returning *GetInventoryItemDataResponse
func (c *ClientWithResponses) GetInventoryItemDataWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *GetInventoryItemDataParams, reqEditors ...RequestEditorFn) (*GetInventoryItemDataResponse, error) {
	rsp, err := c.GetInventoryItemData(ctx, inventorySlug, itemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemDataResponse(rsp)
}

// PutInventoryItemDataWithBodyWithResponse request with arbitrary body returning *PutInventoryItemDataResponse
func (c *ClientWithResponses) PutInventoryItemDataWithBodyWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutInventoryItemDataResponse, error) {
	rsp, err := c.PutInventoryItemDataWithBody(ctx, inventorySlug, itemID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutInventoryItemDataResponse(rsp)
}

func (c *ClientWithResponses) PutInventoryItemDataWithResponse(ctx context.Context, inventorySlug InventorySlug, itemID ItemID, params *PutInventoryItemDataParams, body PutInventoryItemDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PutInventoryItemDataResponse, error) {
	rsp, err := c.PutInventoryItemData(ctx, inventorySlug, itemID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutInventoryItemDataResponse(rsp)
}

// GetSshHostTagsWithResponse request returning *GetSshHostTagsResponse
func (c *ClientWithResponses) GetSshHostTagsWithResponse(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*GetSshHostTagsResponse, error) {
	rsp, err := c.GetSshHostTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshHostTagsResponse(rsp)
}

// GetSshUsersWithResponse request returning *GetSshUsersResponse
func (c *ClientWithResponses) GetSshUsersWithResponse(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*GetSshUsersResponse, error) {
	rsp, err := c.GetSshUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshUsersResponse(rsp)
}

// ParseGetAttestationAuthoritiesResponse parses an HTTP response from a GetAttestationAuthoritiesWithResponse call
func ParseGetAttestationAuthoritiesResponse(rsp *http.Response) (*GetAttestationAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttestationAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttestationAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAttestationAuthoritiesResponse parses an HTTP response from a PostAttestationAuthoritiesWithResponse call
func ParsePostAttestationAuthoritiesResponse(rsp *http.Response) (*PostAttestationAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttestationAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AttestationAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAttestationAuthorityResponse parses an HTTP response from a DeleteAttestationAuthorityWithResponse call
func ParseDeleteAttestationAuthorityResponse(rsp *http.Response) (*DeleteAttestationAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttestationAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAttestationAuthorityResponse parses an HTTP response from a GetAttestationAuthorityWithResponse call
func ParseGetAttestationAuthorityResponse(rsp *http.Response) (*GetAttestationAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttestationAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttestationAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthResponse parses an HTTP response from a PostAuthWithResponse call
func ParsePostAuthResponse(rsp *http.Response) (*PostAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthoritiesResponse parses an HTTP response from a GetAuthoritiesWithResponse call
func ParseGetAuthoritiesResponse(rsp *http.Response) (*GetAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesResponse parses an HTTP response from a PostAuthoritiesWithResponse call
func ParsePostAuthoritiesResponse(rsp *http.Response) (*PostAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesCsrResponse parses an HTTP response from a PostAuthoritiesCsrWithResponse call
func ParsePostAuthoritiesCsrResponse(rsp *http.Response) (*PostAuthoritiesCsrResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesCsrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthorityCsr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorityResponse parses an HTTP response from a DeleteAuthorityWithResponse call
func ParseDeleteAuthorityResponse(rsp *http.Response) (*DeleteAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthorityResponse parses an HTTP response from a GetAuthorityWithResponse call
func ParseGetAuthorityResponse(rsp *http.Response) (*GetAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuthorityProvisionersResponse parses an HTTP response from a ListAuthorityProvisionersWithResponse call
func ParseListAuthorityProvisionersResponse(rsp *http.Response) (*ListAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityProvisionersResponse parses an HTTP response from a PostAuthorityProvisionersWithResponse call
func ParsePostAuthorityProvisionersResponse(rsp *http.Response) (*PostAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProvisionerResponse parses an HTTP response from a DeleteProvisionerWithResponse call
func ParseDeleteProvisionerResponse(rsp *http.Response) (*DeleteProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProvisionerResponse parses an HTTP response from a GetProvisionerWithResponse call
func ParseGetProvisionerResponse(rsp *http.Response) (*GetProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityRootResponse parses an HTTP response from a PostAuthorityRootWithResponse call
func ParsePostAuthorityRootResponse(rsp *http.Response) (*PostAuthorityRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGrantsResponse parses an HTTP response from a GetSshGrantsWithResponse call
func ParseGetSshGrantsResponse(rsp *http.Response) (*GetSshGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Grant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSshGrantsResponse parses an HTTP response from a PostSshGrantsWithResponse call
func ParsePostSshGrantsResponse(rsp *http.Response) (*PostSshGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSshGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Grant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSshGrantResponse parses an HTTP response from a DeleteSshGrantWithResponse call
func ParseDeleteSshGrantResponse(rsp *http.Response) (*DeleteSshGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSshGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGrantResponse parses an HTTP response from a GetSshGrantWithResponse call
func ParseGetSshGrantResponse(rsp *http.Response) (*GetSshGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Grant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGroupsResponse parses an HTTP response from a GetSshGroupsWithResponse call
func ParseGetSshGroupsResponse(rsp *http.Response) (*GetSshGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGroupResponse parses an HTTP response from a GetSshGroupWithResponse call
func ParseGetSshGroupResponse(rsp *http.Response) (*GetSshGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshHostsResponse parses an HTTP response from a GetSshHostsWithResponse call
func ParseGetSshHostsResponse(rsp *http.Response) (*GetSshHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshHostResponse parses an HTTP response from a GetSshHostWithResponse call
func ParseGetSshHostResponse(rsp *http.Response) (*GetSshHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostHostsHostIDTagsResponse parses an HTTP response from a PostHostsHostIDTagsWithResponse call
func ParsePostHostsHostIDTagsResponse(rsp *http.Response) (*PostHostsHostIDTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHostsHostIDTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterSshHostResponse parses an HTTP response from a UnregisterSshHostWithResponse call
func ParseUnregisterSshHostResponse(rsp *http.Response) (*UnregisterSshHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterSshHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListInventoriesResponse parses an HTTP response from a ListInventoriesWithResponse call
func ParseListInventoriesResponse(rsp *http.Response) (*ListInventoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInventoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Inventory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoriesResponse parses an HTTP response from a PostInventoriesWithResponse call
func ParsePostInventoriesResponse(rsp *http.Response) (*PostInventoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Inventory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryResponse parses an HTTP response from a DeleteInventoryWithResponse call
func ParseDeleteInventoryResponse(rsp *http.Response) (*DeleteInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryResponse parses an HTTP response from a GetInventoryWithResponse call
func ParseGetInventoryResponse(rsp *http.Response) (*GetInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Inventory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListInventoryItemsResponse parses an HTTP response from a ListInventoryItemsWithResponse call
func ParseListInventoryItemsResponse(rsp *http.Response) (*ListInventoryItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInventoryItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []InventoryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryItemResponse parses an HTTP response from a DeleteInventoryItemWithResponse call
func ParseDeleteInventoryItemResponse(rsp *http.Response) (*DeleteInventoryItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemResponse parses an HTTP response from a GetInventoryItemWithResponse call
func ParseGetInventoryItemResponse(rsp *http.Response) (*GetInventoryItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InventoryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutInventoryItemResponse parses an HTTP response from a PutInventoryItemWithResponse call
func ParsePutInventoryItemResponse(rsp *http.Response) (*PutInventoryItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutInventoryItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InventoryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemDataResponse parses an HTTP response from a GetInventoryItemDataWithResponse call
func ParseGetInventoryItemDataResponse(rsp *http.Response) (*GetInventoryItemDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutInventoryItemDataResponse parses an HTTP response from a PutInventoryItemDataWithResponse call
func ParsePutInventoryItemDataResponse(rsp *http.Response) (*PutInventoryItemDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutInventoryItemDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshHostTagsResponse parses an HTTP response from a GetSshHostTagsWithResponse call
func ParseGetSshHostTagsResponse(rsp *http.Response) (*GetSshHostTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshHostTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshUsersResponse parses an HTTP response from a GetSshUsersWithResponse call
func ParseGetSshUsersResponse(rsp *http.Response) (*GetSshUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
