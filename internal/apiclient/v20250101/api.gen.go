// Package v20250101 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v20250101

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AcmeAttestationProvisionerAttestationFormats.
const (
	Apple AcmeAttestationProvisionerAttestationFormats = "apple"
	Step  AcmeAttestationProvisionerAttestationFormats = "step"
	Tpm   AcmeAttestationProvisionerAttestationFormats = "tpm"
)

// Defines values for AcmeProvisionerChallenges.
const (
	Dns01     AcmeProvisionerChallenges = "dns-01"
	Http01    AcmeProvisionerChallenges = "http-01"
	TlsAlpn01 AcmeProvisionerChallenges = "tls-alpn-01"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
	AuthorityTypeManaged  AuthorityType = "managed"
)

// Defines values for DeviceOS.
const (
	IOS      DeviceOS = "iOS"
	Linux    DeviceOS = "Linux"
	MacOS    DeviceOS = "macOS"
	TvOS     DeviceOS = "tvOS"
	VisionOS DeviceOS = "visionOS"
	WatchOS  DeviceOS = "watchOS"
	Windows  DeviceOS = "Windows"
)

// Defines values for DeviceOwnership.
const (
	Company DeviceOwnership = "company"
	User    DeviceOwnership = "user"
)

// Defines values for DevicePatchRemove.
const (
	DisplayId   DevicePatchRemove = "displayId"
	DisplayName DevicePatchRemove = "displayName"
	Metadata    DevicePatchRemove = "metadata"
	Os          DevicePatchRemove = "os"
	Ownership   DevicePatchRemove = "ownership"
	Serial      DevicePatchRemove = "serial"
	Tags        DevicePatchRemove = "tags"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for NewPlatformPlatformType.
const (
	NewPlatformPlatformTypeAws   NewPlatformPlatformType = "aws"
	NewPlatformPlatformTypeAzure NewPlatformPlatformType = "azure"
	NewPlatformPlatformTypeGcp   NewPlatformPlatformType = "gcp"
)

// Defines values for PlatformPlatformType.
const (
	PlatformPlatformTypeAws   PlatformPlatformType = "aws"
	PlatformPlatformTypeAzure PlatformPlatformType = "azure"
	PlatformPlatformTypeGcp   PlatformPlatformType = "gcp"
)

// Defines values for ProvisionerType.
const (
	ACME            ProvisionerType = "ACME"
	ACMEATTESTATION ProvisionerType = "ACME_ATTESTATION"
	AWS             ProvisionerType = "AWS"
	AZURE           ProvisionerType = "AZURE"
	GCP             ProvisionerType = "GCP"
	JWK             ProvisionerType = "JWK"
	OIDC            ProvisionerType = "OIDC"
	SCEP            ProvisionerType = "SCEP"
	X5C             ProvisionerType = "X5C"
)

// Defines values for ProvisionerWebhookCertType.
const (
	ALL  ProvisionerWebhookCertType = "ALL"
	SSH  ProvisionerWebhookCertType = "SSH"
	X509 ProvisionerWebhookCertType = "X509"
)

// Defines values for ProvisionerWebhookKind.
const (
	ENRICHING ProvisionerWebhookKind = "ENRICHING"
)

// Defines values for ProvisionerWebhookServerType.
const (
	EXTERNAL          ProvisionerWebhookServerType = "EXTERNAL"
	HOSTEDATTESTATION ProvisionerWebhookServerType = "HOSTED_ATTESTATION"
)

// Defines values for ScepProvisionerEncryptionAlgorithmIdentifier.
const (
	AES128CBC ScepProvisionerEncryptionAlgorithmIdentifier = "AES_128_CBC"
	AES128GCM ScepProvisionerEncryptionAlgorithmIdentifier = "AES_128_GCM"
	AES256CBC ScepProvisionerEncryptionAlgorithmIdentifier = "AES_256_CBC"
	AES256GCM ScepProvisionerEncryptionAlgorithmIdentifier = "AES_256_GCM"
	DESCBC    ScepProvisionerEncryptionAlgorithmIdentifier = "DES_CBC"
)

// Defines values for X509CertificateRevocationReason.
const (
	AACOMPROMISE         X509CertificateRevocationReason = "AA_COMPROMISE"
	AFFILIATIONCHANGED   X509CertificateRevocationReason = "AFFILIATION_CHANGED"
	CACOMPROMISE         X509CertificateRevocationReason = "CA_COMPROMISE"
	CERTIFICATEHOLD      X509CertificateRevocationReason = "CERTIFICATE_HOLD"
	CESSATIONOFOPERATION X509CertificateRevocationReason = "CESSATION_OF_OPERATION"
	KEYCOMPROMISE        X509CertificateRevocationReason = "KEY_COMPROMISE"
	PRIVILEGEWITHDRAWN   X509CertificateRevocationReason = "PRIVILEGE_WITHDRAWN"
	SUPERSEDED           X509CertificateRevocationReason = "SUPERSEDED"
	UNSPECIFIED          X509CertificateRevocationReason = "UNSPECIFIED"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// AcmeAttestationProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [device-attest-01 challenge of the ACME protocol](https://smallstep.com/blog/acme-managed-device-attestation-explained/).
type AcmeAttestationProvisioner struct {
	// AttestationFormats The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default.
	AttestationFormats []AcmeAttestationProvisionerAttestationFormats `json:"attestationFormats"`

	// AttestationRoots A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
	AttestationRoots *[]string `json:"attestationRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// AcmeAttestationProvisionerAttestationFormats defines model for AcmeAttestationProvisioner.AttestationFormats.
type AcmeAttestationProvisionerAttestationFormats string

// AcmeProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [ACME protocol](https://smallstep.com/docs/step-ca/acme-basics/#acme-challenges).
type AcmeProvisioner struct {
	// Challenges Which ACME challenge types are allowed.
	Challenges []AcmeProvisionerChallenges `json:"challenges"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
	RequireEAB bool `json:"requireEAB"`
}

// AcmeProvisionerChallenges defines model for AcmeProvisioner.Challenges.
type AcmeProvisionerChallenges string

// Authority An X509 authority hosted by Smallstep.
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only).
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created.
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached.
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority.
	Id string `json:"id"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Root The root certificate in pem format.
	Root *string `json:"root,omitempty"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root.
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority.
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format.
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR.
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// AwsAccounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
type AwsAccounts = []string

// AwsDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
type AwsDisableCustomSANs = bool

// AwsPlatform Configuration for an AWS platform.
type AwsPlatform struct {
	AccountId string `json:"accountId"`

	// Name A friendly name for this AWS account.
	Name string `json:"name"`

	// RoleArn A role ARN that allows the Smallstep Platform to manage resources on your behalf.
	RoleArn *string `json:"roleArn,omitempty"`
}

// AwsProvisioner The [AWS provisioner](https://smallstep.com/docs/step-ca/provisioners/#aws) grants a certificate to an Amazon EC2 instance using the Instance Identity Document.
type AwsProvisioner struct {
	// Accounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
	Accounts AwsAccounts `json:"accounts"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
	DisableCustomSANs *AwsDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`
}

// AzureAudience Defaults to https://management.azure.com/ but it can be changed if necessary.
type AzureAudience = string

// AzureDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
type AzureDisableCustomSANs = bool

// AzurePlatform Microsoft Azure
type AzurePlatform struct {
	// ClientId The client ID of an Azure Service Principal that allows the Smallstep Platform to manage resources on your behalf.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecret The client secret of an Azure Service Principal that allows the Smallstep Platform to manage resources on your behalf.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Name A friendly name for this Azure connection
	Name string `json:"name"`

	// ResourceGroups A list of resource groups that are allowed to enroll with the Smallstep Platform.
	ResourceGroups []string `json:"resourceGroups"`

	// TenantId The Azure Entra tenant ID
	TenantId string `json:"tenantId"`
}

// AzureProvisioner The [Azure provisioner](https://smallstep.com/docs/step-ca/provisioners/#azure) grants certificates to Microsoft Azure instances using the managed identities tokens.
type AzureProvisioner struct {
	// Audience Defaults to https://management.azure.com/ but it can be changed if necessary.
	Audience *AzureAudience `json:"audience,omitempty"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
	DisableCustomSANs *AzureDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// ResourceGroups The list of resource group names that are allowed to use this provisioner.
	ResourceGroups AzureResourceGroups `json:"resourceGroups"`

	// TenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
	TenantID AzureTenantID `json:"tenantID"`
}

// AzureResourceGroups The list of resource group names that are allowed to use this provisioner.
type AzureResourceGroups = []string

// AzureTenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
type AzureTenantID = string

// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
type BasicAuth struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// BasicConstraints defines model for basicConstraints.
type BasicConstraints struct {
	IsCA       bool `json:"isCA"`
	MaxPathLen int  `json:"maxPathLen"`
}

// Device defines model for device.
type Device struct {
	// ApprovedAt Timestamp in RFC3339 format when the device was approved to connect to company resources. Read only.
	ApprovedAt *time.Time `json:"approvedAt,omitempty"`

	// Connected The device is currently connected to Smallstep. Read only.
	Connected bool `json:"connected"`

	// DisplayId An opaque identifier that may be used to link this device to an external inventory.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayId *DeviceDisplayId `json:"displayId,omitempty"`

	// DisplayName A friendly name for the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayName *DeviceDisplayName `json:"displayName,omitempty"`

	// EnrolledAt Timestamp in RFC3339 format when the device first connected to Smallstep. Read only.
	EnrolledAt *time.Time `json:"enrolledAt,omitempty"`

	// HighAssurance The device has been issued certificates using high assurance device attestation. Read only.
	HighAssurance bool `json:"highAssurance"`

	// Id A UUID identifying this device. Read only.
	Id string `json:"id"`

	// LastSeen Timestamp in RFC3339 format when the device last connected to Smallstep. Read only.
	LastSeen *time.Time `json:"lastSeen,omitempty"`

	// Metadata A set of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
	Metadata *DeviceMetadata `json:"metadata,omitempty"`

	// Os The device operating system.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Os *DeviceOS `json:"os,omitempty"`

	// Ownership Whether the device is owned by the user or the company.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Ownership *DeviceOwnership `json:"ownership,omitempty"`

	// PermanentIdentifier The cryptographic identity of the device. High-assurance devices are only issued certificates when this identifier is attested by a trusted source. All devices with the same permanent identifier appear as a single device in the Smallstep API. For Windows and Linux devices this is the hash of the TPM endorsement key and for Apple devices it is the serial number.
	PermanentIdentifier string `json:"permanentIdentifier"`

	// Serial The serial number of the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Serial *DeviceSerial `json:"serial,omitempty"`

	// Tags A set of tags that can be used to group devices.
	Tags *DeviceTags `json:"tags,omitempty"`
	User *DeviceUser `json:"user,omitempty"`
}

// DeviceDisplayId An opaque identifier that may be used to link this device to an external inventory.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceDisplayId = string

// DeviceDisplayName A friendly name for the device.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceDisplayName = string

// DeviceMetadata A set of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
type DeviceMetadata = []DeviceMetadataItem

// DeviceMetadataItem defines model for deviceMetadataItem.
type DeviceMetadataItem struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// DeviceOS The device operating system.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceOS string

// DeviceOwnership Whether the device is owned by the user or the company.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceOwnership string

// DevicePatch Data that can be modified on an existing device.
type DevicePatch struct {
	// DisplayId An opaque identifier that may be used to link this device to an external inventory.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayId *DeviceDisplayId `json:"displayId,omitempty"`

	// DisplayName A friendly name for the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayName *DeviceDisplayName `json:"displayName,omitempty"`

	// Metadata A set of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
	Metadata *DeviceMetadata `json:"metadata,omitempty"`

	// Os The device operating system.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Os *DeviceOS `json:"os,omitempty"`

	// Ownership Whether the device is owned by the user or the company.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Ownership *DeviceOwnership `json:"ownership,omitempty"`

	// Remove Some device fields may be populated with a value derived from data synced from your team's MDMs.
	// Any data that is explicitly set by API or with the Smallstep dashboard will mask MDM-derived values.
	// Use this list to specify fields that should be unset. If the device includes data synced from an MDM
	// this will result in the fields being populated with values derived from the MDM data. Otherwise the
	// removed fields will be empty.
	Remove *[]DevicePatchRemove `json:"remove,omitempty"`

	// Serial The serial number of the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Serial *DeviceSerial `json:"serial,omitempty"`

	// Tags A set of tags that can be used to group devices.
	Tags *DeviceTags `json:"tags,omitempty"`
}

// DevicePatchRemove defines model for DevicePatch.Remove.
type DevicePatchRemove string

// DeviceRequest Data that can be added to a device record.
type DeviceRequest struct {
	// DisplayId An opaque identifier that may be used to link this device to an external inventory.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayId *DeviceDisplayId `json:"displayId,omitempty"`

	// DisplayName A friendly name for the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayName *DeviceDisplayName `json:"displayName,omitempty"`

	// Metadata A set of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
	Metadata *DeviceMetadata `json:"metadata,omitempty"`

	// Os The device operating system.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Os *DeviceOS `json:"os,omitempty"`

	// Ownership Whether the device is owned by the user or the company.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Ownership *DeviceOwnership `json:"ownership,omitempty"`

	// PermanentIdentifier The cryptographic identity of the device. High-assurance devices are only issued certificates when this identifier is attested by a trusted source. All devices with the same permanent identifier appear as a single device in the Smallstep API. For Windows and Linux devices this is the hash of the TPM endorsement key and for Apple devices it is the serial number.
	PermanentIdentifier string `json:"permanentIdentifier"`

	// Serial The serial number of the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Serial *DeviceSerial `json:"serial,omitempty"`

	// Tags A set of tags that can be used to group devices.
	Tags *DeviceTags `json:"tags,omitempty"`
	User *DeviceUser `json:"user,omitempty"`
}

// DeviceSerial The serial number of the device.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceSerial = string

// DeviceTags A set of tags that can be used to group devices.
type DeviceTags = []string

// DeviceUser defines model for deviceUser.
type DeviceUser struct {
	// DisplayName Full name of the user the device is assigned to. Synced from team's identity provider. Read only.
	DisplayName *string `json:"displayName,omitempty"`

	// Email Email of the user the device is assigned to.
	// Setting this value will mask any value synced from an MDM.
	Email string `json:"email"`
}

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizationalUnit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error.
	Message string `json:"message"`
}

// ExtraName defines model for extraName.
type ExtraName struct {
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

// GcpDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
type GcpDisableCustomSANs = bool

// GcpPlatform Google Cloud Platform
type GcpPlatform struct {
	// Name A friendly name for this GCP connection
	Name string `json:"name"`

	// ProjectIds The project IDs where the resources are located.
	ProjectIds []string `json:"projectIds"`

	// ServiceAccountKey A JSON-formatted service account key that allows the Smallstep Platform to manage resources on your behalf.
	ServiceAccountKey *string `json:"serviceAccountKey,omitempty"`

	// ServiceAccounts GCE service accounts that are allowed to enroll with the Smallstep Platform.
	ServiceAccounts *[]string `json:"serviceAccounts,omitempty"`
}

// GcpProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
type GcpProjectIDs = []string

// GcpProvisioner The [GCP provisioner](https://smallstep.com/docs/step-ca/provisioners/#gcp) grants a certificate to a Google Compute Engine instance using its identity token. At least one service account or project ID must be set.
type GcpProvisioner struct {
	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
	DisableCustomSANs *GcpDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`

	// ProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
	ProjectIDs *GcpProjectIDs `json:"projectIDs,omitempty"`

	// ServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
	ServiceAccounts *GcpServiceAccounts `json:"serviceAccounts,omitempty"`
}

// GcpServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
type GcpServiceAccounts = []string

// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
type InstanceAge = string

// JwkProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#jwk) that uses public-key cryptography to sign and validate a JSON Web Token (JWT).
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key.
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key.
	Key interface{} `json:"key"`
}

// NameConstraints X509 certificate name constratins.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical.
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority.
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority.
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority.
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority.
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority.
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority.
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root.
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`
}

// NewPlatform Configuration to create a new platform.
type NewPlatform struct {
	DisplayName           string                            `json:"displayName"`
	PlatformConfiguration NewPlatform_PlatformConfiguration `json:"platformConfiguration"`

	// PlatformType Determines which set of fields to use in platformConfiguration. Cannot be changed.
	PlatformType NewPlatformPlatformType `json:"platformType"`
	Slug         string                  `json:"slug"`
}

// NewPlatform_PlatformConfiguration defines model for NewPlatform.PlatformConfiguration.
type NewPlatform_PlatformConfiguration struct {
	union json.RawMessage
}

// NewPlatformPlatformType Determines which set of fields to use in platformConfiguration. Cannot be changed.
type NewPlatformPlatformType string

// OidcProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#oauthoidc-single-sign-on) that is configured to trust and accept an OAuth provider's ID tokens for authentication. By default, the issued certificate will use the subject (sub) claim from the identity token as its subject. The value of the token's email claim is also included as an email SAN in the certificate.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// Platform A platform with a list of configurations.
type Platform struct {
	DisplayName            string                                 `json:"displayName"`
	PlatformConfigurations []Platform_PlatformConfigurations_Item `json:"platformConfigurations"`

	// PlatformType The type used in platformConfiguration.
	PlatformType PlatformPlatformType `json:"platformType"`
	Slug         string               `json:"slug"`
}

// Platform_PlatformConfigurations_Item defines model for platform.platformConfigurations.Item.
type Platform_PlatformConfigurations_Item struct {
	union json.RawMessage
}

// PlatformPlatformType The type used in platformConfiguration.
type PlatformPlatformType string

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner.
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner.
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh      *SshOptions           `json:"ssh,omitempty"`
	Webhooks *[]ProvisionerWebhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates.
	X509 *X509Options `json:"x509,omitempty"`
}

// ProvisionerWebhook A [webhook](https://smallstep.com/docs/step-ca/webhooks/) to call when a certificate request is being processed.
type ProvisionerWebhook struct {
	// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BasicAuth *BasicAuth `json:"basicAuth,omitempty"`

	// BearerToken Webhook requests will include an Authorization header with the token. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BearerToken *string                    `json:"bearerToken,omitempty"`
	CertType    ProvisionerWebhookCertType `json:"certType"`

	// CollectionSlug For HOSTED_ATTESTATION webhooks, the collectionSlug is a reference to the collection that holds the devices that may be issued certificates. This collection must already exist. Required for `HOSTED_ATTESTATION` webhook servers; not allowed for `EXTERNAL`.
	CollectionSlug *string `json:"collectionSlug,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created. Will be sent to the webhook server in every request in the `X-Smallstep-Webhook-ID` header.
	Id *string `json:"id,omitempty"`

	// Kind The webhook kind indicates how and when it is called.
	//
	// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
	Kind ProvisionerWebhookKind `json:"kind"`

	// Name The name of the webhook. For `ENRICHING` webhooks, the returned data can be referenced in the certificate under the path `.Webhooks.<name>`. Must be unique to the provisioner.
	Name string `json:"name"`

	// Secret The shared secret used to authenticate the payload sent to the webhook server. Generated server-side. This is returned only for `EXTERNAL` webhook servers and only once, at the time of creation.
	Secret *string `json:"secret,omitempty"`

	// ServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
	//
	// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
	ServerType ProvisionerWebhookServerType `json:"serverType"`

	// Url The URL of the webhook server. Required for `EXTERNAL` webhook servers; read-only for hosted webhook servers.
	Url *string `json:"url,omitempty"`
}

// ProvisionerWebhookCertType defines model for ProvisionerWebhook.CertType.
type ProvisionerWebhookCertType string

// ProvisionerWebhookKind The webhook kind indicates how and when it is called.
//
// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
type ProvisionerWebhookKind string

// ProvisionerWebhookServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
//
// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
type ProvisionerWebhookServerType string

// ScepProvisioner The [SCEP provisioner](https://smallstep.com/docs/step-ca/provisioners/#scep) grants certificates to clients using the SCEP protocol. This type is currently experimental and subject to change.
type ScepProvisioner struct {
	// AutogenerateDecrypter Automatically generate a new RSA decrypter instead of providing one.
	AutogenerateDecrypter *bool `json:"autogenerateDecrypter,omitempty"`

	// Challenge A static challenge secret.
	Challenge *string `json:"challenge,omitempty"`

	// DecrypterCertificate A pem-encoded certificate for an RSA public key.
	DecrypterCertificate *string `json:"decrypterCertificate,omitempty"`

	// DecrypterKey The pem-encoded RSA private key, corresponding to the certificate public key.
	DecrypterKey *string `json:"decrypterKey,omitempty"`

	// DecrypterKeyPassword The password for the pem-encoded RSA private key, if any.
	DecrypterKeyPassword *string `json:"decrypterKeyPassword,omitempty"`

	// EncryptionAlgorithmIdentifier The encryption algorithm used for encrypting responses to the SCEP client:
	//  * `DES_CBC`    - [DES in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.1) - `1.3.14.3.2.7`
	//  * `AES_128_CBC` - [AES-128 in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.5) - `2.16.840.1.101.3.4.1.2`
	//  * `AES_128_GCM` - [AES-128 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.6`
	//  * `AES_256_CBC` - [AES-256 in CBC mode](https://www.rfc-editor.org/rfc/rfc3565.html#section-4.1) - `2.16.840.1.101.3.4.1.42`
	//  * `AES_256_GCM` - [AES-256 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.46`
	EncryptionAlgorithmIdentifier *ScepProvisionerEncryptionAlgorithmIdentifier `json:"encryptionAlgorithmIdentifier,omitempty"`

	// ExcludeIntermediate Exclude the intermediate CA certificate in SCEP responses.
	ExcludeIntermediate *bool `json:"excludeIntermediate,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// IncludeRoot Include the root CA certificate in SCEP responses.
	IncludeRoot *bool `json:"includeRoot,omitempty"`

	// MinimumPublicKeyLength The minimum number of bits for RSA public keys accepted in SCEP requests.
	MinimumPublicKeyLength *int `json:"minimumPublicKeyLength,omitempty"`
}

// ScepProvisionerEncryptionAlgorithmIdentifier The encryption algorithm used for encrypting responses to the SCEP client:
//   - `DES_CBC`    - [DES in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.1) - `1.3.14.3.2.7`
//   - `AES_128_CBC` - [AES-128 in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.5) - `2.16.840.1.101.3.4.1.2`
//   - `AES_128_GCM` - [AES-128 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.6`
//   - `AES_256_CBC` - [AES-256 in CBC mode](https://www.rfc-editor.org/rfc/rfc3565.html#section-4.1) - `2.16.840.1.101.3.4.1.42`
//   - `AES_256_GCM` - [AES-256 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.46`
type ScepProvisionerEncryptionAlgorithmIdentifier string

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Subject Name used in x509 certificates
type Subject struct {
	CommonName         *string      `json:"commonName,omitempty"`
	Country            *[]string    `json:"country,omitempty"`
	EmailAddress       *[]string    `json:"emailAddress,omitempty"`
	ExtraNames         *[]ExtraName `json:"extraNames,omitempty"`
	Locality           *[]string    `json:"locality,omitempty"`
	Organization       *[]string    `json:"organization,omitempty"`
	OrganizationalUnit *[]string    `json:"organizationalUnit,omitempty"`
	PostalCode         *[]string    `json:"postalCode,omitempty"`
	Province           *[]string    `json:"province,omitempty"`
	SerialNumber       *string      `json:"serialNumber,omitempty"`
	StreetAddress      *[]string    `json:"streetAddress,omitempty"`
}

// X509Certificate defines model for x509Certificate.
type X509Certificate struct {
	AuthorityKeyId        string           `json:"authorityKeyId"`
	BasicConstraints      BasicConstraints `json:"basicConstraints"`
	CrlDistributionPoints *[]string        `json:"crlDistributionPoints,omitempty"`
	DnsNames              *[]string        `json:"dnsNames,omitempty"`
	EmailAddresses        *[]string        `json:"emailAddresses,omitempty"`
	ExtKeyUsage           *[]string        `json:"extKeyUsage,omitempty"`
	IpAddresses           *[]string        `json:"ipAddresses,omitempty"`

	// Issuer Name used in x509 certificates
	Issuer                Subject   `json:"issuer"`
	IssuingCertificateURL *[]string `json:"issuingCertificateURL,omitempty"`
	KeyUsage              []string  `json:"keyUsage"`

	// NameConstraints X509 certificate name constratins.
	NameConstraints    *NameConstraints                 `json:"nameConstraints,omitempty"`
	OcspServer         *[]string                        `json:"ocspServer,omitempty"`
	Pem                string                           `json:"pem"`
	PolicyIdentifiers  *[]string                        `json:"policyIdentifiers,omitempty"`
	RevocationReason   *X509CertificateRevocationReason `json:"revocationReason,omitempty"`
	Revoked            *bool                            `json:"revoked,omitempty"`
	SerialNumber       string                           `json:"serialNumber"`
	SignatureAlgorithm string                           `json:"signatureAlgorithm"`

	// Subject Name used in x509 certificates
	Subject      Subject   `json:"subject"`
	SubjectKeyId string    `json:"subjectKeyId"`
	Uris         *[]string `json:"uris,omitempty"`
	Version      int       `json:"version"`
}

// X509CertificateRevocationReason defines model for X509Certificate.RevocationReason.
type X509CertificateRevocationReason string

// X509Issuer A Customized X509 issuer for an authority.
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm.
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer.
	Name string `json:"name"`

	// NameConstraints X509 certificate name constratins.
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm.
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates.
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// X5cProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#x5c---x509-certificate) that authenticates a certificate request with an existing x509 certificate.
type X5cProvisioner struct {
	// Roots A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
	Roots []string `json:"roots"`
}

// Accept defines model for accept.
type Accept = string

// AuthorityDomainOrID defines model for authorityDomainOrID.
type AuthorityDomainOrID = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// DeviceID defines model for deviceID.
type DeviceID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// PlatformSlug defines model for platformSlug.
type PlatformSlug = string

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// SerialNumber defines model for serialNumber.
type SerialNumber = string

// WebhookNameOrID defines model for webhookNameOrID.
type WebhookNameOrID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N422 defines model for 422.
type N422 = Error

// N500 defines model for 500.
type N500 = Error

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
	TeamSlug *string                   `json:"teamSlug,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostWebhooksParams defines parameters for PostWebhooks.
type PostWebhooksParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWebhookParams defines parameters for DeleteWebhook.
type DeleteWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListCertificatesParams defines parameters for ListCertificates.
type ListCertificatesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCertificateParams defines parameters for GetCertificate.
type GetCertificateParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostDevicesParams defines parameters for PostDevices.
type PostDevicesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetPlatformsParams defines parameters for GetPlatforms.
type GetPlatformsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutPlatformParams defines parameters for PutPlatform.
type PutPlatformParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostWebhooksJSONRequestBody defines body for PostWebhooks for application/json ContentType.
type PostWebhooksJSONRequestBody = ProvisionerWebhook

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostDevicesJSONRequestBody defines body for PostDevices for application/json ContentType.
type PostDevicesJSONRequestBody = DeviceRequest

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody = DevicePatch

// PutPlatformJSONRequestBody defines body for PutPlatform for application/json ContentType.
type PutPlatformJSONRequestBody = NewPlatform

// AsAwsPlatform returns the union data inside the NewPlatform_PlatformConfiguration as a AwsPlatform
func (t NewPlatform_PlatformConfiguration) AsAwsPlatform() (AwsPlatform, error) {
	var body AwsPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsPlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided AwsPlatform
func (t *NewPlatform_PlatformConfiguration) FromAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsPlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided AwsPlatform
func (t *NewPlatform_PlatformConfiguration) MergeAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzurePlatform returns the union data inside the NewPlatform_PlatformConfiguration as a AzurePlatform
func (t NewPlatform_PlatformConfiguration) AsAzurePlatform() (AzurePlatform, error) {
	var body AzurePlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzurePlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided AzurePlatform
func (t *NewPlatform_PlatformConfiguration) FromAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzurePlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided AzurePlatform
func (t *NewPlatform_PlatformConfiguration) MergeAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGcpPlatform returns the union data inside the NewPlatform_PlatformConfiguration as a GcpPlatform
func (t NewPlatform_PlatformConfiguration) AsGcpPlatform() (GcpPlatform, error) {
	var body GcpPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpPlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided GcpPlatform
func (t *NewPlatform_PlatformConfiguration) FromGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpPlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided GcpPlatform
func (t *NewPlatform_PlatformConfiguration) MergeGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewPlatform_PlatformConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewPlatform_PlatformConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsPlatform returns the union data inside the Platform_PlatformConfigurations_Item as a AwsPlatform
func (t Platform_PlatformConfigurations_Item) AsAwsPlatform() (AwsPlatform, error) {
	var body AwsPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsPlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided AwsPlatform
func (t *Platform_PlatformConfigurations_Item) FromAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsPlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided AwsPlatform
func (t *Platform_PlatformConfigurations_Item) MergeAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzurePlatform returns the union data inside the Platform_PlatformConfigurations_Item as a AzurePlatform
func (t Platform_PlatformConfigurations_Item) AsAzurePlatform() (AzurePlatform, error) {
	var body AzurePlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzurePlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided AzurePlatform
func (t *Platform_PlatformConfigurations_Item) FromAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzurePlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided AzurePlatform
func (t *Platform_PlatformConfigurations_Item) MergeAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGcpPlatform returns the union data inside the Platform_PlatformConfigurations_Item as a GcpPlatform
func (t Platform_PlatformConfigurations_Item) AsGcpPlatform() (GcpPlatform, error) {
	var body GcpPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpPlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided GcpPlatform
func (t *Platform_PlatformConfigurations_Item) FromGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpPlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided GcpPlatform
func (t *Platform_PlatformConfigurations_Item) MergeGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Platform_PlatformConfigurations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Platform_PlatformConfigurations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAcmeProvisioner returns the union data inside the Provisioner as a AcmeProvisioner
func (t Provisioner) AsAcmeProvisioner() (AcmeProvisioner, error) {
	var body AcmeProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeProvisioner overwrites any union data inside the Provisioner as the provided AcmeProvisioner
func (t *Provisioner) FromAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeProvisioner
func (t *Provisioner) MergeAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAcmeAttestationProvisioner returns the union data inside the Provisioner as a AcmeAttestationProvisioner
func (t Provisioner) AsAcmeAttestationProvisioner() (AcmeAttestationProvisioner, error) {
	var body AcmeAttestationProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeAttestationProvisioner overwrites any union data inside the Provisioner as the provided AcmeAttestationProvisioner
func (t *Provisioner) FromAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeAttestationProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeAttestationProvisioner
func (t *Provisioner) MergeAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsX5cProvisioner returns the union data inside the Provisioner as a X5cProvisioner
func (t Provisioner) AsX5cProvisioner() (X5cProvisioner, error) {
	var body X5cProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX5cProvisioner overwrites any union data inside the Provisioner as the provided X5cProvisioner
func (t *Provisioner) FromX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX5cProvisioner performs a merge with any union data inside the Provisioner, using the provided X5cProvisioner
func (t *Provisioner) MergeX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAwsProvisioner returns the union data inside the Provisioner as a AwsProvisioner
func (t Provisioner) AsAwsProvisioner() (AwsProvisioner, error) {
	var body AwsProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsProvisioner overwrites any union data inside the Provisioner as the provided AwsProvisioner
func (t *Provisioner) FromAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsProvisioner performs a merge with any union data inside the Provisioner, using the provided AwsProvisioner
func (t *Provisioner) MergeAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGcpProvisioner returns the union data inside the Provisioner as a GcpProvisioner
func (t Provisioner) AsGcpProvisioner() (GcpProvisioner, error) {
	var body GcpProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpProvisioner overwrites any union data inside the Provisioner as the provided GcpProvisioner
func (t *Provisioner) FromGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpProvisioner performs a merge with any union data inside the Provisioner, using the provided GcpProvisioner
func (t *Provisioner) MergeGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureProvisioner returns the union data inside the Provisioner as a AzureProvisioner
func (t Provisioner) AsAzureProvisioner() (AzureProvisioner, error) {
	var body AzureProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureProvisioner overwrites any union data inside the Provisioner as the provided AzureProvisioner
func (t *Provisioner) FromAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureProvisioner performs a merge with any union data inside the Provisioner, using the provided AzureProvisioner
func (t *Provisioner) MergeAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScepProvisioner returns the union data inside the Provisioner as a ScepProvisioner
func (t Provisioner) AsScepProvisioner() (ScepProvisioner, error) {
	var body ScepProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScepProvisioner overwrites any union data inside the Provisioner as the provided ScepProvisioner
func (t *Provisioner) FromScepProvisioner(v ScepProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScepProvisioner performs a merge with any union data inside the Provisioner, using the provided ScepProvisioner
func (t *Provisioner) MergeScepProvisioner(v ScepProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAuthWithBody request with any body
	PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorities request
	GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthoritiesWithBody request with any body
	PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthoritiesCsrWithBody request with any body
	PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthority request
	DeleteAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthority request
	GetAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthorityProvisioners request
	ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityProvisionersWithBody request with any body
	PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProvisioner request
	DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProvisioner request
	GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooksWithBody request with any body
	PostWebhooksWithBody(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWebhooks(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityRootWithBody request with any body
	PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCertificates request
	ListCertificates(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificate request
	GetCertificate(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDevicesWithBody request with any body
	PostDevicesWithBody(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDevices(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDevice request
	DeleteDevice(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDevice request
	GetDevice(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchDeviceWithBody request with any body
	PatchDeviceWithBody(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchDevice(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatforms request
	GetPlatforms(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPlatformWithBody request with any body
	PutPlatformWithBody(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPlatform(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthoritiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorityRequest(c.Server, authorityDomainOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorityRequest(c.Server, authorityDomainOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthorityProvisionersRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWithBody(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequestWithBody(c.Server, authorityID, provisionerNameOrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooks(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequest(c.Server, authorityID, provisionerNameOrID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, authorityID, provisionerNameOrID, webhookNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, authorityID, provisionerNameOrID, webhookNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCertificates(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificate(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateRequest(c.Server, serialNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDevicesWithBody(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDevicesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDevices(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDevicesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDevice(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceRequest(c.Server, deviceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDevice(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceRequest(c.Server, deviceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDeviceWithBody(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDeviceRequestWithBody(c.Server, deviceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDevice(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDeviceRequest(c.Server, deviceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatforms(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlatformWithBody(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlatformRequestWithBody(c.Server, platformSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlatform(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlatformRequest(c.Server, platformSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAuthRequest calls the generic PostAuth builder with application/json body
func NewPostAuthRequest(server string, body PostAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthRequestWithBody generates requests for PostAuth with any type of body
func NewPostAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthoritiesRequest generates requests for GetAuthorities
func NewGetAuthoritiesRequest(server string, params *GetAuthoritiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthoritiesRequest calls the generic PostAuthorities builder with application/json body
func NewPostAuthoritiesRequest(server string, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesRequestWithBody generates requests for PostAuthorities with any type of body
func NewPostAuthoritiesRequestWithBody(server string, params *PostAuthoritiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthoritiesCsrRequest calls the generic PostAuthoritiesCsr builder with application/json body
func NewPostAuthoritiesCsrRequest(server string, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesCsrRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesCsrRequestWithBody generates requests for PostAuthoritiesCsr with any type of body
func NewPostAuthoritiesCsrRequestWithBody(server string, params *PostAuthoritiesCsrParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/csr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteAuthorityRequest generates requests for DeleteAuthority
func NewDeleteAuthorityRequest(server string, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityDomainOrID", runtime.ParamLocationPath, authorityDomainOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetAuthorityRequest generates requests for GetAuthority
func NewGetAuthorityRequest(server string, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityDomainOrID", runtime.ParamLocationPath, authorityDomainOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListAuthorityProvisionersRequest generates requests for ListAuthorityProvisioners
func NewListAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *ListAuthorityProvisionersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthorityProvisionersRequest calls the generic PostAuthorityProvisioners builder with application/json body
func NewPostAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityProvisionersRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityProvisionersRequestWithBody generates requests for PostAuthorityProvisioners with any type of body
func NewPostAuthorityProvisionersRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteProvisionerRequest generates requests for DeleteProvisioner
func NewDeleteProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetProvisionerRequest generates requests for GetProvisioner
func NewGetProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostWebhooksRequest calls the generic PostWebhooks builder with application/json body
func NewPostWebhooksRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWebhooksRequestWithBody(server, authorityID, provisionerNameOrID, params, "application/json", bodyReader)
}

// NewPostWebhooksRequestWithBody generates requests for PostWebhooks with any type of body
func NewPostWebhooksRequestWithBody(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, webhookNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, webhookNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthorityRootRequest calls the generic PostAuthorityRoot builder with application/json body
func NewPostAuthorityRootRequest(server string, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityRootRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityRootRequestWithBody generates requests for PostAuthorityRoot with any type of body
func NewPostAuthorityRootRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/root", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListCertificatesRequest generates requests for ListCertificates
func NewListCertificatesRequest(server string, params *ListCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetCertificateRequest generates requests for GetCertificate
func NewGetCertificateRequest(server string, serialNumber SerialNumber, params *GetCertificateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serialNumber", runtime.ParamLocationPath, serialNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostDevicesRequest calls the generic PostDevices builder with application/json body
func NewPostDevicesRequest(server string, params *PostDevicesParams, body PostDevicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDevicesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostDevicesRequestWithBody generates requests for PostDevices with any type of body
func NewPostDevicesRequestWithBody(server string, params *PostDevicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteDeviceRequest generates requests for DeleteDevice
func NewDeleteDeviceRequest(server string, deviceID DeviceID, params *DeleteDeviceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deviceID", runtime.ParamLocationPath, deviceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetDeviceRequest generates requests for GetDevice
func NewGetDeviceRequest(server string, deviceID DeviceID, params *GetDeviceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deviceID", runtime.ParamLocationPath, deviceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPatchDeviceRequest calls the generic PatchDevice builder with application/json body
func NewPatchDeviceRequest(server string, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchDeviceRequestWithBody(server, deviceID, params, "application/json", bodyReader)
}

// NewPatchDeviceRequestWithBody generates requests for PatchDevice with any type of body
func NewPatchDeviceRequestWithBody(server string, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deviceID", runtime.ParamLocationPath, deviceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetPlatformsRequest generates requests for GetPlatforms
func NewGetPlatformsRequest(server string, params *GetPlatformsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutPlatformRequest calls the generic PutPlatform builder with application/json body
func NewPutPlatformRequest(server string, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPlatformRequestWithBody(server, platformSlug, params, "application/json", bodyReader)
}

// NewPutPlatformRequestWithBody generates requests for PutPlatform with any type of body
func NewPutPlatformRequestWithBody(server string, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platformSlug", runtime.ParamLocationPath, platformSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platforms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAuthWithBodyWithResponse request with any body
	PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	// GetAuthoritiesWithResponse request
	GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error)

	// PostAuthoritiesWithBodyWithResponse request with any body
	PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	// PostAuthoritiesCsrWithBodyWithResponse request with any body
	PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	// DeleteAuthorityWithResponse request
	DeleteAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error)

	// GetAuthorityWithResponse request
	GetAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error)

	// ListAuthorityProvisionersWithResponse request
	ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error)

	// PostAuthorityProvisionersWithBodyWithResponse request with any body
	PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	// DeleteProvisionerWithResponse request
	DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error)

	// GetProvisionerWithResponse request
	GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error)

	// PostWebhooksWithBodyWithResponse request with any body
	PostWebhooksWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	PostWebhooksWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// PostAuthorityRootWithBodyWithResponse request with any body
	PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	// ListCertificatesWithResponse request
	ListCertificatesWithResponse(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*ListCertificatesResponse, error)

	// GetCertificateWithResponse request
	GetCertificateWithResponse(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*GetCertificateResponse, error)

	// PostDevicesWithBodyWithResponse request with any body
	PostDevicesWithBodyWithResponse(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error)

	PostDevicesWithResponse(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error)

	// DeleteDeviceWithResponse request
	DeleteDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error)

	// GetDeviceWithResponse request
	GetDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*GetDeviceResponse, error)

	// PatchDeviceWithBodyWithResponse request with any body
	PatchDeviceWithBodyWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error)

	PatchDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error)

	// GetPlatformsWithResponse request
	GetPlatformsWithResponse(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*GetPlatformsResponse, error)

	// PutPlatformWithBodyWithResponse request with any body
	PutPlatformWithBodyWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error)

	PutPlatformWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error)
}

type PostAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Token *string `json:"token,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Authority
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Authority
	JSON400      *N400
	JSON401      *N401
	JSON409      *N409
	JSON412      *N412
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesCsrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthorityCsr
	JSON400      *N400
	JSON401      *N401
	JSON409      *N409
	JSON412      *N412
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesCsrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesCsrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Provisioner
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Provisioner
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Provisioner
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProvisionerWebhook
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON409      *N409
	JSON412      *N412
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProvisionerWebhook
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthorityRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]X509Certificate
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *X509Certificate
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Device
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON404      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Platform
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlatformsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Platform
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAuthWithBodyWithResponse request with arbitrary body returning *PostAuthResponse
func (c *ClientWithResponses) PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

func (c *ClientWithResponses) PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

// GetAuthoritiesWithResponse request returning *GetAuthoritiesResponse
func (c *ClientWithResponses) GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error) {
	rsp, err := c.GetAuthorities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthoritiesResponse(rsp)
}

// PostAuthoritiesWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesResponse
func (c *ClientWithResponses) PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthoritiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthorities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

// PostAuthoritiesCsrWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesCsrResponse
func (c *ClientWithResponses) PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsrWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsr(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

// DeleteAuthorityWithResponse request returning *DeleteAuthorityResponse
func (c *ClientWithResponses) DeleteAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error) {
	rsp, err := c.DeleteAuthority(ctx, authorityDomainOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorityResponse(rsp)
}

// GetAuthorityWithResponse request returning *GetAuthorityResponse
func (c *ClientWithResponses) GetAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error) {
	rsp, err := c.GetAuthority(ctx, authorityDomainOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorityResponse(rsp)
}

// ListAuthorityProvisionersWithResponse request returning *ListAuthorityProvisionersResponse
func (c *ClientWithResponses) ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error) {
	rsp, err := c.ListAuthorityProvisioners(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthorityProvisionersResponse(rsp)
}

// PostAuthorityProvisionersWithBodyWithResponse request with arbitrary body returning *PostAuthorityProvisionersResponse
func (c *ClientWithResponses) PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisionersWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisioners(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

// DeleteProvisionerWithResponse request returning *DeleteProvisionerResponse
func (c *ClientWithResponses) DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error) {
	rsp, err := c.DeleteProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProvisionerResponse(rsp)
}

// GetProvisionerWithResponse request returning *GetProvisionerResponse
func (c *ClientWithResponses) GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error) {
	rsp, err := c.GetProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProvisionerResponse(rsp)
}

// PostWebhooksWithBodyWithResponse request with arbitrary body returning *PostWebhooksResponse
func (c *ClientWithResponses) PostWebhooksWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooksWithBody(ctx, authorityID, provisionerNameOrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

func (c *ClientWithResponses) PostWebhooksWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooks(ctx, authorityID, provisionerNameOrID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, authorityID, provisionerNameOrID, webhookNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, authorityID, provisionerNameOrID, webhookNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// PostAuthorityRootWithBodyWithResponse request with arbitrary body returning *PostAuthorityRootResponse
func (c *ClientWithResponses) PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRootWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRoot(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

// ListCertificatesWithResponse request returning *ListCertificatesResponse
func (c *ClientWithResponses) ListCertificatesWithResponse(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*ListCertificatesResponse, error) {
	rsp, err := c.ListCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCertificatesResponse(rsp)
}

// GetCertificateWithResponse request returning *GetCertificateResponse
func (c *ClientWithResponses) GetCertificateWithResponse(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*GetCertificateResponse, error) {
	rsp, err := c.GetCertificate(ctx, serialNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateResponse(rsp)
}

// PostDevicesWithBodyWithResponse request with arbitrary body returning *PostDevicesResponse
func (c *ClientWithResponses) PostDevicesWithBodyWithResponse(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error) {
	rsp, err := c.PostDevicesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDevicesResponse(rsp)
}

func (c *ClientWithResponses) PostDevicesWithResponse(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error) {
	rsp, err := c.PostDevices(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDevicesResponse(rsp)
}

// DeleteDeviceWithResponse request returning *DeleteDeviceResponse
func (c *ClientWithResponses) DeleteDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error) {
	rsp, err := c.DeleteDevice(ctx, deviceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceResponse(rsp)
}

// GetDeviceWithResponse request returning *GetDeviceResponse
func (c *ClientWithResponses) GetDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*GetDeviceResponse, error) {
	rsp, err := c.GetDevice(ctx, deviceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceResponse(rsp)
}

// PatchDeviceWithBodyWithResponse request with arbitrary body returning *PatchDeviceResponse
func (c *ClientWithResponses) PatchDeviceWithBodyWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error) {
	rsp, err := c.PatchDeviceWithBody(ctx, deviceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDeviceResponse(rsp)
}

func (c *ClientWithResponses) PatchDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error) {
	rsp, err := c.PatchDevice(ctx, deviceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDeviceResponse(rsp)
}

// GetPlatformsWithResponse request returning *GetPlatformsResponse
func (c *ClientWithResponses) GetPlatformsWithResponse(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*GetPlatformsResponse, error) {
	rsp, err := c.GetPlatforms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformsResponse(rsp)
}

// PutPlatformWithBodyWithResponse request with arbitrary body returning *PutPlatformResponse
func (c *ClientWithResponses) PutPlatformWithBodyWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error) {
	rsp, err := c.PutPlatformWithBody(ctx, platformSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlatformResponse(rsp)
}

func (c *ClientWithResponses) PutPlatformWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error) {
	rsp, err := c.PutPlatform(ctx, platformSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlatformResponse(rsp)
}

// ParsePostAuthResponse parses an HTTP response from a PostAuthWithResponse call
func ParsePostAuthResponse(rsp *http.Response) (*PostAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthoritiesResponse parses an HTTP response from a GetAuthoritiesWithResponse call
func ParseGetAuthoritiesResponse(rsp *http.Response) (*GetAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesResponse parses an HTTP response from a PostAuthoritiesWithResponse call
func ParsePostAuthoritiesResponse(rsp *http.Response) (*PostAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesCsrResponse parses an HTTP response from a PostAuthoritiesCsrWithResponse call
func ParsePostAuthoritiesCsrResponse(rsp *http.Response) (*PostAuthoritiesCsrResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesCsrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthorityCsr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorityResponse parses an HTTP response from a DeleteAuthorityWithResponse call
func ParseDeleteAuthorityResponse(rsp *http.Response) (*DeleteAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthorityResponse parses an HTTP response from a GetAuthorityWithResponse call
func ParseGetAuthorityResponse(rsp *http.Response) (*GetAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuthorityProvisionersResponse parses an HTTP response from a ListAuthorityProvisionersWithResponse call
func ParseListAuthorityProvisionersResponse(rsp *http.Response) (*ListAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityProvisionersResponse parses an HTTP response from a PostAuthorityProvisionersWithResponse call
func ParsePostAuthorityProvisionersResponse(rsp *http.Response) (*PostAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProvisionerResponse parses an HTTP response from a DeleteProvisionerWithResponse call
func ParseDeleteProvisionerResponse(rsp *http.Response) (*DeleteProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProvisionerResponse parses an HTTP response from a GetProvisionerWithResponse call
func ParseGetProvisionerResponse(rsp *http.Response) (*GetProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWebhooksResponse parses an HTTP response from a PostWebhooksWithResponse call
func ParsePostWebhooksResponse(rsp *http.Response) (*PostWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProvisionerWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProvisionerWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityRootResponse parses an HTTP response from a PostAuthorityRootWithResponse call
func ParsePostAuthorityRootResponse(rsp *http.Response) (*PostAuthorityRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCertificatesResponse parses an HTTP response from a ListCertificatesWithResponse call
func ParseListCertificatesResponse(rsp *http.Response) (*ListCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []X509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateResponse parses an HTTP response from a GetCertificateWithResponse call
func ParseGetCertificateResponse(rsp *http.Response) (*GetCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest X509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDevicesResponse parses an HTTP response from a PostDevicesWithResponse call
func ParsePostDevicesResponse(rsp *http.Response) (*PostDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDeviceResponse parses an HTTP response from a DeleteDeviceWithResponse call
func ParseDeleteDeviceResponse(rsp *http.Response) (*DeleteDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDeviceResponse parses an HTTP response from a GetDeviceWithResponse call
func ParseGetDeviceResponse(rsp *http.Response) (*GetDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchDeviceResponse parses an HTTP response from a PatchDeviceWithResponse call
func ParsePatchDeviceResponse(rsp *http.Response) (*PatchDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformsResponse parses an HTTP response from a GetPlatformsWithResponse call
func ParseGetPlatformsResponse(rsp *http.Response) (*GetPlatformsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Platform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutPlatformResponse parses an HTTP response from a PutPlatformWithResponse call
func ParsePutPlatformResponse(rsp *http.Response) (*PutPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Platform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//5PVeIeXDgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
