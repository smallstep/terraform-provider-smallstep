// Package v20250101 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v20250101

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AccountType.
const (
	AccountTypeBrowser  AccountType = "browser"
	AccountTypeEthernet AccountType = "ethernet"
	AccountTypeVpn      AccountType = "vpn"
	AccountTypeWifi     AccountType = "wifi"
)

// Defines values for AccountRequestType.
const (
	AccountRequestTypeBrowser  AccountRequestType = "browser"
	AccountRequestTypeEthernet AccountRequestType = "ethernet"
	AccountRequestTypeVpn      AccountRequestType = "vpn"
	AccountRequestTypeWifi     AccountRequestType = "wifi"
)

// Defines values for AcmeAttestationProvisionerAttestationFormats.
const (
	Apple AcmeAttestationProvisionerAttestationFormats = "apple"
	Step  AcmeAttestationProvisionerAttestationFormats = "step"
	Tpm   AcmeAttestationProvisionerAttestationFormats = "tpm"
)

// Defines values for AcmeProvisionerChallenges.
const (
	Dns01     AcmeProvisionerChallenges = "dns-01"
	Http01    AcmeProvisionerChallenges = "http-01"
	TlsAlpn01 AcmeProvisionerChallenges = "tls-alpn-01"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
	AuthorityTypeManaged  AuthorityType = "managed"
)

// Defines values for CredentialCertificateType.
const (
	CredentialCertificateTypeX509 CredentialCertificateType = "X509"
)

// Defines values for CredentialFilesKeyFormat.
const (
	CredentialFilesKeyFormatCLASSIC CredentialFilesKeyFormat = "CLASSIC"
	CredentialFilesKeyFormatDEFAULT CredentialFilesKeyFormat = "DEFAULT"
	CredentialFilesKeyFormatOPENSSH CredentialFilesKeyFormat = "OPENSSH"
	CredentialFilesKeyFormatPKCS8   CredentialFilesKeyFormat = "PKCS8"
	CredentialFilesKeyFormatTSS2    CredentialFilesKeyFormat = "TSS2"
)

// Defines values for CredentialKeyProtection.
const (
	CredentialKeyProtectionHARDWARE             CredentialKeyProtection = "HARDWARE"
	CredentialKeyProtectionHARDWAREATTESTED     CredentialKeyProtection = "HARDWARE_ATTESTED"
	CredentialKeyProtectionHARDWAREWITHFALLBACK CredentialKeyProtection = "HARDWARE_WITH_FALLBACK"
	CredentialKeyProtectionNONE                 CredentialKeyProtection = "NONE"
)

// Defines values for CredentialKeyType.
const (
	CredentialKeyTypeDEFAULT   CredentialKeyType = "DEFAULT"
	CredentialKeyTypeECDSAP256 CredentialKeyType = "ECDSA_P256"
	CredentialKeyTypeECDSAP384 CredentialKeyType = "ECDSA_P384"
	CredentialKeyTypeECDSAP521 CredentialKeyType = "ECDSA_P521"
	CredentialKeyTypeED25519   CredentialKeyType = "ED25519"
	CredentialKeyTypeRSA2048   CredentialKeyType = "RSA_2048"
	CredentialKeyTypeRSA3072   CredentialKeyType = "RSA_3072"
	CredentialKeyTypeRSA4096   CredentialKeyType = "RSA_4096"
)

// Defines values for DeviceAssurance.
const (
	High   DeviceAssurance = "high"
	Normal DeviceAssurance = "normal"
)

// Defines values for DeviceDiscoverySource.
const (
	EndUser        DeviceDiscoverySource = "End-User"
	Intune         DeviceDiscoverySource = "Intune"
	Jamf           DeviceDiscoverySource = "Jamf"
	SmallstepAPI   DeviceDiscoverySource = "Smallstep API"
	SmallstepAgent DeviceDiscoverySource = "Smallstep Agent"
)

// Defines values for DeviceOS.
const (
	IOS      DeviceOS = "iOS"
	Linux    DeviceOS = "Linux"
	MacOS    DeviceOS = "macOS"
	TvOS     DeviceOS = "tvOS"
	VisionOS DeviceOS = "visionOS"
	WatchOS  DeviceOS = "watchOS"
	Windows  DeviceOS = "Windows"
)

// Defines values for DeviceOwnership.
const (
	Company DeviceOwnership = "company"
	User    DeviceOwnership = "user"
)

// Defines values for DeviceStatus.
const (
	DeviceStatusError   DeviceStatus = "error"
	DeviceStatusOk      DeviceStatus = "ok"
	DeviceStatusWarning DeviceStatus = "warning"
)

// Defines values for EndpointCertificateInfoType.
const (
	EndpointCertificateInfoTypeSSHHOST EndpointCertificateInfoType = "SSH_HOST"
	EndpointCertificateInfoTypeSSHUSER EndpointCertificateInfoType = "SSH_USER"
	EndpointCertificateInfoTypeX509    EndpointCertificateInfoType = "X509"
)

// Defines values for EndpointConfigurationExtendedType.
const (
	EndpointConfigurationExtendedTypeBrowser  EndpointConfigurationExtendedType = "browser"
	EndpointConfigurationExtendedTypeEthernet EndpointConfigurationExtendedType = "ethernet"
	EndpointConfigurationExtendedTypeVpn      EndpointConfigurationExtendedType = "vpn"
	EndpointConfigurationExtendedTypeWifi     EndpointConfigurationExtendedType = "wifi"
)

// Defines values for EndpointConfigurationKind.
const (
	EndpointConfigurationKindAccount  EndpointConfigurationKind = "account"
	EndpointConfigurationKindDevice   EndpointConfigurationKind = "device"
	EndpointConfigurationKindWorkload EndpointConfigurationKind = "workload"
)

// Defines values for EndpointConfigurationRequestExtendedType.
const (
	EndpointConfigurationRequestExtendedTypeBrowser  EndpointConfigurationRequestExtendedType = "browser"
	EndpointConfigurationRequestExtendedTypeEthernet EndpointConfigurationRequestExtendedType = "ethernet"
	EndpointConfigurationRequestExtendedTypeVpn      EndpointConfigurationRequestExtendedType = "vpn"
	EndpointConfigurationRequestExtendedTypeWifi     EndpointConfigurationRequestExtendedType = "wifi"
)

// Defines values for EndpointConfigurationRequestKind.
const (
	EndpointConfigurationRequestKindAccount  EndpointConfigurationRequestKind = "account"
	EndpointConfigurationRequestKindDevice   EndpointConfigurationRequestKind = "device"
	EndpointConfigurationRequestKindWorkload EndpointConfigurationRequestKind = "workload"
)

// Defines values for EndpointKeyInfoFormat.
const (
	EndpointKeyInfoFormatCLASSIC EndpointKeyInfoFormat = "CLASSIC"
	EndpointKeyInfoFormatDEFAULT EndpointKeyInfoFormat = "DEFAULT"
	EndpointKeyInfoFormatOPENSSH EndpointKeyInfoFormat = "OPENSSH"
	EndpointKeyInfoFormatPKCS8   EndpointKeyInfoFormat = "PKCS8"
	EndpointKeyInfoFormatTSS2    EndpointKeyInfoFormat = "TSS2"
)

// Defines values for EndpointKeyInfoProtection.
const (
	EndpointKeyInfoProtectionDEFAULT              EndpointKeyInfoProtection = "DEFAULT"
	EndpointKeyInfoProtectionHARDWARE             EndpointKeyInfoProtection = "HARDWARE"
	EndpointKeyInfoProtectionHARDWAREATTESTED     EndpointKeyInfoProtection = "HARDWARE_ATTESTED"
	EndpointKeyInfoProtectionHARDWAREWITHFALLBACK EndpointKeyInfoProtection = "HARDWARE_WITH_FALLBACK"
	EndpointKeyInfoProtectionNONE                 EndpointKeyInfoProtection = "NONE"
)

// Defines values for EndpointKeyInfoType.
const (
	EndpointKeyInfoTypeDEFAULT   EndpointKeyInfoType = "DEFAULT"
	EndpointKeyInfoTypeECDSAP256 EndpointKeyInfoType = "ECDSA_P256"
	EndpointKeyInfoTypeECDSAP384 EndpointKeyInfoType = "ECDSA_P384"
	EndpointKeyInfoTypeECDSAP521 EndpointKeyInfoType = "ECDSA_P521"
	EndpointKeyInfoTypeED25519   EndpointKeyInfoType = "ED25519"
	EndpointKeyInfoTypeRSA2048   EndpointKeyInfoType = "RSA_2048"
	EndpointKeyInfoTypeRSA3072   EndpointKeyInfoType = "RSA_3072"
	EndpointKeyInfoTypeRSA4096   EndpointKeyInfoType = "RSA_4096"
)

// Defines values for EndpointReloadInfoMethod.
const (
	AUTOMATIC EndpointReloadInfoMethod = "AUTOMATIC"
	CUSTOM    EndpointReloadInfoMethod = "CUSTOM"
	DBUS      EndpointReloadInfoMethod = "DBUS"
	PLATFORM  EndpointReloadInfoMethod = "PLATFORM"
	SIGNAL    EndpointReloadInfoMethod = "SIGNAL"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for NewPlatformPlatformType.
const (
	NewPlatformPlatformTypeAws   NewPlatformPlatformType = "aws"
	NewPlatformPlatformTypeAzure NewPlatformPlatformType = "azure"
	NewPlatformPlatformTypeGcp   NewPlatformPlatformType = "gcp"
)

// Defines values for PlatformPlatformType.
const (
	PlatformPlatformTypeAws   PlatformPlatformType = "aws"
	PlatformPlatformTypeAzure PlatformPlatformType = "azure"
	PlatformPlatformTypeGcp   PlatformPlatformType = "gcp"
)

// Defines values for ProvisionerType.
const (
	ACME            ProvisionerType = "ACME"
	ACMEATTESTATION ProvisionerType = "ACME_ATTESTATION"
	AWS             ProvisionerType = "AWS"
	AZURE           ProvisionerType = "AZURE"
	GCP             ProvisionerType = "GCP"
	JWK             ProvisionerType = "JWK"
	OIDC            ProvisionerType = "OIDC"
	SCEP            ProvisionerType = "SCEP"
	X5C             ProvisionerType = "X5C"
)

// Defines values for ProvisionerWebhookCertType.
const (
	ALL  ProvisionerWebhookCertType = "ALL"
	SSH  ProvisionerWebhookCertType = "SSH"
	X509 ProvisionerWebhookCertType = "X509"
)

// Defines values for ProvisionerWebhookKind.
const (
	ENRICHING ProvisionerWebhookKind = "ENRICHING"
)

// Defines values for ProvisionerWebhookServerType.
const (
	EXTERNAL          ProvisionerWebhookServerType = "EXTERNAL"
	HOSTEDATTESTATION ProvisionerWebhookServerType = "HOSTED_ATTESTATION"
)

// Defines values for ScepProvisionerEncryptionAlgorithmIdentifier.
const (
	AES128CBC ScepProvisionerEncryptionAlgorithmIdentifier = "AES_128_CBC"
	AES128GCM ScepProvisionerEncryptionAlgorithmIdentifier = "AES_128_GCM"
	AES256CBC ScepProvisionerEncryptionAlgorithmIdentifier = "AES_256_CBC"
	AES256GCM ScepProvisionerEncryptionAlgorithmIdentifier = "AES_256_GCM"
	DESCBC    ScepProvisionerEncryptionAlgorithmIdentifier = "DES_CBC"
)

// Defines values for VpnType.
const (
	IKEv2 VpnType = "IKEv2"
	IPSec VpnType = "IPSec"
	SSL   VpnType = "SSL"
)

// Defines values for VpnVendor.
const (
	Cisco   VpnVendor = "Cisco"
	F5      VpnVendor = "F5"
	Juniper VpnVendor = "Juniper"
)

// Defines values for X509CertificateRevocationReason.
const (
	AACOMPROMISE         X509CertificateRevocationReason = "AA_COMPROMISE"
	AFFILIATIONCHANGED   X509CertificateRevocationReason = "AFFILIATION_CHANGED"
	CACOMPROMISE         X509CertificateRevocationReason = "CA_COMPROMISE"
	CERTIFICATEHOLD      X509CertificateRevocationReason = "CERTIFICATE_HOLD"
	CESSATIONOFOPERATION X509CertificateRevocationReason = "CESSATION_OF_OPERATION"
	KEYCOMPROMISE        X509CertificateRevocationReason = "KEY_COMPROMISE"
	PRIVILEGEWITHDRAWN   X509CertificateRevocationReason = "PRIVILEGE_WITHDRAWN"
	SUPERSEDED           X509CertificateRevocationReason = "SUPERSEDED"
	UNSPECIFIED          X509CertificateRevocationReason = "UNSPECIFIED"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// Defines values for ListDevicesParamsSortField.
const (
	EnrolledAt ListDevicesParamsSortField = "enrolledAt"
	LastSeen   ListDevicesParamsSortField = "lastSeen"
	Source     ListDevicesParamsSortField = "source"
)

// Account defines model for account.
type Account struct {
	// CertificateInfo Details on a managed certificate.
	CertificateInfo *EndpointCertificateInfo `json:"certificateInfo,omitempty"`
	Configuration   *Account_Configuration   `json:"configuration,omitempty"`

	// Id A UUID identifying this account. Read only.
	Id string `json:"id"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// Name A human-friendly name for this account.
	Name string `json:"name"`

	// Policy Policy to select the devices an account is assigned to. An empty policy indicates an account will be provisioned for all devices.
	Policy *PolicyMatchCriteria `json:"policy,omitempty"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`

	// Type The type of configuration settings for this account.
	Type *AccountType `json:"type,omitempty"`
}

// Account_Configuration defines model for Account.Configuration.
type Account_Configuration struct {
	union json.RawMessage
}

// AccountType The type of configuration settings for this account.
type AccountType string

// AccountRequest The configuration settings of an account.
type AccountRequest struct {
	// CertificateInfo Details on a managed certificate.
	CertificateInfo *EndpointCertificateInfo      `json:"certificateInfo,omitempty"`
	Configuration   *AccountRequest_Configuration `json:"configuration,omitempty"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// Name A human-friendly name for this account.
	Name string `json:"name"`

	// Policy Policy to select the devices an account is assigned to. An empty policy indicates an account will be provisioned for all devices.
	Policy *PolicyMatchCriteria `json:"policy,omitempty"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`

	// Type The type of configuration settings for this account.
	Type *AccountRequestType `json:"type,omitempty"`
}

// AccountRequest_Configuration defines model for AccountRequest.Configuration.
type AccountRequest_Configuration struct {
	union json.RawMessage
}

// AccountRequestType The type of configuration settings for this account.
type AccountRequestType string

// AcmeAttestationProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [device-attest-01 challenge of the ACME protocol](https://smallstep.com/blog/acme-managed-device-attestation-explained/).
type AcmeAttestationProvisioner struct {
	// AttestationFormats The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default.
	AttestationFormats []AcmeAttestationProvisionerAttestationFormats `json:"attestationFormats"`

	// AttestationRoots A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
	AttestationRoots *[]string `json:"attestationRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// AcmeAttestationProvisionerAttestationFormats defines model for AcmeAttestationProvisioner.AttestationFormats.
type AcmeAttestationProvisionerAttestationFormats string

// AcmeProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [ACME protocol](https://smallstep.com/docs/step-ca/acme-basics/#acme-challenges).
type AcmeProvisioner struct {
	// Challenges Which ACME challenge types are allowed.
	Challenges []AcmeProvisionerChallenges `json:"challenges"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
	RequireEAB bool `json:"requireEAB"`
}

// AcmeProvisionerChallenges defines model for AcmeProvisioner.Challenges.
type AcmeProvisionerChallenges string

// Authority An X509 authority hosted by Smallstep.
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only).
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created.
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached.
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority.
	Id string `json:"id"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Root The root certificate in pem format.
	Root *string `json:"root,omitempty"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root.
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority.
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format.
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR.
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// AwsAccounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
type AwsAccounts = []string

// AwsDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
type AwsDisableCustomSANs = bool

// AwsPlatform Configuration for an AWS platform.
type AwsPlatform struct {
	AccountId string `json:"accountId"`

	// Name A friendly name for this AWS account.
	Name string `json:"name"`

	// RoleArn A role ARN that allows the Smallstep Platform to manage resources on your behalf.
	RoleArn *string `json:"roleArn,omitempty"`
}

// AwsProvisioner The [AWS provisioner](https://smallstep.com/docs/step-ca/provisioners/#aws) grants a certificate to an Amazon EC2 instance using the Instance Identity Document.
type AwsProvisioner struct {
	// Accounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
	Accounts AwsAccounts `json:"accounts"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
	DisableCustomSANs *AwsDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`
}

// AzureAudience Defaults to https://management.azure.com/ but it can be changed if necessary.
type AzureAudience = string

// AzureDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
type AzureDisableCustomSANs = bool

// AzurePlatform Microsoft Azure
type AzurePlatform struct {
	// ClientId The client ID of an Azure Service Principal that allows the Smallstep Platform to manage resources on your behalf.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecret The client secret of an Azure Service Principal that allows the Smallstep Platform to manage resources on your behalf.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Name A friendly name for this Azure connection
	Name string `json:"name"`

	// ResourceGroups A list of resource groups that are allowed to enroll with the Smallstep Platform.
	ResourceGroups []string `json:"resourceGroups"`

	// TenantId The Azure Entra tenant ID
	TenantId string `json:"tenantId"`
}

// AzureProvisioner The [Azure provisioner](https://smallstep.com/docs/step-ca/provisioners/#azure) grants certificates to Microsoft Azure instances using the managed identities tokens.
type AzureProvisioner struct {
	// Audience Defaults to https://management.azure.com/ but it can be changed if necessary.
	Audience *AzureAudience `json:"audience,omitempty"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
	DisableCustomSANs *AzureDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// ResourceGroups The list of resource group names that are allowed to use this provisioner.
	ResourceGroups AzureResourceGroups `json:"resourceGroups"`

	// TenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
	TenantID AzureTenantID `json:"tenantID"`
}

// AzureResourceGroups The list of resource group names that are allowed to use this provisioner.
type AzureResourceGroups = []string

// AzureTenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
type AzureTenantID = string

// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
type BasicAuth struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// BasicConstraints defines model for basicConstraints.
type BasicConstraints struct {
	IsCA       bool `json:"isCA"`
	MaxPathLen int  `json:"maxPathLen"`
}

// Browser defines model for browser.
type Browser struct {
	// Credentials The UUID of credentials that the Smallstep agent will configure to use this browser integration.
	Credentials    []string `json:"credentials"`
	Id             *string  `json:"id,omitempty"`
	MatchAddresses []string `json:"matchAddresses"`
	Name           *string  `json:"name,omitempty"`
}

// BrowserAccount Configuration to use a client certificate.
type BrowserAccount = map[string]interface{}

// CertificateField A certificate field that takes a single string value, e.g. Common Name. Static values are used as a fallback when device metadata is not present.
type CertificateField struct {
	// DeviceMetadata A value populated from a key in the device's metadata.
	DeviceMetadata *string `json:"deviceMetadata,omitempty"`

	// Static A literal value.
	Static *string `json:"static,omitempty"`
}

// CertificateFieldList A certificate field that accepts multiple string values, e.g. SANs.
type CertificateFieldList struct {
	// DeviceMetadata A value populated from a key in the device's metadata.
	DeviceMetadata *[]string `json:"deviceMetadata,omitempty"`

	// Static A literal value.
	Static *[]string `json:"static,omitempty"`
}

// Credential A certificate key pair.
type Credential struct {
	Certificate CredentialCertificate `json:"certificate"`
	Files       *CredentialFiles      `json:"files,omitempty"`

	// Id A UUID identifying this credential. Read only.
	Id *string `json:"id,omitempty"`

	// Key The attributes of the cryptographic key. Key `type` and `protection` are required unless the `pubFile` is set.
	Key CredentialKey `json:"key"`

	// Policy Policy to select the devices an account is assigned to. An empty policy indicates an account will be provisioned for all devices.
	Policy *PolicyMatchCriteria `json:"policy,omitempty"`
	Slug   string               `json:"slug"`
}

// CredentialCertificate defines model for credentialCertificate.
type CredentialCertificate struct {
	// AuthorityID A UUID identifying the authority that issues certificates for the credential.
	AuthorityID *string `json:"authorityID,omitempty"`

	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string                      `json:"duration,omitempty"`
	Fields   CredentialCertificate_Fields `json:"fields"`
	Type     CredentialCertificateType    `json:"type"`
}

// CredentialCertificate_Fields defines model for CredentialCertificate.Fields.
type CredentialCertificate_Fields struct {
	union json.RawMessage
}

// CredentialCertificateType defines model for CredentialCertificate.Type.
type CredentialCertificateType string

// CredentialFiles defines model for credentialFiles.
type CredentialFiles struct {
	// CrtFile The filepath where the certificate is to be stored.
	CrtFile *string `json:"crtFile,omitempty"`

	// Gid GID of the files where the credential is stored.
	Gid *int `json:"gid,omitempty"`

	// KeyFile The filepath where the key is to be stored.
	KeyFile *string `json:"keyFile,omitempty"`

	// KeyFormat The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux tss2 will be used.
	KeyFormat *CredentialFilesKeyFormat `json:"keyFormat,omitempty"`

	// Mode Permission bits of the files where the credential is stored.
	Mode *int `json:"mode,omitempty"`

	// RootFile The filepath where the root certificate is to be stored.
	RootFile *string `json:"rootFile,omitempty"`

	// Uid UID of the files where the credential is stored.
	Uid *int `json:"uid,omitempty"`
}

// CredentialFilesKeyFormat The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux tss2 will be used.
type CredentialFilesKeyFormat string

// CredentialKey The attributes of the cryptographic key. Key `type` and `protection` are required unless the `pubFile` is set.
type CredentialKey struct {
	// Protection Whether to use a hardware module to store the private key. If set to `NONE` no hardware module will be used. `HARDWARE_WITH_FALLBACK` can only be used with the key file format `DEFAULT`.
	Protection *CredentialKeyProtection `json:"protection,omitempty"`

	// PubFile A CSR or SSH public key to use instead of generating one. Cannot be used in conjunction with key type, key protection, key file or key file format.
	PubFile *string `json:"pubFile,omitempty"`

	// Type The key type used. The current default type is `ECDSA_P256` but is not fixed at the time the credential resource is created - new keys generated for this credential in the future may have a different type.
	Type *CredentialKeyType `json:"type,omitempty"`
}

// CredentialKeyProtection Whether to use a hardware module to store the private key. If set to `NONE` no hardware module will be used. `HARDWARE_WITH_FALLBACK` can only be used with the key file format `DEFAULT`.
type CredentialKeyProtection string

// CredentialKeyType The key type used. The current default type is `ECDSA_P256` but is not fixed at the time the credential resource is created - new keys generated for this credential in the future may have a different type.
type CredentialKeyType string

// Device defines model for device.
type Device struct {
	// ApprovedAt Timestamp in RFC3339 format when the device was approved to connect to company resources. Read only.
	ApprovedAt *time.Time `json:"approvedAt,omitempty"`

	// Connected The device is currently connected to Smallstep. Read only.
	Connected bool `json:"connected"`

	// DisplayId An opaque identifier that may be used to link this device to an external inventory.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayId *DeviceDisplayId `json:"displayId,omitempty"`

	// DisplayName A friendly name for the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayName *DeviceDisplayName `json:"displayName,omitempty"`

	// EnrolledAt Timestamp in RFC3339 format when the device first connected to Smallstep. Read only.
	EnrolledAt *time.Time `json:"enrolledAt,omitempty"`

	// HighAssurance The device has been issued certificates using high assurance device attestation. Read only.
	HighAssurance bool `json:"highAssurance"`

	// HostID The identifier for the smallstep agent on the device.
	HostID *string `json:"hostID,omitempty"`

	// Id A UUID identifying this device. Read only.
	Id string `json:"id"`

	// LastSeen Timestamp in RFC3339 format when the device last connected to Smallstep. Read only.
	LastSeen *time.Time `json:"lastSeen,omitempty"`

	// Metadata A map of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
	Metadata *DeviceMetadata `json:"metadata,omitempty"`

	// Os The device operating system.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Os *DeviceOS `json:"os,omitempty"`

	// Ownership Whether the device is owned by the user or the company.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Ownership *DeviceOwnership `json:"ownership,omitempty"`

	// PermanentIdentifier The cryptographic identity of the device. High-assurance devices are only issued certificates when this identifier is attested by a trusted source. All devices with the same permanent identifier appear as a single device in the Smallstep API. For Windows and Linux devices this is the hash of the TPM endorsement key and for Apple devices it is the serial number.
	PermanentIdentifier string `json:"permanentIdentifier"`

	// Serial The serial number of the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Serial *DeviceSerial `json:"serial,omitempty"`

	// Tags A set of tags that can be used to group devices.
	Tags *DeviceTags `json:"tags,omitempty"`

	// User The user that a device is assigned to. A device cannot be approved for high-assurance certificates until a user has been assigned to it.
	User *DeviceUser `json:"user,omitempty"`
}

// DeviceAssurance The assurance level of the device.
// High-assurance devices are those that have a user binding, have been approved, and have performed cryptographic
// remote attestation.
type DeviceAssurance string

// DeviceDiscoverySource The source from which this device was discovered.
type DeviceDiscoverySource string

// DeviceDisplayId An opaque identifier that may be used to link this device to an external inventory.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceDisplayId = string

// DeviceDisplayName A friendly name for the device.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceDisplayName = string

// DeviceMetadata A map of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
type DeviceMetadata map[string]string

// DeviceOS The device operating system.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceOS string

// DeviceOwnership Whether the device is owned by the user or the company.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceOwnership string

// DevicePatch Data that can be modified on an existing device.
//
// Some device fields may be populated with a value derived from data synced from your team's MDMs.
// Any data that is explicitly set by API or with the Smallstep dashboard will mask MDM-derived values.
// Use this list to specify fields that should be unset. If the device includes data synced from an MDM
// this will result in the fields being populated with values derived from the MDM data. Otherwise the
// removed fields will be empty.
type DevicePatch struct {
	DisplayId   *DevicePatch_DisplayId   `json:"displayId,omitempty"`
	DisplayName *DevicePatch_DisplayName `json:"displayName,omitempty"`
	Metadata    *DevicePatch_Metadata    `json:"metadata,omitempty"`
	Os          *DevicePatch_Os          `json:"os,omitempty"`
	Ownership   *DevicePatch_Ownership   `json:"ownership,omitempty"`
	Serial      *DevicePatch_Serial      `json:"serial,omitempty"`
	Tags        *DevicePatch_Tags        `json:"tags,omitempty"`

	// User The user that a device is assigned to. A device cannot be approved for high-assurance certificates until it has an assigned user.
	User *DeviceUserPatch `json:"user,omitempty"`
}

// DevicePatchDisplayId1 defines model for .
type DevicePatchDisplayId1 = interface{}

// DevicePatch_DisplayId defines model for DevicePatch.DisplayId.
type DevicePatch_DisplayId struct {
	union json.RawMessage
}

// DevicePatchDisplayName1 defines model for .
type DevicePatchDisplayName1 = interface{}

// DevicePatch_DisplayName defines model for DevicePatch.DisplayName.
type DevicePatch_DisplayName struct {
	union json.RawMessage
}

// DevicePatchMetadata1 defines model for .
type DevicePatchMetadata1 = interface{}

// DevicePatch_Metadata defines model for DevicePatch.Metadata.
type DevicePatch_Metadata struct {
	union json.RawMessage
}

// DevicePatchOs1 defines model for .
type DevicePatchOs1 = interface{}

// DevicePatch_Os defines model for DevicePatch.Os.
type DevicePatch_Os struct {
	union json.RawMessage
}

// DevicePatchOwnership1 defines model for .
type DevicePatchOwnership1 = interface{}

// DevicePatch_Ownership defines model for DevicePatch.Ownership.
type DevicePatch_Ownership struct {
	union json.RawMessage
}

// DevicePatchSerial1 defines model for .
type DevicePatchSerial1 = interface{}

// DevicePatch_Serial defines model for DevicePatch.Serial.
type DevicePatch_Serial struct {
	union json.RawMessage
}

// DevicePatchTags1 defines model for .
type DevicePatchTags1 = interface{}

// DevicePatch_Tags defines model for DevicePatch.Tags.
type DevicePatch_Tags struct {
	union json.RawMessage
}

// DeviceRequest Data that can be added to a device record.
type DeviceRequest struct {
	// DisplayId An opaque identifier that may be used to link this device to an external inventory.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayId *DeviceDisplayId `json:"displayId,omitempty"`

	// DisplayName A friendly name for the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	DisplayName *DeviceDisplayName `json:"displayName,omitempty"`

	// Metadata A map of key-value pairs available as template data when a provisioner with a webhook is used to issue a certificate to a device.
	Metadata *DeviceMetadata `json:"metadata,omitempty"`

	// Os The device operating system.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Os *DeviceOS `json:"os,omitempty"`

	// Ownership Whether the device is owned by the user or the company.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Ownership *DeviceOwnership `json:"ownership,omitempty"`

	// PermanentIdentifier The cryptographic identity of the device. High-assurance devices are only issued certificates when this identifier is attested by a trusted source. All devices with the same permanent identifier appear as a single device in the Smallstep API. For Windows and Linux devices this is the hash of the TPM endorsement key and for Apple devices it is the serial number.
	PermanentIdentifier string `json:"permanentIdentifier"`

	// Serial The serial number of the device.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Serial *DeviceSerial `json:"serial,omitempty"`

	// Tags A set of tags that can be used to group devices.
	Tags *DeviceTags `json:"tags,omitempty"`

	// User The user that a device is assigned to. A device cannot be approved for high-assurance certificates until a user has been assigned to it.
	User *DeviceUser `json:"user,omitempty"`
}

// DeviceSerial The serial number of the device.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceSerial = string

// DeviceStatus The status of the device.
type DeviceStatus string

// DeviceTags A set of tags that can be used to group devices.
type DeviceTags = []string

// DeviceUser The user that a device is assigned to. A device cannot be approved for high-assurance certificates until a user has been assigned to it.
type DeviceUser struct {
	// DisplayName Full name of the user the device is assigned to. Synced from team's identity provider. Read only.
	DisplayName *string `json:"displayName,omitempty"`

	// Email Email of the user the device is assigned to.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Email string `json:"email"`
}

// DeviceUserPatch The user that a device is assigned to. A device cannot be approved for high-assurance certificates until it has an assigned user.
type DeviceUserPatch struct {
	// Email Email of the user the device is assigned to.
	// This field may be populated with a value derived from data synced from your team's MDMs.
	// Setting this value explicitly will mask any MDM-derived value.
	Email DeviceUserPatch_Email `json:"email"`
}

// DeviceUserPatchEmail0 defines model for .
type DeviceUserPatchEmail0 = interface{}

// DeviceUserPatchEmail1 defines model for .
type DeviceUserPatchEmail1 = string

// DeviceUserPatch_Email Email of the user the device is assigned to.
// This field may be populated with a value derived from data synced from your team's MDMs.
// Setting this value explicitly will mask any MDM-derived value.
type DeviceUserPatch_Email struct {
	union json.RawMessage
}

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizationalUnit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// EndpointCertificateInfo Details on a managed certificate.
type EndpointCertificateInfo struct {
	// AuthorityID A UUID identifying the authority to issue certificates for the account. If not provided, a new authority will be created.
	AuthorityID *string `json:"authorityID,omitempty"`

	// CrtFile The filepath where the certificate is to be stored.
	CrtFile *string                          `json:"crtFile,omitempty"`
	Details *EndpointCertificateInfo_Details `json:"details,omitempty"`

	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// Gid GID of the files where the certificate is stored.
	Gid *int `json:"gid,omitempty"`

	// KeyFile The filepath where the key is to be stored.
	KeyFile *string `json:"keyFile,omitempty"`

	// Mode Permission bits of the files where the certificate is stored.
	Mode *int `json:"mode,omitempty"`

	// RootFile The filepath where the root certificate is to be stored.
	RootFile *string `json:"rootFile,omitempty"`

	// Type The type of certificate.
	Type EndpointCertificateInfoType `json:"type"`

	// Uid UID of the files where the certificate is stored.
	Uid *int `json:"uid,omitempty"`
}

// EndpointCertificateInfo_Details defines model for EndpointCertificateInfo.Details.
type EndpointCertificateInfo_Details struct {
	union json.RawMessage
}

// EndpointCertificateInfoType The type of certificate.
type EndpointCertificateInfoType string

// EndpointConfiguration defines model for endpointConfiguration.
type EndpointConfiguration struct {
	// CertificateInfo Details on a managed certificate.
	CertificateInfo *EndpointCertificateInfo `json:"certificateInfo,omitempty"`

	// ExtendedType The extended type of this endpoint, which allows for further configuration to be specified using the `extendedTypeConfiguration` field.
	ExtendedType              *EndpointConfigurationExtendedType               `json:"extendedType,omitempty"`
	ExtendedTypeConfiguration *EndpointConfiguration_ExtendedTypeConfiguration `json:"extendedTypeConfiguration,omitempty"`

	// Id A UUID identifying this endpoint configuration. Read only.
	Id string `json:"id"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// Kind The kind of endpoint.
	//
	// Account-kind endpoints should be used for human users accessing protected resources. For account-kind endpoints, the `extendedType` and `extendedTypeConfiguration` fields are required.
	//
	// Device-kind endpoints should be used for devices or machines accessing protected resources.
	//
	// Workload-kind endpoints should be used issuing credentials to programs running on the device or machine.
	Kind EndpointConfigurationKind `json:"kind"`

	// Name A human-friendly name for this endpoint on devices.
	Name string `json:"name"`

	// Policy Policy to select the devices an account is assigned to. An empty policy indicates an account will be provisioned for all devices.
	Policy *PolicyMatchCriteria `json:"policy,omitempty"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`
}

// EndpointConfigurationExtendedType The extended type of this endpoint, which allows for further configuration to be specified using the `extendedTypeConfiguration` field.
type EndpointConfigurationExtendedType string

// EndpointConfiguration_ExtendedTypeConfiguration defines model for EndpointConfiguration.ExtendedTypeConfiguration.
type EndpointConfiguration_ExtendedTypeConfiguration struct {
	union json.RawMessage
}

// EndpointConfigurationKind The kind of endpoint.
//
// Account-kind endpoints should be used for human users accessing protected resources. For account-kind endpoints, the `extendedType` and `extendedTypeConfiguration` fields are required.
//
// Device-kind endpoints should be used for devices or machines accessing protected resources.
//
// Workload-kind endpoints should be used issuing credentials to programs running on the device or machine.
type EndpointConfigurationKind string

// EndpointConfigurationRequest The configuration settings of an endpoint.
type EndpointConfigurationRequest struct {
	// CertificateInfo Details on a managed certificate.
	CertificateInfo *EndpointCertificateInfo `json:"certificateInfo,omitempty"`

	// ExtendedType The extended type of this endpoint, which allows for further configuration to be specified using the `extendedTypeConfiguration` field.
	ExtendedType              *EndpointConfigurationRequestExtendedType               `json:"extendedType,omitempty"`
	ExtendedTypeConfiguration *EndpointConfigurationRequest_ExtendedTypeConfiguration `json:"extendedTypeConfiguration,omitempty"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// Kind The kind of endpoint.
	//
	// Account-kind endpoints should be used for human users accessing protected resources. For account-kind endpoints, the `extendedType` and `extendedTypeConfiguration` fields are required.
	//
	// Device-kind endpoints should be used for devices or machines accessing protected resources.
	//
	// Workload-kind endpoints should be used issuing credentials to programs running on the device or machine.
	Kind EndpointConfigurationRequestKind `json:"kind"`

	// Name A human-friendly name for this endpoint on devices.
	Name string `json:"name"`

	// Policy Policy to select the devices an account is assigned to. An empty policy indicates an account will be provisioned for all devices.
	Policy *PolicyMatchCriteria `json:"policy,omitempty"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`
}

// EndpointConfigurationRequestExtendedType The extended type of this endpoint, which allows for further configuration to be specified using the `extendedTypeConfiguration` field.
type EndpointConfigurationRequestExtendedType string

// EndpointConfigurationRequest_ExtendedTypeConfiguration defines model for EndpointConfigurationRequest.ExtendedTypeConfiguration.
type EndpointConfigurationRequest_ExtendedTypeConfiguration struct {
	union json.RawMessage
}

// EndpointConfigurationRequestKind The kind of endpoint.
//
// Account-kind endpoints should be used for human users accessing protected resources. For account-kind endpoints, the `extendedType` and `extendedTypeConfiguration` fields are required.
//
// Device-kind endpoints should be used for devices or machines accessing protected resources.
//
// Workload-kind endpoints should be used issuing credentials to programs running on the device or machine.
type EndpointConfigurationRequestKind string

// EndpointKeyInfo The attributes of the cryptographic key.
type EndpointKeyInfo struct {
	// Format The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used.
	Format *EndpointKeyInfoFormat `json:"format,omitempty"`

	// Protection Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`.
	Protection *EndpointKeyInfoProtection `json:"protection,omitempty"`

	// PubFile A CSR or SSH public key to use instead of generating one.
	PubFile *string `json:"pubFile,omitempty"`

	// Type The key type used. The current DEFAULT type is ECDSA_P256.
	Type *EndpointKeyInfoType `json:"type,omitempty"`
}

// EndpointKeyInfoFormat The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used.
type EndpointKeyInfoFormat string

// EndpointKeyInfoProtection Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`.
type EndpointKeyInfoProtection string

// EndpointKeyInfoType The key type used. The current DEFAULT type is ECDSA_P256.
type EndpointKeyInfoType string

// EndpointReloadInfo The properties used to reload a service.
type EndpointReloadInfo struct {
	// Method Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system.
	Method EndpointReloadInfoMethod `json:"method"`

	// PidFile File that holds the pid of the process to signal. Required when method is SIGNAL.
	PidFile *string `json:"pidFile,omitempty"`

	// Signal The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
	Signal *int `json:"signal,omitempty"`

	// UnitName The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
	UnitName *string `json:"unitName,omitempty"`
}

// EndpointReloadInfoMethod Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`. `PLATFORM` uses a method specific to the operating system.
type EndpointReloadInfoMethod string

// Error defines model for error.
type Error struct {
	// Message A description of the error.
	Message string `json:"message"`
}

// Ethernet Configuration for connecting a device to an EAP-TLS 802.1X wired network.
type Ethernet struct {
	// Autojoin Whether or not clients should automatically connect to the network.
	Autojoin *bool `json:"autojoin,omitempty"`

	// Credentials The UUID of credentials that the Smallstep agent will configure to use this ethernet integration.
	Credentials []string `json:"credentials"`

	// Id The UUID of this protected Ethernet configuration.
	Id *string `json:"id,omitempty"`

	// Name A human-friendly display name for this resource.
	Name *string `json:"name,omitempty"`

	// RadiusServerCA The certificate bundle used to verify the RADIUS server.
	RadiusServerCA string `json:"radiusServerCA"`
}

// EthernetAccount Configuration to connect a device to a protected LAN.
type EthernetAccount struct {
	// Autojoin Whether or not clients should automatically connect to the network.
	Autojoin *bool `json:"autojoin,omitempty"`

	// CaChain The certificate authority bundle that client certificates must chain up to.
	CaChain *string `json:"caChain,omitempty"`

	// ExternalRadiusServer Whether or not this network is configured to use Smallstep or external RADIUS.
	ExternalRadiusServer *bool `json:"externalRadiusServer,omitempty"`

	// NetworkAccessServerIP The public IP address of your network equipment that clients connect to.
	NetworkAccessServerIP *string `json:"networkAccessServerIP,omitempty"`
}

// ExtraName defines model for extraName.
type ExtraName struct {
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

// GcpDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
type GcpDisableCustomSANs = bool

// GcpPlatform Google Cloud Platform
type GcpPlatform struct {
	// Name A friendly name for this GCP connection
	Name string `json:"name"`

	// ProjectIds The project IDs where the resources are located.
	ProjectIds []string `json:"projectIds"`

	// ServiceAccountKey A JSON-formatted service account key that allows the Smallstep Platform to manage resources on your behalf.
	ServiceAccountKey *string `json:"serviceAccountKey,omitempty"`

	// ServiceAccounts GCE service accounts that are allowed to enroll with the Smallstep Platform.
	ServiceAccounts *[]string `json:"serviceAccounts,omitempty"`
}

// GcpProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
type GcpProjectIDs = []string

// GcpProvisioner The [GCP provisioner](https://smallstep.com/docs/step-ca/provisioners/#gcp) grants a certificate to a Google Compute Engine instance using its identity token. At least one service account or project ID must be set.
type GcpProvisioner struct {
	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
	DisableCustomSANs *GcpDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`

	// ProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
	ProjectIDs *GcpProjectIDs `json:"projectIDs,omitempty"`

	// ServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
	ServiceAccounts *GcpServiceAccounts `json:"serviceAccounts,omitempty"`
}

// GcpServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
type GcpServiceAccounts = []string

// IdentityProvider defines model for identityProvider.
type IdentityProvider struct {
	// AuthorizeEndpoint The URL where clients authenticate.
	AuthorizeEndpoint *string `json:"authorizeEndpoint,omitempty"`

	// Issuer The id of this identity provider.
	Issuer *string `json:"issuer,omitempty"`

	// JwksEndpoint The URL where relying parties can read the provider's public key.
	JwksEndpoint *string `json:"jwksEndpoint,omitempty"`

	// TokenEndpoint The URL where relying parties exchange authorization codes for identity tokens.
	TokenEndpoint *string `json:"tokenEndpoint,omitempty"`

	// TrustRoots The CA used to verify clients at the authorize endpoint.
	TrustRoots string `json:"trustRoots"`
}

// IdpClient defines model for idpClient.
type IdpClient struct {
	Id          *string `json:"id,omitempty"`
	RedirectURI string  `json:"redirectURI"`
	Secret      *string `json:"secret,omitempty"`
}

// IkeV2Config defines model for ikeV2Config.
type IkeV2Config struct {
	// CaChain The certificate authority bundle that client certificates must chain up to.
	CaChain string `json:"caChain"`

	// Eap Whether or not EAP is enforced on this VPN server.
	Eap *bool `json:"eap,omitempty"`

	// RemoteID Typically, the common name of the remote server. Defaults to the remote address.
	RemoteID *string `json:"remoteID,omitempty"`
}

// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
type InstanceAge = string

// JwkProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#jwk) that uses public-key cryptography to sign and validate a JSON Web Token (JWT).
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key.
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key.
	Key interface{} `json:"key"`
}

// ManagedRadius defines model for managedRadius.
type ManagedRadius struct {
	// ClientCA The CA that the RADIUS server will trust to verify clients.
	ClientCA        string            `json:"clientCA"`
	Id              *string           `json:"id,omitempty"`
	Name            string            `json:"name"`
	NasIPs          []string          `json:"nasIPs"`
	ReplyAttributes *[]ReplyAttribute `json:"replyAttributes,omitempty"`

	// Secret The credential the Network Access Server (NAS) uses to connect to the RADIUS server.
	// Only included when the `secret` parameter is set in the query string.
	Secret *string `json:"secret,omitempty"`

	// ServerCA The CA that supplicants should use to verify the RADIUS server.
	ServerCA *string `json:"serverCA,omitempty"`

	// ServerHostname The hostname of the RADIUS server.
	ServerHostname *string `json:"serverHostname,omitempty"`

	// ServerIP The IP address of the RADIUS server.
	ServerIP *string `json:"serverIP,omitempty"`

	// ServerPort The port of the RADIUS server.
	ServerPort *string `json:"serverPort,omitempty"`
}

// NameConstraints X509 certificate name constratins.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical.
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority.
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority.
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority.
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority.
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority.
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority.
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root.
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`
}

// NewPlatform Configuration to create a new platform.
type NewPlatform struct {
	DisplayName           string                            `json:"displayName"`
	PlatformConfiguration NewPlatform_PlatformConfiguration `json:"platformConfiguration"`

	// PlatformType Determines which set of fields to use in platformConfiguration. Cannot be changed.
	PlatformType NewPlatformPlatformType `json:"platformType"`
	Slug         string                  `json:"slug"`
}

// NewPlatform_PlatformConfiguration defines model for NewPlatform.PlatformConfiguration.
type NewPlatform_PlatformConfiguration struct {
	union json.RawMessage
}

// NewPlatformPlatformType Determines which set of fields to use in platformConfiguration. Cannot be changed.
type NewPlatformPlatformType string

// OidcProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#oauthoidc-single-sign-on) that is configured to trust and accept an OAuth provider's ID tokens for authentication. By default, the issued certificate will use the subject (sub) claim from the identity token as its subject. The value of the token's email claim is also included as an email SAN in the certificate.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// Platform A platform with a list of configurations.
type Platform struct {
	DisplayName            string                                 `json:"displayName"`
	PlatformConfigurations []Platform_PlatformConfigurations_Item `json:"platformConfigurations"`

	// PlatformType The type used in platformConfiguration.
	PlatformType PlatformPlatformType `json:"platformType"`
	Slug         string               `json:"slug"`
}

// Platform_PlatformConfigurations_Item defines model for platform.platformConfigurations.Item.
type Platform_PlatformConfigurations_Item struct {
	union json.RawMessage
}

// PlatformPlatformType The type used in platformConfiguration.
type PlatformPlatformType string

// PolicyMatchCriteria Policy to select the devices an account is assigned to. An empty policy indicates an account will be provisioned for all devices.
type PolicyMatchCriteria struct {
	// Assurance Assurance levels that devices must match.
	Assurance *[]DeviceAssurance `json:"assurance,omitempty"`

	// OperatingSystem Operating systems that devices must match.
	OperatingSystem *[]DeviceOS `json:"operatingSystem,omitempty"`

	// Ownership Ownership values that devices must match.
	Ownership *[]DeviceOwnership `json:"ownership,omitempty"`

	// Source Registration sources that devices must match.
	Source *[]DeviceDiscoverySource `json:"source,omitempty"`

	// Tags Tags that devices must match.
	Tags *[]string `json:"tags,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner.
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner.
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh      *SshOptions           `json:"ssh,omitempty"`
	Webhooks *[]ProvisionerWebhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates.
	X509 *X509Options `json:"x509,omitempty"`
}

// ProvisionerWebhook A [webhook](https://smallstep.com/docs/step-ca/webhooks/) to call when a certificate request is being processed.
type ProvisionerWebhook struct {
	// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BasicAuth *BasicAuth `json:"basicAuth,omitempty"`

	// BearerToken Webhook requests will include an Authorization header with the token. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BearerToken *string                    `json:"bearerToken,omitempty"`
	CertType    ProvisionerWebhookCertType `json:"certType"`

	// CollectionSlug For HOSTED_ATTESTATION webhooks, the collectionSlug is a reference to the collection that holds the devices that may be issued certificates. This collection must already exist. Required for `HOSTED_ATTESTATION` webhook servers; not allowed for `EXTERNAL`.
	CollectionSlug *string `json:"collectionSlug,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created. Will be sent to the webhook server in every request in the `X-Smallstep-Webhook-ID` header.
	Id *string `json:"id,omitempty"`

	// Kind The webhook kind indicates how and when it is called.
	//
	// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
	Kind ProvisionerWebhookKind `json:"kind"`

	// Name The name of the webhook. For `ENRICHING` webhooks, the returned data can be referenced in the certificate under the path `.Webhooks.<name>`. Must be unique to the provisioner.
	Name string `json:"name"`

	// Secret The shared secret used to authenticate the payload sent to the webhook server. Generated server-side. This is returned only for `EXTERNAL` webhook servers and only once, at the time of creation.
	Secret *string `json:"secret,omitempty"`

	// ServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
	//
	// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
	ServerType ProvisionerWebhookServerType `json:"serverType"`

	// Url The URL of the webhook server. Required for `EXTERNAL` webhook servers; read-only for hosted webhook servers.
	Url *string `json:"url,omitempty"`
}

// ProvisionerWebhookCertType defines model for ProvisionerWebhook.CertType.
type ProvisionerWebhookCertType string

// ProvisionerWebhookKind The webhook kind indicates how and when it is called.
//
// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
type ProvisionerWebhookKind string

// ProvisionerWebhookServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
//
// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
type ProvisionerWebhookServerType string

// ReplyAttribute defines model for replyAttribute.
type ReplyAttribute struct {
	// Name The attribute name.
	Name string `json:"name"`

	// Value The static attribute value.
	Value *string `json:"value,omitempty"`

	// ValueFromExtension The object identifier of an extension in the supplicant certificate. The RADIUS server will set the value of the reply attribute to the value of the extension.
	ValueFromExtension *string `json:"valueFromExtension,omitempty"`
	union              json.RawMessage
}

// ReplyAttribute0 defines model for .
type ReplyAttribute0 = interface{}

// ReplyAttribute1 defines model for .
type ReplyAttribute1 = interface{}

// ScepProvisioner The [SCEP provisioner](https://smallstep.com/docs/step-ca/provisioners/#scep) grants certificates to clients using the SCEP protocol. This type is currently experimental and subject to change.
type ScepProvisioner struct {
	// AutogenerateDecrypter Automatically generate a new RSA decrypter instead of providing one.
	AutogenerateDecrypter *bool `json:"autogenerateDecrypter,omitempty"`

	// Challenge A static challenge secret.
	Challenge *string `json:"challenge,omitempty"`

	// DecrypterCertificate A pem-encoded certificate for an RSA public key.
	DecrypterCertificate *string `json:"decrypterCertificate,omitempty"`

	// DecrypterKey The pem-encoded RSA private key, corresponding to the certificate public key.
	DecrypterKey *string `json:"decrypterKey,omitempty"`

	// DecrypterKeyPassword The password for the pem-encoded RSA private key, if any.
	DecrypterKeyPassword *string `json:"decrypterKeyPassword,omitempty"`

	// EncryptionAlgorithmIdentifier The encryption algorithm used for encrypting responses to the SCEP client:
	//  * `DES_CBC`    - [DES in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.1) - `1.3.14.3.2.7`
	//  * `AES_128_CBC` - [AES-128 in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.5) - `2.16.840.1.101.3.4.1.2`
	//  * `AES_128_GCM` - [AES-128 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.6`
	//  * `AES_256_CBC` - [AES-256 in CBC mode](https://www.rfc-editor.org/rfc/rfc3565.html#section-4.1) - `2.16.840.1.101.3.4.1.42`
	//  * `AES_256_GCM` - [AES-256 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.46`
	EncryptionAlgorithmIdentifier *ScepProvisionerEncryptionAlgorithmIdentifier `json:"encryptionAlgorithmIdentifier,omitempty"`

	// ExcludeIntermediate Exclude the intermediate CA certificate in SCEP responses.
	ExcludeIntermediate *bool `json:"excludeIntermediate,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// IncludeRoot Include the root CA certificate in SCEP responses.
	IncludeRoot *bool `json:"includeRoot,omitempty"`

	// MinimumPublicKeyLength The minimum number of bits for RSA public keys accepted in SCEP requests.
	MinimumPublicKeyLength *int `json:"minimumPublicKeyLength,omitempty"`
}

// ScepProvisionerEncryptionAlgorithmIdentifier The encryption algorithm used for encrypting responses to the SCEP client:
//   - `DES_CBC`    - [DES in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.1) - `1.3.14.3.2.7`
//   - `AES_128_CBC` - [AES-128 in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.5) - `2.16.840.1.101.3.4.1.2`
//   - `AES_128_GCM` - [AES-128 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.6`
//   - `AES_256_CBC` - [AES-256 in CBC mode](https://www.rfc-editor.org/rfc/rfc3565.html#section-4.1) - `2.16.840.1.101.3.4.1.42`
//   - `AES_256_GCM` - [AES-256 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.46`
type ScepProvisionerEncryptionAlgorithmIdentifier string

// SshFields Populate certificate fields using static names or device metadata.
type SshFields struct {
	// KeyId A certificate field that takes a single string value, e.g. Common Name. Static values are used as a fallback when device metadata is not present.
	KeyId *CertificateField `json:"keyId,omitempty"`

	// Principals A certificate field that accepts multiple string values, e.g. SANs.
	Principals *CertificateFieldList `json:"principals,omitempty"`
}

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Subject Name used in x509 certificates
type Subject struct {
	CommonName         *string      `json:"commonName,omitempty"`
	Country            *[]string    `json:"country,omitempty"`
	EmailAddress       *[]string    `json:"emailAddress,omitempty"`
	ExtraNames         *[]ExtraName `json:"extraNames,omitempty"`
	Locality           *[]string    `json:"locality,omitempty"`
	Organization       *[]string    `json:"organization,omitempty"`
	OrganizationalUnit *[]string    `json:"organizationalUnit,omitempty"`
	PostalCode         *[]string    `json:"postalCode,omitempty"`
	Province           *[]string    `json:"province,omitempty"`
	SerialNumber       *string      `json:"serialNumber,omitempty"`
	StreetAddress      *[]string    `json:"streetAddress,omitempty"`
}

// Vpn defines model for vpn.
type Vpn struct {
	// Autojoin Whether or not clients should automatically connect to the network.
	Autojoin *bool `json:"autojoin,omitempty"`

	// ConnectionType The type of VPN connection.
	ConnectionType VpnType `json:"connectionType"`

	// Credentials The UUID of credentials that the Smallstep agent will configure to use this VPN integration.
	Credentials []string     `json:"credentials"`
	Id          *string      `json:"id,omitempty"`
	Ike         *IkeV2Config `json:"ike,omitempty"`
	Name        *string      `json:"name,omitempty"`

	// RemoteAddress The public IP address of the VPN server.
	RemoteAddress string `json:"remoteAddress"`

	// Vendor For SSL-type VPN connections, the vendor of the VPN.
	Vendor *VpnVendor `json:"vendor,omitempty"`
}

// VpnAccount Configuration to connect a device to a VPN.
type VpnAccount struct {
	// Autojoin Whether or not clients should automatically connect to the network.
	Autojoin *bool `json:"autojoin,omitempty"`

	// ConnectionType The type of VPN connection.
	ConnectionType VpnType      `json:"connectionType"`
	Ike            *IkeV2Config `json:"ike,omitempty"`

	// RemoteAddress The public IP address of the VPN server.
	RemoteAddress string `json:"remoteAddress"`

	// Vendor For SSL-type VPN connections, the vendor of the VPN.
	Vendor *VpnVendor `json:"vendor,omitempty"`
}

// VpnType The type of VPN connection.
type VpnType string

// VpnVendor For SSL-type VPN connections, the vendor of the VPN.
type VpnVendor string

// Wifi Configuration to use a credential to connect to a protected Wi-Fi network.
type Wifi struct {
	// Autojoin Whether or not clients should automatically connect to the network.
	Autojoin *bool `json:"autojoin,omitempty"`

	// Credentials The UUID of credentials that the Smallstep agent will configure to use this Wi-Fi integration.
	Credentials []string `json:"credentials"`

	// Hidden Whether or not the SSID is broadcast by the access points.
	Hidden *bool `json:"hidden,omitempty"`

	// Id The UUID of this protected Wi-Fi configuration.
	Id *string `json:"id,omitempty"`

	// Name A human-friendly display name for this resource.
	Name *string `json:"name,omitempty"`

	// RadiusServerCA The certificate bundle used to verify the RADIUS server.
	RadiusServerCA string `json:"radiusServerCA"`

	// Ssid The name of the wireless network that clients connect to.
	Ssid string `json:"ssid"`
}

// WifiAccount Configuration to connect a device to a protected WiFi network.
type WifiAccount struct {
	// Autojoin Whether or not clients should automatically connect to the network.
	Autojoin *bool `json:"autojoin,omitempty"`

	// CaChain The certificate authority bundle that client certificates must chain up to.
	CaChain *string `json:"caChain,omitempty"`

	// ExternalRadiusServer Whether or not this network is configured to use Smallstep or external RADIUS.
	ExternalRadiusServer *bool `json:"externalRadiusServer,omitempty"`

	// Hidden Whether or not the SSID is broadcast by the access points.
	Hidden *bool `json:"hidden,omitempty"`

	// NetworkAccessServerIP The public IP address of your network equipment that clients connect to.
	NetworkAccessServerIP *string `json:"networkAccessServerIP,omitempty"`

	// Ssid The name of the wireless network clients connect to.
	Ssid string `json:"ssid"`
}

// X509Certificate defines model for x509Certificate.
type X509Certificate struct {
	AuthorityKeyId        string           `json:"authorityKeyId"`
	BasicConstraints      BasicConstraints `json:"basicConstraints"`
	CrlDistributionPoints *[]string        `json:"crlDistributionPoints,omitempty"`
	DnsNames              *[]string        `json:"dnsNames,omitempty"`
	EmailAddresses        *[]string        `json:"emailAddresses,omitempty"`
	ExtKeyUsage           *[]string        `json:"extKeyUsage,omitempty"`
	IpAddresses           *[]string        `json:"ipAddresses,omitempty"`

	// Issuer Name used in x509 certificates
	Issuer                Subject   `json:"issuer"`
	IssuingCertificateURL *[]string `json:"issuingCertificateURL,omitempty"`
	KeyUsage              []string  `json:"keyUsage"`

	// NameConstraints X509 certificate name constratins.
	NameConstraints    *NameConstraints                 `json:"nameConstraints,omitempty"`
	OcspServer         *[]string                        `json:"ocspServer,omitempty"`
	Pem                string                           `json:"pem"`
	PolicyIdentifiers  *[]string                        `json:"policyIdentifiers,omitempty"`
	RevocationReason   *X509CertificateRevocationReason `json:"revocationReason,omitempty"`
	Revoked            *bool                            `json:"revoked,omitempty"`
	SerialNumber       string                           `json:"serialNumber"`
	SignatureAlgorithm string                           `json:"signatureAlgorithm"`

	// Subject Name used in x509 certificates
	Subject      Subject   `json:"subject"`
	SubjectKeyId string    `json:"subjectKeyId"`
	Uris         *[]string `json:"uris,omitempty"`
	Version      int       `json:"version"`
}

// X509CertificateRevocationReason defines model for X509Certificate.RevocationReason.
type X509CertificateRevocationReason string

// X509Fields Populate certificate fields using using static names or device metadata.
type X509Fields struct {
	// CommonName A certificate field that takes a single string value, e.g. Common Name. Static values are used as a fallback when device metadata is not present.
	CommonName *CertificateField `json:"commonName,omitempty"`

	// Country A certificate field that accepts multiple string values, e.g. SANs.
	Country *CertificateFieldList `json:"country,omitempty"`

	// Locality A certificate field that accepts multiple string values, e.g. SANs.
	Locality *CertificateFieldList `json:"locality,omitempty"`

	// Organization A certificate field that accepts multiple string values, e.g. SANs.
	Organization *CertificateFieldList `json:"organization,omitempty"`

	// OrganizationalUnit A certificate field that accepts multiple string values, e.g. SANs.
	OrganizationalUnit *CertificateFieldList `json:"organizationalUnit,omitempty"`

	// PostalCode A certificate field that accepts multiple string values, e.g. SANs.
	PostalCode *CertificateFieldList `json:"postalCode,omitempty"`

	// Province A certificate field that accepts multiple string values, e.g. SANs.
	Province *CertificateFieldList `json:"province,omitempty"`

	// Sans A certificate field that accepts multiple string values, e.g. SANs.
	Sans *CertificateFieldList `json:"sans,omitempty"`

	// StreetAddress A certificate field that accepts multiple string values, e.g. SANs.
	StreetAddress *CertificateFieldList `json:"streetAddress,omitempty"`
}

// X509Issuer A Customized X509 issuer for an authority.
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm.
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer.
	Name string `json:"name"`

	// NameConstraints X509 certificate name constratins.
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm.
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates.
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// X5cProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#x5c---x509-certificate) that authenticates a certificate request with an existing x509 certificate.
type X5cProvisioner struct {
	// Roots A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
	Roots []string `json:"roots"`
}

// Accept defines model for accept.
type Accept = string

// AccountID defines model for accountID.
type AccountID = string

// AuthorityDomainOrID defines model for authorityDomainOrID.
type AuthorityDomainOrID = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// BrowserID defines model for browserID.
type BrowserID = string

// CredentialID defines model for credentialID.
type CredentialID = string

// DeviceFilters defines model for deviceFilters.
type DeviceFilters struct {
	// Assurance Assurance levels that devices must match.
	Assurance *[]DeviceAssurance `json:"assurance,omitempty"`

	// OnlyManaged Only return devices that are Smallstep-managed.
	OnlyManaged *bool `json:"onlyManaged,omitempty"`

	// OnlyPendingApproval Only return devices that are pending approval.
	OnlyPendingApproval *bool `json:"onlyPendingApproval,omitempty"`

	// OnlyUnassigned Only return devices that do not have a user binding.
	OnlyUnassigned *bool `json:"onlyUnassigned,omitempty"`

	// OperatingSystem Operating systems that devices must match.
	OperatingSystem *[]DeviceOS `json:"operatingSystem,omitempty"`

	// Ownership Ownership values that devices must match.
	Ownership *[]DeviceOwnership `json:"ownership,omitempty"`

	// Source Registration sources that devices must match.
	Source *[]DeviceDiscoverySource `json:"source,omitempty"`

	// Status The status of the device.
	Status *DeviceStatus `json:"status,omitempty"`
}

// DeviceID defines model for deviceID.
type DeviceID = string

// DeviceSort defines model for deviceSort.
type DeviceSort struct {
	// Ascending Indicates that devices should be sorted in ascending order.
	Ascending *bool `json:"ascending,omitempty"`

	// Field The field used for sorting matching devices.
	Field *string `json:"field,omitempty"`
}

// EndpointConfigurationID defines model for endpointConfigurationID.
type EndpointConfigurationID = string

// EthernetID defines model for ethernetID.
type EthernetID = string

// IdpClientID defines model for idpClientID.
type IdpClientID = string

// ManagedRadiusID defines model for managedRadiusID.
type ManagedRadiusID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// PlatformSlug defines model for platformSlug.
type PlatformSlug = string

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// Secret defines model for secret.
type Secret = bool

// SerialNumber defines model for serialNumber.
type SerialNumber = string

// VpnID defines model for vpnID.
type VpnID = string

// WebhookNameOrID defines model for webhookNameOrID.
type WebhookNameOrID = string

// WifiID defines model for wifiID.
type WifiID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N422 defines model for 422.
type N422 = Error

// N500 defines model for 500.
type N500 = Error

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAccountsParams defines parameters for PostAccounts.
type PostAccountsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAccountParams defines parameters for DeleteAccount.
type DeleteAccountParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAccountParams defines parameters for GetAccount.
type GetAccountParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutAccountParams defines parameters for PutAccount.
type PutAccountParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
	TeamSlug *string                   `json:"teamSlug,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostWebhooksParams defines parameters for PostWebhooks.
type PostWebhooksParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWebhookParams defines parameters for DeleteWebhook.
type DeleteWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListCertificatesParams defines parameters for ListCertificates.
type ListCertificatesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCertificateParams defines parameters for GetCertificate.
type GetCertificateParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteCredentialParams defines parameters for DeleteCredential.
type DeleteCredentialParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCredentialParams defines parameters for GetCredential.
type GetCredentialParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCredentialParams defines parameters for PutCredential.
type PutCredentialParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostCredentialsParams defines parameters for PostCredentials.
type PostCredentialsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// Filters Filter a list of devices by specifying the critera that must be met. Example: `?filters[os]=windows&filters[assurance]=high`, which after encoding would be `?filters%5Bos%5D=windows&filters%5Bassurance%5D=high`
	Filters *DeviceFilters `form:"filters,omitempty" json:"filters,omitempty"`

	// Sort The sorting behavior for matching devices. Example: `?sort[field]=lastSeen&sort[ascending]=true`, which after encoding would be `?sort%5Bfield%5D=lastSeen&sort%5Bascending%5D=true`
	Sort *DeviceSort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListDevicesParamsSortField defines parameters for ListDevices.
type ListDevicesParamsSortField string

// PostDevicesParams defines parameters for PostDevices.
type PostDevicesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListEndpointConfigurationsParams defines parameters for ListEndpointConfigurations.
type ListEndpointConfigurationsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostEndpointConfigurationsParams defines parameters for PostEndpointConfigurations.
type PostEndpointConfigurationsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteEndpointConfigurationParams defines parameters for DeleteEndpointConfiguration.
type DeleteEndpointConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetEndpointConfigurationParams defines parameters for GetEndpointConfiguration.
type GetEndpointConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutEndpointConfigurationParams defines parameters for PutEndpointConfiguration.
type PutEndpointConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListManagedRadiusParams defines parameters for ListManagedRadius.
type ListManagedRadiusParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostManagedRadiusParams defines parameters for PostManagedRadius.
type PostManagedRadiusParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteManagedRadiusParams defines parameters for DeleteManagedRadius.
type DeleteManagedRadiusParams struct {
	// Secret Whether to return the managed RADIUS secret in the response.
	Secret *Secret `form:"secret,omitempty" json:"secret,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetManagedRadiusParams defines parameters for GetManagedRadius.
type GetManagedRadiusParams struct {
	// Secret Whether to return the managed RADIUS secret in the response.
	Secret *Secret `form:"secret,omitempty" json:"secret,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutManagedRadiusParams defines parameters for PutManagedRadius.
type PutManagedRadiusParams struct {
	// Secret Whether to return the managed RADIUS secret in the response.
	Secret *Secret `form:"secret,omitempty" json:"secret,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetPlatformsParams defines parameters for GetPlatforms.
type GetPlatformsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutPlatformParams defines parameters for PutPlatform.
type PutPlatformParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListBrowserParams defines parameters for ListBrowser.
type ListBrowserParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostBrowserParams defines parameters for PostBrowser.
type PostBrowserParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteBrowserParams defines parameters for DeleteBrowser.
type DeleteBrowserParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetBrowserParams defines parameters for GetBrowser.
type GetBrowserParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutBrowserParams defines parameters for PutBrowser.
type PutBrowserParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListEthernetParams defines parameters for ListEthernet.
type ListEthernetParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostEthernetParams defines parameters for PostEthernet.
type PostEthernetParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteEthernetParams defines parameters for DeleteEthernet.
type DeleteEthernetParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetEthernetParams defines parameters for GetEthernet.
type GetEthernetParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutEthernetParams defines parameters for PutEthernet.
type PutEthernetParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListVpnParams defines parameters for ListVpn.
type ListVpnParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostVpnParams defines parameters for PostVpn.
type PostVpnParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteVpnParams defines parameters for DeleteVpn.
type DeleteVpnParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetVpnParams defines parameters for GetVpn.
type GetVpnParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutVpnParams defines parameters for PutVpn.
type PutVpnParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListWifiParams defines parameters for ListWifi.
type ListWifiParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostWifiParams defines parameters for PostWifi.
type PostWifiParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWifiParams defines parameters for DeleteWifi.
type DeleteWifiParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWifiParams defines parameters for GetWifi.
type GetWifiParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutWifiParams defines parameters for PutWifi.
type PutWifiParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteIdentityProviderParams defines parameters for DeleteIdentityProvider.
type DeleteIdentityProviderParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetIdentityProviderParams defines parameters for GetIdentityProvider.
type GetIdentityProviderParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutIdentityProviderParams defines parameters for PutIdentityProvider.
type PutIdentityProviderParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListIdpClientsParams defines parameters for ListIdpClients.
type ListIdpClientsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostIdpClientsParams defines parameters for PostIdpClients.
type PostIdpClientsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteIdpClientParams defines parameters for DeleteIdpClient.
type DeleteIdpClientParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetIdpClientParams defines parameters for GetIdpClient.
type GetIdpClientParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAccountsJSONRequestBody defines body for PostAccounts for application/json ContentType.
type PostAccountsJSONRequestBody = AccountRequest

// PutAccountJSONRequestBody defines body for PutAccount for application/json ContentType.
type PutAccountJSONRequestBody = Account

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostWebhooksJSONRequestBody defines body for PostWebhooks for application/json ContentType.
type PostWebhooksJSONRequestBody = ProvisionerWebhook

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PutCredentialJSONRequestBody defines body for PutCredential for application/json ContentType.
type PutCredentialJSONRequestBody = Credential

// PostCredentialsJSONRequestBody defines body for PostCredentials for application/json ContentType.
type PostCredentialsJSONRequestBody = Credential

// PostDevicesJSONRequestBody defines body for PostDevices for application/json ContentType.
type PostDevicesJSONRequestBody = DeviceRequest

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody = DevicePatch

// PostEndpointConfigurationsJSONRequestBody defines body for PostEndpointConfigurations for application/json ContentType.
type PostEndpointConfigurationsJSONRequestBody = EndpointConfigurationRequest

// PutEndpointConfigurationJSONRequestBody defines body for PutEndpointConfiguration for application/json ContentType.
type PutEndpointConfigurationJSONRequestBody = EndpointConfiguration

// PostManagedRadiusJSONRequestBody defines body for PostManagedRadius for application/json ContentType.
type PostManagedRadiusJSONRequestBody = ManagedRadius

// PutManagedRadiusJSONRequestBody defines body for PutManagedRadius for application/json ContentType.
type PutManagedRadiusJSONRequestBody = ManagedRadius

// PutPlatformJSONRequestBody defines body for PutPlatform for application/json ContentType.
type PutPlatformJSONRequestBody = NewPlatform

// PostBrowserJSONRequestBody defines body for PostBrowser for application/json ContentType.
type PostBrowserJSONRequestBody = Browser

// PutBrowserJSONRequestBody defines body for PutBrowser for application/json ContentType.
type PutBrowserJSONRequestBody = Browser

// PostEthernetJSONRequestBody defines body for PostEthernet for application/json ContentType.
type PostEthernetJSONRequestBody = Ethernet

// PutEthernetJSONRequestBody defines body for PutEthernet for application/json ContentType.
type PutEthernetJSONRequestBody = Ethernet

// PostVpnJSONRequestBody defines body for PostVpn for application/json ContentType.
type PostVpnJSONRequestBody = Vpn

// PutVpnJSONRequestBody defines body for PutVpn for application/json ContentType.
type PutVpnJSONRequestBody = Vpn

// PostWifiJSONRequestBody defines body for PostWifi for application/json ContentType.
type PostWifiJSONRequestBody = Wifi

// PutWifiJSONRequestBody defines body for PutWifi for application/json ContentType.
type PutWifiJSONRequestBody = Wifi

// PutIdentityProviderJSONRequestBody defines body for PutIdentityProvider for application/json ContentType.
type PutIdentityProviderJSONRequestBody = IdentityProvider

// PostIdpClientsJSONRequestBody defines body for PostIdpClients for application/json ContentType.
type PostIdpClientsJSONRequestBody = IdpClient

// AsWifiAccount returns the union data inside the Account_Configuration as a WifiAccount
func (t Account_Configuration) AsWifiAccount() (WifiAccount, error) {
	var body WifiAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWifiAccount overwrites any union data inside the Account_Configuration as the provided WifiAccount
func (t *Account_Configuration) FromWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWifiAccount performs a merge with any union data inside the Account_Configuration, using the provided WifiAccount
func (t *Account_Configuration) MergeWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEthernetAccount returns the union data inside the Account_Configuration as a EthernetAccount
func (t Account_Configuration) AsEthernetAccount() (EthernetAccount, error) {
	var body EthernetAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthernetAccount overwrites any union data inside the Account_Configuration as the provided EthernetAccount
func (t *Account_Configuration) FromEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthernetAccount performs a merge with any union data inside the Account_Configuration, using the provided EthernetAccount
func (t *Account_Configuration) MergeEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVpnAccount returns the union data inside the Account_Configuration as a VpnAccount
func (t Account_Configuration) AsVpnAccount() (VpnAccount, error) {
	var body VpnAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnAccount overwrites any union data inside the Account_Configuration as the provided VpnAccount
func (t *Account_Configuration) FromVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnAccount performs a merge with any union data inside the Account_Configuration, using the provided VpnAccount
func (t *Account_Configuration) MergeVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBrowserAccount returns the union data inside the Account_Configuration as a BrowserAccount
func (t Account_Configuration) AsBrowserAccount() (BrowserAccount, error) {
	var body BrowserAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBrowserAccount overwrites any union data inside the Account_Configuration as the provided BrowserAccount
func (t *Account_Configuration) FromBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBrowserAccount performs a merge with any union data inside the Account_Configuration, using the provided BrowserAccount
func (t *Account_Configuration) MergeBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Account_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Account_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWifiAccount returns the union data inside the AccountRequest_Configuration as a WifiAccount
func (t AccountRequest_Configuration) AsWifiAccount() (WifiAccount, error) {
	var body WifiAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWifiAccount overwrites any union data inside the AccountRequest_Configuration as the provided WifiAccount
func (t *AccountRequest_Configuration) FromWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWifiAccount performs a merge with any union data inside the AccountRequest_Configuration, using the provided WifiAccount
func (t *AccountRequest_Configuration) MergeWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEthernetAccount returns the union data inside the AccountRequest_Configuration as a EthernetAccount
func (t AccountRequest_Configuration) AsEthernetAccount() (EthernetAccount, error) {
	var body EthernetAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthernetAccount overwrites any union data inside the AccountRequest_Configuration as the provided EthernetAccount
func (t *AccountRequest_Configuration) FromEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthernetAccount performs a merge with any union data inside the AccountRequest_Configuration, using the provided EthernetAccount
func (t *AccountRequest_Configuration) MergeEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVpnAccount returns the union data inside the AccountRequest_Configuration as a VpnAccount
func (t AccountRequest_Configuration) AsVpnAccount() (VpnAccount, error) {
	var body VpnAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnAccount overwrites any union data inside the AccountRequest_Configuration as the provided VpnAccount
func (t *AccountRequest_Configuration) FromVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnAccount performs a merge with any union data inside the AccountRequest_Configuration, using the provided VpnAccount
func (t *AccountRequest_Configuration) MergeVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBrowserAccount returns the union data inside the AccountRequest_Configuration as a BrowserAccount
func (t AccountRequest_Configuration) AsBrowserAccount() (BrowserAccount, error) {
	var body BrowserAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBrowserAccount overwrites any union data inside the AccountRequest_Configuration as the provided BrowserAccount
func (t *AccountRequest_Configuration) FromBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBrowserAccount performs a merge with any union data inside the AccountRequest_Configuration, using the provided BrowserAccount
func (t *AccountRequest_Configuration) MergeBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AccountRequest_Configuration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AccountRequest_Configuration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsX509Fields returns the union data inside the CredentialCertificate_Fields as a X509Fields
func (t CredentialCertificate_Fields) AsX509Fields() (X509Fields, error) {
	var body X509Fields
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX509Fields overwrites any union data inside the CredentialCertificate_Fields as the provided X509Fields
func (t *CredentialCertificate_Fields) FromX509Fields(v X509Fields) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX509Fields performs a merge with any union data inside the CredentialCertificate_Fields, using the provided X509Fields
func (t *CredentialCertificate_Fields) MergeX509Fields(v X509Fields) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CredentialCertificate_Fields) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CredentialCertificate_Fields) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceDisplayId returns the union data inside the DevicePatch_DisplayId as a DeviceDisplayId
func (t DevicePatch_DisplayId) AsDeviceDisplayId() (DeviceDisplayId, error) {
	var body DeviceDisplayId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceDisplayId overwrites any union data inside the DevicePatch_DisplayId as the provided DeviceDisplayId
func (t *DevicePatch_DisplayId) FromDeviceDisplayId(v DeviceDisplayId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceDisplayId performs a merge with any union data inside the DevicePatch_DisplayId, using the provided DeviceDisplayId
func (t *DevicePatch_DisplayId) MergeDeviceDisplayId(v DeviceDisplayId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchDisplayId1 returns the union data inside the DevicePatch_DisplayId as a DevicePatchDisplayId1
func (t DevicePatch_DisplayId) AsDevicePatchDisplayId1() (DevicePatchDisplayId1, error) {
	var body DevicePatchDisplayId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchDisplayId1 overwrites any union data inside the DevicePatch_DisplayId as the provided DevicePatchDisplayId1
func (t *DevicePatch_DisplayId) FromDevicePatchDisplayId1(v DevicePatchDisplayId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchDisplayId1 performs a merge with any union data inside the DevicePatch_DisplayId, using the provided DevicePatchDisplayId1
func (t *DevicePatch_DisplayId) MergeDevicePatchDisplayId1(v DevicePatchDisplayId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_DisplayId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_DisplayId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceDisplayName returns the union data inside the DevicePatch_DisplayName as a DeviceDisplayName
func (t DevicePatch_DisplayName) AsDeviceDisplayName() (DeviceDisplayName, error) {
	var body DeviceDisplayName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceDisplayName overwrites any union data inside the DevicePatch_DisplayName as the provided DeviceDisplayName
func (t *DevicePatch_DisplayName) FromDeviceDisplayName(v DeviceDisplayName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceDisplayName performs a merge with any union data inside the DevicePatch_DisplayName, using the provided DeviceDisplayName
func (t *DevicePatch_DisplayName) MergeDeviceDisplayName(v DeviceDisplayName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchDisplayName1 returns the union data inside the DevicePatch_DisplayName as a DevicePatchDisplayName1
func (t DevicePatch_DisplayName) AsDevicePatchDisplayName1() (DevicePatchDisplayName1, error) {
	var body DevicePatchDisplayName1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchDisplayName1 overwrites any union data inside the DevicePatch_DisplayName as the provided DevicePatchDisplayName1
func (t *DevicePatch_DisplayName) FromDevicePatchDisplayName1(v DevicePatchDisplayName1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchDisplayName1 performs a merge with any union data inside the DevicePatch_DisplayName, using the provided DevicePatchDisplayName1
func (t *DevicePatch_DisplayName) MergeDevicePatchDisplayName1(v DevicePatchDisplayName1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_DisplayName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_DisplayName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceMetadata returns the union data inside the DevicePatch_Metadata as a DeviceMetadata
func (t DevicePatch_Metadata) AsDeviceMetadata() (DeviceMetadata, error) {
	var body DeviceMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceMetadata overwrites any union data inside the DevicePatch_Metadata as the provided DeviceMetadata
func (t *DevicePatch_Metadata) FromDeviceMetadata(v DeviceMetadata) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceMetadata performs a merge with any union data inside the DevicePatch_Metadata, using the provided DeviceMetadata
func (t *DevicePatch_Metadata) MergeDeviceMetadata(v DeviceMetadata) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchMetadata1 returns the union data inside the DevicePatch_Metadata as a DevicePatchMetadata1
func (t DevicePatch_Metadata) AsDevicePatchMetadata1() (DevicePatchMetadata1, error) {
	var body DevicePatchMetadata1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchMetadata1 overwrites any union data inside the DevicePatch_Metadata as the provided DevicePatchMetadata1
func (t *DevicePatch_Metadata) FromDevicePatchMetadata1(v DevicePatchMetadata1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchMetadata1 performs a merge with any union data inside the DevicePatch_Metadata, using the provided DevicePatchMetadata1
func (t *DevicePatch_Metadata) MergeDevicePatchMetadata1(v DevicePatchMetadata1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_Metadata) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_Metadata) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceOS returns the union data inside the DevicePatch_Os as a DeviceOS
func (t DevicePatch_Os) AsDeviceOS() (DeviceOS, error) {
	var body DeviceOS
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceOS overwrites any union data inside the DevicePatch_Os as the provided DeviceOS
func (t *DevicePatch_Os) FromDeviceOS(v DeviceOS) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceOS performs a merge with any union data inside the DevicePatch_Os, using the provided DeviceOS
func (t *DevicePatch_Os) MergeDeviceOS(v DeviceOS) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchOs1 returns the union data inside the DevicePatch_Os as a DevicePatchOs1
func (t DevicePatch_Os) AsDevicePatchOs1() (DevicePatchOs1, error) {
	var body DevicePatchOs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchOs1 overwrites any union data inside the DevicePatch_Os as the provided DevicePatchOs1
func (t *DevicePatch_Os) FromDevicePatchOs1(v DevicePatchOs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchOs1 performs a merge with any union data inside the DevicePatch_Os, using the provided DevicePatchOs1
func (t *DevicePatch_Os) MergeDevicePatchOs1(v DevicePatchOs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_Os) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_Os) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceOwnership returns the union data inside the DevicePatch_Ownership as a DeviceOwnership
func (t DevicePatch_Ownership) AsDeviceOwnership() (DeviceOwnership, error) {
	var body DeviceOwnership
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceOwnership overwrites any union data inside the DevicePatch_Ownership as the provided DeviceOwnership
func (t *DevicePatch_Ownership) FromDeviceOwnership(v DeviceOwnership) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceOwnership performs a merge with any union data inside the DevicePatch_Ownership, using the provided DeviceOwnership
func (t *DevicePatch_Ownership) MergeDeviceOwnership(v DeviceOwnership) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchOwnership1 returns the union data inside the DevicePatch_Ownership as a DevicePatchOwnership1
func (t DevicePatch_Ownership) AsDevicePatchOwnership1() (DevicePatchOwnership1, error) {
	var body DevicePatchOwnership1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchOwnership1 overwrites any union data inside the DevicePatch_Ownership as the provided DevicePatchOwnership1
func (t *DevicePatch_Ownership) FromDevicePatchOwnership1(v DevicePatchOwnership1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchOwnership1 performs a merge with any union data inside the DevicePatch_Ownership, using the provided DevicePatchOwnership1
func (t *DevicePatch_Ownership) MergeDevicePatchOwnership1(v DevicePatchOwnership1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_Ownership) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_Ownership) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceSerial returns the union data inside the DevicePatch_Serial as a DeviceSerial
func (t DevicePatch_Serial) AsDeviceSerial() (DeviceSerial, error) {
	var body DeviceSerial
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceSerial overwrites any union data inside the DevicePatch_Serial as the provided DeviceSerial
func (t *DevicePatch_Serial) FromDeviceSerial(v DeviceSerial) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceSerial performs a merge with any union data inside the DevicePatch_Serial, using the provided DeviceSerial
func (t *DevicePatch_Serial) MergeDeviceSerial(v DeviceSerial) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchSerial1 returns the union data inside the DevicePatch_Serial as a DevicePatchSerial1
func (t DevicePatch_Serial) AsDevicePatchSerial1() (DevicePatchSerial1, error) {
	var body DevicePatchSerial1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchSerial1 overwrites any union data inside the DevicePatch_Serial as the provided DevicePatchSerial1
func (t *DevicePatch_Serial) FromDevicePatchSerial1(v DevicePatchSerial1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchSerial1 performs a merge with any union data inside the DevicePatch_Serial, using the provided DevicePatchSerial1
func (t *DevicePatch_Serial) MergeDevicePatchSerial1(v DevicePatchSerial1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_Serial) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_Serial) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceTags returns the union data inside the DevicePatch_Tags as a DeviceTags
func (t DevicePatch_Tags) AsDeviceTags() (DeviceTags, error) {
	var body DeviceTags
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceTags overwrites any union data inside the DevicePatch_Tags as the provided DeviceTags
func (t *DevicePatch_Tags) FromDeviceTags(v DeviceTags) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceTags performs a merge with any union data inside the DevicePatch_Tags, using the provided DeviceTags
func (t *DevicePatch_Tags) MergeDeviceTags(v DeviceTags) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDevicePatchTags1 returns the union data inside the DevicePatch_Tags as a DevicePatchTags1
func (t DevicePatch_Tags) AsDevicePatchTags1() (DevicePatchTags1, error) {
	var body DevicePatchTags1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDevicePatchTags1 overwrites any union data inside the DevicePatch_Tags as the provided DevicePatchTags1
func (t *DevicePatch_Tags) FromDevicePatchTags1(v DevicePatchTags1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDevicePatchTags1 performs a merge with any union data inside the DevicePatch_Tags, using the provided DevicePatchTags1
func (t *DevicePatch_Tags) MergeDevicePatchTags1(v DevicePatchTags1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DevicePatch_Tags) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DevicePatch_Tags) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeviceUserPatchEmail0 returns the union data inside the DeviceUserPatch_Email as a DeviceUserPatchEmail0
func (t DeviceUserPatch_Email) AsDeviceUserPatchEmail0() (DeviceUserPatchEmail0, error) {
	var body DeviceUserPatchEmail0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceUserPatchEmail0 overwrites any union data inside the DeviceUserPatch_Email as the provided DeviceUserPatchEmail0
func (t *DeviceUserPatch_Email) FromDeviceUserPatchEmail0(v DeviceUserPatchEmail0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceUserPatchEmail0 performs a merge with any union data inside the DeviceUserPatch_Email, using the provided DeviceUserPatchEmail0
func (t *DeviceUserPatch_Email) MergeDeviceUserPatchEmail0(v DeviceUserPatchEmail0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeviceUserPatchEmail1 returns the union data inside the DeviceUserPatch_Email as a DeviceUserPatchEmail1
func (t DeviceUserPatch_Email) AsDeviceUserPatchEmail1() (DeviceUserPatchEmail1, error) {
	var body DeviceUserPatchEmail1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeviceUserPatchEmail1 overwrites any union data inside the DeviceUserPatch_Email as the provided DeviceUserPatchEmail1
func (t *DeviceUserPatch_Email) FromDeviceUserPatchEmail1(v DeviceUserPatchEmail1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeviceUserPatchEmail1 performs a merge with any union data inside the DeviceUserPatch_Email, using the provided DeviceUserPatchEmail1
func (t *DeviceUserPatch_Email) MergeDeviceUserPatchEmail1(v DeviceUserPatchEmail1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeviceUserPatch_Email) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeviceUserPatch_Email) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsX509Fields returns the union data inside the EndpointCertificateInfo_Details as a X509Fields
func (t EndpointCertificateInfo_Details) AsX509Fields() (X509Fields, error) {
	var body X509Fields
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX509Fields overwrites any union data inside the EndpointCertificateInfo_Details as the provided X509Fields
func (t *EndpointCertificateInfo_Details) FromX509Fields(v X509Fields) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX509Fields performs a merge with any union data inside the EndpointCertificateInfo_Details, using the provided X509Fields
func (t *EndpointCertificateInfo_Details) MergeX509Fields(v X509Fields) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSshFields returns the union data inside the EndpointCertificateInfo_Details as a SshFields
func (t EndpointCertificateInfo_Details) AsSshFields() (SshFields, error) {
	var body SshFields
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSshFields overwrites any union data inside the EndpointCertificateInfo_Details as the provided SshFields
func (t *EndpointCertificateInfo_Details) FromSshFields(v SshFields) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSshFields performs a merge with any union data inside the EndpointCertificateInfo_Details, using the provided SshFields
func (t *EndpointCertificateInfo_Details) MergeSshFields(v SshFields) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EndpointCertificateInfo_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EndpointCertificateInfo_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWifiAccount returns the union data inside the EndpointConfiguration_ExtendedTypeConfiguration as a WifiAccount
func (t EndpointConfiguration_ExtendedTypeConfiguration) AsWifiAccount() (WifiAccount, error) {
	var body WifiAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWifiAccount overwrites any union data inside the EndpointConfiguration_ExtendedTypeConfiguration as the provided WifiAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) FromWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWifiAccount performs a merge with any union data inside the EndpointConfiguration_ExtendedTypeConfiguration, using the provided WifiAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) MergeWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEthernetAccount returns the union data inside the EndpointConfiguration_ExtendedTypeConfiguration as a EthernetAccount
func (t EndpointConfiguration_ExtendedTypeConfiguration) AsEthernetAccount() (EthernetAccount, error) {
	var body EthernetAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthernetAccount overwrites any union data inside the EndpointConfiguration_ExtendedTypeConfiguration as the provided EthernetAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) FromEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthernetAccount performs a merge with any union data inside the EndpointConfiguration_ExtendedTypeConfiguration, using the provided EthernetAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) MergeEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVpnAccount returns the union data inside the EndpointConfiguration_ExtendedTypeConfiguration as a VpnAccount
func (t EndpointConfiguration_ExtendedTypeConfiguration) AsVpnAccount() (VpnAccount, error) {
	var body VpnAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnAccount overwrites any union data inside the EndpointConfiguration_ExtendedTypeConfiguration as the provided VpnAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) FromVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnAccount performs a merge with any union data inside the EndpointConfiguration_ExtendedTypeConfiguration, using the provided VpnAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) MergeVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBrowserAccount returns the union data inside the EndpointConfiguration_ExtendedTypeConfiguration as a BrowserAccount
func (t EndpointConfiguration_ExtendedTypeConfiguration) AsBrowserAccount() (BrowserAccount, error) {
	var body BrowserAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBrowserAccount overwrites any union data inside the EndpointConfiguration_ExtendedTypeConfiguration as the provided BrowserAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) FromBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBrowserAccount performs a merge with any union data inside the EndpointConfiguration_ExtendedTypeConfiguration, using the provided BrowserAccount
func (t *EndpointConfiguration_ExtendedTypeConfiguration) MergeBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EndpointConfiguration_ExtendedTypeConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EndpointConfiguration_ExtendedTypeConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWifiAccount returns the union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as a WifiAccount
func (t EndpointConfigurationRequest_ExtendedTypeConfiguration) AsWifiAccount() (WifiAccount, error) {
	var body WifiAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWifiAccount overwrites any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as the provided WifiAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) FromWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWifiAccount performs a merge with any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration, using the provided WifiAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) MergeWifiAccount(v WifiAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEthernetAccount returns the union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as a EthernetAccount
func (t EndpointConfigurationRequest_ExtendedTypeConfiguration) AsEthernetAccount() (EthernetAccount, error) {
	var body EthernetAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEthernetAccount overwrites any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as the provided EthernetAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) FromEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEthernetAccount performs a merge with any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration, using the provided EthernetAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) MergeEthernetAccount(v EthernetAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVpnAccount returns the union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as a VpnAccount
func (t EndpointConfigurationRequest_ExtendedTypeConfiguration) AsVpnAccount() (VpnAccount, error) {
	var body VpnAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnAccount overwrites any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as the provided VpnAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) FromVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnAccount performs a merge with any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration, using the provided VpnAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) MergeVpnAccount(v VpnAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBrowserAccount returns the union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as a BrowserAccount
func (t EndpointConfigurationRequest_ExtendedTypeConfiguration) AsBrowserAccount() (BrowserAccount, error) {
	var body BrowserAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBrowserAccount overwrites any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration as the provided BrowserAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) FromBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBrowserAccount performs a merge with any union data inside the EndpointConfigurationRequest_ExtendedTypeConfiguration, using the provided BrowserAccount
func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) MergeBrowserAccount(v BrowserAccount) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EndpointConfigurationRequest_ExtendedTypeConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EndpointConfigurationRequest_ExtendedTypeConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsPlatform returns the union data inside the NewPlatform_PlatformConfiguration as a AwsPlatform
func (t NewPlatform_PlatformConfiguration) AsAwsPlatform() (AwsPlatform, error) {
	var body AwsPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsPlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided AwsPlatform
func (t *NewPlatform_PlatformConfiguration) FromAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsPlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided AwsPlatform
func (t *NewPlatform_PlatformConfiguration) MergeAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzurePlatform returns the union data inside the NewPlatform_PlatformConfiguration as a AzurePlatform
func (t NewPlatform_PlatformConfiguration) AsAzurePlatform() (AzurePlatform, error) {
	var body AzurePlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzurePlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided AzurePlatform
func (t *NewPlatform_PlatformConfiguration) FromAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzurePlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided AzurePlatform
func (t *NewPlatform_PlatformConfiguration) MergeAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGcpPlatform returns the union data inside the NewPlatform_PlatformConfiguration as a GcpPlatform
func (t NewPlatform_PlatformConfiguration) AsGcpPlatform() (GcpPlatform, error) {
	var body GcpPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpPlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided GcpPlatform
func (t *NewPlatform_PlatformConfiguration) FromGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpPlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided GcpPlatform
func (t *NewPlatform_PlatformConfiguration) MergeGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewPlatform_PlatformConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewPlatform_PlatformConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsPlatform returns the union data inside the Platform_PlatformConfigurations_Item as a AwsPlatform
func (t Platform_PlatformConfigurations_Item) AsAwsPlatform() (AwsPlatform, error) {
	var body AwsPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsPlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided AwsPlatform
func (t *Platform_PlatformConfigurations_Item) FromAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsPlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided AwsPlatform
func (t *Platform_PlatformConfigurations_Item) MergeAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzurePlatform returns the union data inside the Platform_PlatformConfigurations_Item as a AzurePlatform
func (t Platform_PlatformConfigurations_Item) AsAzurePlatform() (AzurePlatform, error) {
	var body AzurePlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzurePlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided AzurePlatform
func (t *Platform_PlatformConfigurations_Item) FromAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzurePlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided AzurePlatform
func (t *Platform_PlatformConfigurations_Item) MergeAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGcpPlatform returns the union data inside the Platform_PlatformConfigurations_Item as a GcpPlatform
func (t Platform_PlatformConfigurations_Item) AsGcpPlatform() (GcpPlatform, error) {
	var body GcpPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpPlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided GcpPlatform
func (t *Platform_PlatformConfigurations_Item) FromGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpPlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided GcpPlatform
func (t *Platform_PlatformConfigurations_Item) MergeGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Platform_PlatformConfigurations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Platform_PlatformConfigurations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAcmeProvisioner returns the union data inside the Provisioner as a AcmeProvisioner
func (t Provisioner) AsAcmeProvisioner() (AcmeProvisioner, error) {
	var body AcmeProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeProvisioner overwrites any union data inside the Provisioner as the provided AcmeProvisioner
func (t *Provisioner) FromAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeProvisioner
func (t *Provisioner) MergeAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAcmeAttestationProvisioner returns the union data inside the Provisioner as a AcmeAttestationProvisioner
func (t Provisioner) AsAcmeAttestationProvisioner() (AcmeAttestationProvisioner, error) {
	var body AcmeAttestationProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeAttestationProvisioner overwrites any union data inside the Provisioner as the provided AcmeAttestationProvisioner
func (t *Provisioner) FromAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeAttestationProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeAttestationProvisioner
func (t *Provisioner) MergeAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsX5cProvisioner returns the union data inside the Provisioner as a X5cProvisioner
func (t Provisioner) AsX5cProvisioner() (X5cProvisioner, error) {
	var body X5cProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX5cProvisioner overwrites any union data inside the Provisioner as the provided X5cProvisioner
func (t *Provisioner) FromX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX5cProvisioner performs a merge with any union data inside the Provisioner, using the provided X5cProvisioner
func (t *Provisioner) MergeX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAwsProvisioner returns the union data inside the Provisioner as a AwsProvisioner
func (t Provisioner) AsAwsProvisioner() (AwsProvisioner, error) {
	var body AwsProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsProvisioner overwrites any union data inside the Provisioner as the provided AwsProvisioner
func (t *Provisioner) FromAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsProvisioner performs a merge with any union data inside the Provisioner, using the provided AwsProvisioner
func (t *Provisioner) MergeAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGcpProvisioner returns the union data inside the Provisioner as a GcpProvisioner
func (t Provisioner) AsGcpProvisioner() (GcpProvisioner, error) {
	var body GcpProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpProvisioner overwrites any union data inside the Provisioner as the provided GcpProvisioner
func (t *Provisioner) FromGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpProvisioner performs a merge with any union data inside the Provisioner, using the provided GcpProvisioner
func (t *Provisioner) MergeGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureProvisioner returns the union data inside the Provisioner as a AzureProvisioner
func (t Provisioner) AsAzureProvisioner() (AzureProvisioner, error) {
	var body AzureProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureProvisioner overwrites any union data inside the Provisioner as the provided AzureProvisioner
func (t *Provisioner) FromAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureProvisioner performs a merge with any union data inside the Provisioner, using the provided AzureProvisioner
func (t *Provisioner) MergeAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScepProvisioner returns the union data inside the Provisioner as a ScepProvisioner
func (t Provisioner) AsScepProvisioner() (ScepProvisioner, error) {
	var body ScepProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScepProvisioner overwrites any union data inside the Provisioner as the provided ScepProvisioner
func (t *Provisioner) FromScepProvisioner(v ScepProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScepProvisioner performs a merge with any union data inside the Provisioner, using the provided ScepProvisioner
func (t *Provisioner) MergeScepProvisioner(v ScepProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsReplyAttribute0 returns the union data inside the ReplyAttribute as a ReplyAttribute0
func (t ReplyAttribute) AsReplyAttribute0() (ReplyAttribute0, error) {
	var body ReplyAttribute0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReplyAttribute0 overwrites any union data inside the ReplyAttribute as the provided ReplyAttribute0
func (t *ReplyAttribute) FromReplyAttribute0(v ReplyAttribute0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReplyAttribute0 performs a merge with any union data inside the ReplyAttribute, using the provided ReplyAttribute0
func (t *ReplyAttribute) MergeReplyAttribute0(v ReplyAttribute0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReplyAttribute1 returns the union data inside the ReplyAttribute as a ReplyAttribute1
func (t ReplyAttribute) AsReplyAttribute1() (ReplyAttribute1, error) {
	var body ReplyAttribute1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReplyAttribute1 overwrites any union data inside the ReplyAttribute as the provided ReplyAttribute1
func (t *ReplyAttribute) FromReplyAttribute1(v ReplyAttribute1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReplyAttribute1 performs a merge with any union data inside the ReplyAttribute, using the provided ReplyAttribute1
func (t *ReplyAttribute) MergeReplyAttribute1(v ReplyAttribute1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReplyAttribute) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Value != nil {
		object["value"], err = json.Marshal(t.Value)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'value': %w", err)
		}
	}

	if t.ValueFromExtension != nil {
		object["valueFromExtension"], err = json.Marshal(t.ValueFromExtension)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'valueFromExtension': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *ReplyAttribute) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &t.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
	}

	if raw, found := object["valueFromExtension"]; found {
		err = json.Unmarshal(raw, &t.ValueFromExtension)
		if err != nil {
			return fmt.Errorf("error reading 'valueFromExtension': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAccountsWithBody request with any body
	PostAccountsWithBody(ctx context.Context, params *PostAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAccounts(ctx context.Context, params *PostAccountsParams, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccount request
	DeleteAccount(ctx context.Context, accountID AccountID, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, accountID AccountID, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAccountWithBody request with any body
	PutAccountWithBody(ctx context.Context, accountID AccountID, params *PutAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAccount(ctx context.Context, accountID AccountID, params *PutAccountParams, body PutAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthWithBody request with any body
	PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorities request
	GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthoritiesWithBody request with any body
	PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthoritiesCsrWithBody request with any body
	PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthority request
	DeleteAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthority request
	GetAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthorityProvisioners request
	ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityProvisionersWithBody request with any body
	PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProvisioner request
	DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProvisioner request
	GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooksWithBody request with any body
	PostWebhooksWithBody(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWebhooks(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityRootWithBody request with any body
	PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCertificates request
	ListCertificates(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificate request
	GetCertificate(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredential request
	DeleteCredential(ctx context.Context, credentialID CredentialID, params *DeleteCredentialParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredential request
	GetCredential(ctx context.Context, credentialID CredentialID, params *GetCredentialParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutCredentialWithBody request with any body
	PutCredentialWithBody(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutCredential(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, body PutCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCredentialsWithBody request with any body
	PostCredentialsWithBody(ctx context.Context, params *PostCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCredentials(ctx context.Context, params *PostCredentialsParams, body PostCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDevices request
	ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDevicesWithBody request with any body
	PostDevicesWithBody(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDevices(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDevice request
	DeleteDevice(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDevice request
	GetDevice(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchDeviceWithBody request with any body
	PatchDeviceWithBody(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchDevice(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEndpointConfigurations request
	ListEndpointConfigurations(ctx context.Context, params *ListEndpointConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEndpointConfigurationsWithBody request with any body
	PostEndpointConfigurationsWithBody(ctx context.Context, params *PostEndpointConfigurationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEndpointConfigurations(ctx context.Context, params *PostEndpointConfigurationsParams, body PostEndpointConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEndpointConfiguration request
	DeleteEndpointConfiguration(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *DeleteEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEndpointConfiguration request
	GetEndpointConfiguration(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *GetEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutEndpointConfigurationWithBody request with any body
	PutEndpointConfigurationWithBody(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutEndpointConfiguration(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, body PutEndpointConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListManagedRadius request
	ListManagedRadius(ctx context.Context, params *ListManagedRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostManagedRadiusWithBody request with any body
	PostManagedRadiusWithBody(ctx context.Context, params *PostManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostManagedRadius(ctx context.Context, params *PostManagedRadiusParams, body PostManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManagedRadius request
	DeleteManagedRadius(ctx context.Context, managedRadiusID ManagedRadiusID, params *DeleteManagedRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManagedRadius request
	GetManagedRadius(ctx context.Context, managedRadiusID ManagedRadiusID, params *GetManagedRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutManagedRadiusWithBody request with any body
	PutManagedRadiusWithBody(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutManagedRadius(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, body PutManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatforms request
	GetPlatforms(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPlatformWithBody request with any body
	PutPlatformWithBody(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPlatform(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBrowser request
	ListBrowser(ctx context.Context, params *ListBrowserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBrowserWithBody request with any body
	PostBrowserWithBody(ctx context.Context, params *PostBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBrowser(ctx context.Context, params *PostBrowserParams, body PostBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBrowser request
	DeleteBrowser(ctx context.Context, browserID BrowserID, params *DeleteBrowserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrowser request
	GetBrowser(ctx context.Context, browserID BrowserID, params *GetBrowserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutBrowserWithBody request with any body
	PutBrowserWithBody(ctx context.Context, browserID BrowserID, params *PutBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutBrowser(ctx context.Context, browserID BrowserID, params *PutBrowserParams, body PutBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEthernet request
	ListEthernet(ctx context.Context, params *ListEthernetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEthernetWithBody request with any body
	PostEthernetWithBody(ctx context.Context, params *PostEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEthernet(ctx context.Context, params *PostEthernetParams, body PostEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEthernet request
	DeleteEthernet(ctx context.Context, ethernetID EthernetID, params *DeleteEthernetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEthernet request
	GetEthernet(ctx context.Context, ethernetID EthernetID, params *GetEthernetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutEthernetWithBody request with any body
	PutEthernetWithBody(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutEthernet(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, body PutEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVpn request
	ListVpn(ctx context.Context, params *ListVpnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVpnWithBody request with any body
	PostVpnWithBody(ctx context.Context, params *PostVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVpn(ctx context.Context, params *PostVpnParams, body PostVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpn request
	DeleteVpn(ctx context.Context, vpnID VpnID, params *DeleteVpnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVpn request
	GetVpn(ctx context.Context, vpnID VpnID, params *GetVpnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutVpnWithBody request with any body
	PutVpnWithBody(ctx context.Context, vpnID VpnID, params *PutVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutVpn(ctx context.Context, vpnID VpnID, params *PutVpnParams, body PutVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWifi request
	ListWifi(ctx context.Context, params *ListWifiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWifiWithBody request with any body
	PostWifiWithBody(ctx context.Context, params *PostWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWifi(ctx context.Context, params *PostWifiParams, body PostWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWifi request
	DeleteWifi(ctx context.Context, wifiID WifiID, params *DeleteWifiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWifi request
	GetWifi(ctx context.Context, wifiID WifiID, params *GetWifiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWifiWithBody request with any body
	PutWifiWithBody(ctx context.Context, wifiID WifiID, params *PutWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutWifi(ctx context.Context, wifiID WifiID, params *PutWifiParams, body PutWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIdentityProvider request
	DeleteIdentityProvider(ctx context.Context, params *DeleteIdentityProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityProvider request
	GetIdentityProvider(ctx context.Context, params *GetIdentityProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutIdentityProviderWithBody request with any body
	PutIdentityProviderWithBody(ctx context.Context, params *PutIdentityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutIdentityProvider(ctx context.Context, params *PutIdentityProviderParams, body PutIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIdpClients request
	ListIdpClients(ctx context.Context, params *ListIdpClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostIdpClientsWithBody request with any body
	PostIdpClientsWithBody(ctx context.Context, params *PostIdpClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostIdpClients(ctx context.Context, params *PostIdpClientsParams, body PostIdpClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIdpClient request
	DeleteIdpClient(ctx context.Context, idpClientID IdpClientID, params *DeleteIdpClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdpClient request
	GetIdpClient(ctx context.Context, idpClientID IdpClientID, params *GetIdpClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccountsWithBody(ctx context.Context, params *PostAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccounts(ctx context.Context, params *PostAccountsParams, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccount(ctx context.Context, accountID AccountID, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, accountID AccountID, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, accountID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAccountWithBody(ctx context.Context, accountID AccountID, params *PutAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAccountRequestWithBody(c.Server, accountID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAccount(ctx context.Context, accountID AccountID, params *PutAccountParams, body PutAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAccountRequest(c.Server, accountID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthoritiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorityRequest(c.Server, authorityDomainOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthority(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorityRequest(c.Server, authorityDomainOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthorityProvisionersRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWithBody(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequestWithBody(c.Server, authorityID, provisionerNameOrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooks(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequest(c.Server, authorityID, provisionerNameOrID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, authorityID, provisionerNameOrID, webhookNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, authorityID, provisionerNameOrID, webhookNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCertificates(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificate(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateRequest(c.Server, serialNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredential(ctx context.Context, credentialID CredentialID, params *DeleteCredentialParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialRequest(c.Server, credentialID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredential(ctx context.Context, credentialID CredentialID, params *GetCredentialParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialRequest(c.Server, credentialID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCredentialWithBody(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCredentialRequestWithBody(c.Server, credentialID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCredential(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, body PutCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCredentialRequest(c.Server, credentialID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCredentialsWithBody(ctx context.Context, params *PostCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCredentialsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCredentials(ctx context.Context, params *PostCredentialsParams, body PostCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCredentialsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDevicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDevicesWithBody(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDevicesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDevices(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDevicesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDevice(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceRequest(c.Server, deviceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDevice(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceRequest(c.Server, deviceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDeviceWithBody(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDeviceRequestWithBody(c.Server, deviceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDevice(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDeviceRequest(c.Server, deviceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEndpointConfigurations(ctx context.Context, params *ListEndpointConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEndpointConfigurationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEndpointConfigurationsWithBody(ctx context.Context, params *PostEndpointConfigurationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEndpointConfigurationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEndpointConfigurations(ctx context.Context, params *PostEndpointConfigurationsParams, body PostEndpointConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEndpointConfigurationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEndpointConfiguration(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *DeleteEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEndpointConfigurationRequest(c.Server, endpointConfigurationID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEndpointConfiguration(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *GetEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEndpointConfigurationRequest(c.Server, endpointConfigurationID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEndpointConfigurationWithBody(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEndpointConfigurationRequestWithBody(c.Server, endpointConfigurationID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEndpointConfiguration(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, body PutEndpointConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEndpointConfigurationRequest(c.Server, endpointConfigurationID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListManagedRadius(ctx context.Context, params *ListManagedRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListManagedRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostManagedRadiusWithBody(ctx context.Context, params *PostManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostManagedRadiusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostManagedRadius(ctx context.Context, params *PostManagedRadiusParams, body PostManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostManagedRadiusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManagedRadius(ctx context.Context, managedRadiusID ManagedRadiusID, params *DeleteManagedRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManagedRadiusRequest(c.Server, managedRadiusID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManagedRadius(ctx context.Context, managedRadiusID ManagedRadiusID, params *GetManagedRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManagedRadiusRequest(c.Server, managedRadiusID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutManagedRadiusWithBody(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutManagedRadiusRequestWithBody(c.Server, managedRadiusID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutManagedRadius(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, body PutManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutManagedRadiusRequest(c.Server, managedRadiusID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatforms(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlatformWithBody(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlatformRequestWithBody(c.Server, platformSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlatform(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlatformRequest(c.Server, platformSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBrowser(ctx context.Context, params *ListBrowserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBrowserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBrowserWithBody(ctx context.Context, params *PostBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBrowserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBrowser(ctx context.Context, params *PostBrowserParams, body PostBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBrowserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBrowser(ctx context.Context, browserID BrowserID, params *DeleteBrowserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBrowserRequest(c.Server, browserID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrowser(ctx context.Context, browserID BrowserID, params *GetBrowserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrowserRequest(c.Server, browserID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBrowserWithBody(ctx context.Context, browserID BrowserID, params *PutBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBrowserRequestWithBody(c.Server, browserID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutBrowser(ctx context.Context, browserID BrowserID, params *PutBrowserParams, body PutBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutBrowserRequest(c.Server, browserID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEthernet(ctx context.Context, params *ListEthernetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEthernetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEthernetWithBody(ctx context.Context, params *PostEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEthernetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEthernet(ctx context.Context, params *PostEthernetParams, body PostEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEthernetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEthernet(ctx context.Context, ethernetID EthernetID, params *DeleteEthernetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEthernetRequest(c.Server, ethernetID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEthernet(ctx context.Context, ethernetID EthernetID, params *GetEthernetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEthernetRequest(c.Server, ethernetID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEthernetWithBody(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEthernetRequestWithBody(c.Server, ethernetID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEthernet(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, body PutEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEthernetRequest(c.Server, ethernetID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVpn(ctx context.Context, params *ListVpnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVpnRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVpnWithBody(ctx context.Context, params *PostVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVpnRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVpn(ctx context.Context, params *PostVpnParams, body PostVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVpnRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpn(ctx context.Context, vpnID VpnID, params *DeleteVpnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnRequest(c.Server, vpnID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVpn(ctx context.Context, vpnID VpnID, params *GetVpnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVpnRequest(c.Server, vpnID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVpnWithBody(ctx context.Context, vpnID VpnID, params *PutVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVpnRequestWithBody(c.Server, vpnID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVpn(ctx context.Context, vpnID VpnID, params *PutVpnParams, body PutVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVpnRequest(c.Server, vpnID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWifi(ctx context.Context, params *ListWifiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWifiRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWifiWithBody(ctx context.Context, params *PostWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWifiRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWifi(ctx context.Context, params *PostWifiParams, body PostWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWifiRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWifi(ctx context.Context, wifiID WifiID, params *DeleteWifiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWifiRequest(c.Server, wifiID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWifi(ctx context.Context, wifiID WifiID, params *GetWifiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWifiRequest(c.Server, wifiID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWifiWithBody(ctx context.Context, wifiID WifiID, params *PutWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWifiRequestWithBody(c.Server, wifiID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWifi(ctx context.Context, wifiID WifiID, params *PutWifiParams, body PutWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWifiRequest(c.Server, wifiID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIdentityProvider(ctx context.Context, params *DeleteIdentityProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIdentityProviderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityProvider(ctx context.Context, params *GetIdentityProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityProviderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutIdentityProviderWithBody(ctx context.Context, params *PutIdentityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutIdentityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutIdentityProvider(ctx context.Context, params *PutIdentityProviderParams, body PutIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutIdentityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIdpClients(ctx context.Context, params *ListIdpClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIdpClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIdpClientsWithBody(ctx context.Context, params *PostIdpClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIdpClientsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIdpClients(ctx context.Context, params *PostIdpClientsParams, body PostIdpClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIdpClientsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIdpClient(ctx context.Context, idpClientID IdpClientID, params *DeleteIdpClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIdpClientRequest(c.Server, idpClientID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdpClient(ctx context.Context, idpClientID IdpClientID, params *GetIdpClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdpClientRequest(c.Server, idpClientID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAccountsRequest calls the generic PostAccounts builder with application/json body
func NewPostAccountsRequest(server string, params *PostAccountsParams, body PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAccountsRequestWithBody generates requests for PostAccounts with any type of body
func NewPostAccountsRequestWithBody(server string, params *PostAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteAccountRequest generates requests for DeleteAccount
func NewDeleteAccountRequest(server string, accountID AccountID, params *DeleteAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountID", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, accountID AccountID, params *GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountID", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutAccountRequest calls the generic PutAccount builder with application/json body
func NewPutAccountRequest(server string, accountID AccountID, params *PutAccountParams, body PutAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAccountRequestWithBody(server, accountID, params, "application/json", bodyReader)
}

// NewPutAccountRequestWithBody generates requests for PutAccount with any type of body
func NewPutAccountRequestWithBody(server string, accountID AccountID, params *PutAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountID", runtime.ParamLocationPath, accountID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthRequest calls the generic PostAuth builder with application/json body
func NewPostAuthRequest(server string, body PostAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthRequestWithBody generates requests for PostAuth with any type of body
func NewPostAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthoritiesRequest generates requests for GetAuthorities
func NewGetAuthoritiesRequest(server string, params *GetAuthoritiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthoritiesRequest calls the generic PostAuthorities builder with application/json body
func NewPostAuthoritiesRequest(server string, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesRequestWithBody generates requests for PostAuthorities with any type of body
func NewPostAuthoritiesRequestWithBody(server string, params *PostAuthoritiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthoritiesCsrRequest calls the generic PostAuthoritiesCsr builder with application/json body
func NewPostAuthoritiesCsrRequest(server string, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesCsrRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesCsrRequestWithBody generates requests for PostAuthoritiesCsr with any type of body
func NewPostAuthoritiesCsrRequestWithBody(server string, params *PostAuthoritiesCsrParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/csr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteAuthorityRequest generates requests for DeleteAuthority
func NewDeleteAuthorityRequest(server string, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityDomainOrID", runtime.ParamLocationPath, authorityDomainOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetAuthorityRequest generates requests for GetAuthority
func NewGetAuthorityRequest(server string, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityDomainOrID", runtime.ParamLocationPath, authorityDomainOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListAuthorityProvisionersRequest generates requests for ListAuthorityProvisioners
func NewListAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *ListAuthorityProvisionersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthorityProvisionersRequest calls the generic PostAuthorityProvisioners builder with application/json body
func NewPostAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityProvisionersRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityProvisionersRequestWithBody generates requests for PostAuthorityProvisioners with any type of body
func NewPostAuthorityProvisionersRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteProvisionerRequest generates requests for DeleteProvisioner
func NewDeleteProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetProvisionerRequest generates requests for GetProvisioner
func NewGetProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostWebhooksRequest calls the generic PostWebhooks builder with application/json body
func NewPostWebhooksRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWebhooksRequestWithBody(server, authorityID, provisionerNameOrID, params, "application/json", bodyReader)
}

// NewPostWebhooksRequestWithBody generates requests for PostWebhooks with any type of body
func NewPostWebhooksRequestWithBody(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, webhookNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, webhookNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostAuthorityRootRequest calls the generic PostAuthorityRoot builder with application/json body
func NewPostAuthorityRootRequest(server string, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityRootRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityRootRequestWithBody generates requests for PostAuthorityRoot with any type of body
func NewPostAuthorityRootRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/root", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListCertificatesRequest generates requests for ListCertificates
func NewListCertificatesRequest(server string, params *ListCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetCertificateRequest generates requests for GetCertificate
func NewGetCertificateRequest(server string, serialNumber SerialNumber, params *GetCertificateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serialNumber", runtime.ParamLocationPath, serialNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteCredentialRequest generates requests for DeleteCredential
func NewDeleteCredentialRequest(server string, credentialID CredentialID, params *DeleteCredentialParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "credentialID", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credential/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetCredentialRequest generates requests for GetCredential
func NewGetCredentialRequest(server string, credentialID CredentialID, params *GetCredentialParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "credentialID", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credential/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutCredentialRequest calls the generic PutCredential builder with application/json body
func NewPutCredentialRequest(server string, credentialID CredentialID, params *PutCredentialParams, body PutCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCredentialRequestWithBody(server, credentialID, params, "application/json", bodyReader)
}

// NewPutCredentialRequestWithBody generates requests for PutCredential with any type of body
func NewPutCredentialRequestWithBody(server string, credentialID CredentialID, params *PutCredentialParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "credentialID", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credential/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostCredentialsRequest calls the generic PostCredentials builder with application/json body
func NewPostCredentialsRequest(server string, params *PostCredentialsParams, body PostCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCredentialsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCredentialsRequestWithBody generates requests for PostCredentials with any type of body
func NewPostCredentialsRequestWithBody(server string, params *PostCredentialsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListDevicesRequest generates requests for ListDevices
func NewListDevicesRequest(server string, params *ListDevicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostDevicesRequest calls the generic PostDevices builder with application/json body
func NewPostDevicesRequest(server string, params *PostDevicesParams, body PostDevicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDevicesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostDevicesRequestWithBody generates requests for PostDevices with any type of body
func NewPostDevicesRequestWithBody(server string, params *PostDevicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteDeviceRequest generates requests for DeleteDevice
func NewDeleteDeviceRequest(server string, deviceID DeviceID, params *DeleteDeviceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deviceID", runtime.ParamLocationPath, deviceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetDeviceRequest generates requests for GetDevice
func NewGetDeviceRequest(server string, deviceID DeviceID, params *GetDeviceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deviceID", runtime.ParamLocationPath, deviceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPatchDeviceRequest calls the generic PatchDevice builder with application/json body
func NewPatchDeviceRequest(server string, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchDeviceRequestWithBody(server, deviceID, params, "application/json", bodyReader)
}

// NewPatchDeviceRequestWithBody generates requests for PatchDevice with any type of body
func NewPatchDeviceRequestWithBody(server string, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deviceID", runtime.ParamLocationPath, deviceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListEndpointConfigurationsRequest generates requests for ListEndpointConfigurations
func NewListEndpointConfigurationsRequest(server string, params *ListEndpointConfigurationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/endpoint-configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostEndpointConfigurationsRequest calls the generic PostEndpointConfigurations builder with application/json body
func NewPostEndpointConfigurationsRequest(server string, params *PostEndpointConfigurationsParams, body PostEndpointConfigurationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEndpointConfigurationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostEndpointConfigurationsRequestWithBody generates requests for PostEndpointConfigurations with any type of body
func NewPostEndpointConfigurationsRequestWithBody(server string, params *PostEndpointConfigurationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/endpoint-configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteEndpointConfigurationRequest generates requests for DeleteEndpointConfiguration
func NewDeleteEndpointConfigurationRequest(server string, endpointConfigurationID EndpointConfigurationID, params *DeleteEndpointConfigurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointConfigurationID", runtime.ParamLocationPath, endpointConfigurationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/endpoint-configurations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetEndpointConfigurationRequest generates requests for GetEndpointConfiguration
func NewGetEndpointConfigurationRequest(server string, endpointConfigurationID EndpointConfigurationID, params *GetEndpointConfigurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointConfigurationID", runtime.ParamLocationPath, endpointConfigurationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/endpoint-configurations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutEndpointConfigurationRequest calls the generic PutEndpointConfiguration builder with application/json body
func NewPutEndpointConfigurationRequest(server string, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, body PutEndpointConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutEndpointConfigurationRequestWithBody(server, endpointConfigurationID, params, "application/json", bodyReader)
}

// NewPutEndpointConfigurationRequestWithBody generates requests for PutEndpointConfiguration with any type of body
func NewPutEndpointConfigurationRequestWithBody(server string, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "endpointConfigurationID", runtime.ParamLocationPath, endpointConfigurationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/endpoint-configurations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListManagedRadiusRequest generates requests for ListManagedRadius
func NewListManagedRadiusRequest(server string, params *ListManagedRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/managed-radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostManagedRadiusRequest calls the generic PostManagedRadius builder with application/json body
func NewPostManagedRadiusRequest(server string, params *PostManagedRadiusParams, body PostManagedRadiusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostManagedRadiusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostManagedRadiusRequestWithBody generates requests for PostManagedRadius with any type of body
func NewPostManagedRadiusRequestWithBody(server string, params *PostManagedRadiusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/managed-radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteManagedRadiusRequest generates requests for DeleteManagedRadius
func NewDeleteManagedRadiusRequest(server string, managedRadiusID ManagedRadiusID, params *DeleteManagedRadiusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managedRadiusID", runtime.ParamLocationPath, managedRadiusID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/managed-radius/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Secret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret", runtime.ParamLocationQuery, *params.Secret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetManagedRadiusRequest generates requests for GetManagedRadius
func NewGetManagedRadiusRequest(server string, managedRadiusID ManagedRadiusID, params *GetManagedRadiusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managedRadiusID", runtime.ParamLocationPath, managedRadiusID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/managed-radius/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Secret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret", runtime.ParamLocationQuery, *params.Secret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutManagedRadiusRequest calls the generic PutManagedRadius builder with application/json body
func NewPutManagedRadiusRequest(server string, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, body PutManagedRadiusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutManagedRadiusRequestWithBody(server, managedRadiusID, params, "application/json", bodyReader)
}

// NewPutManagedRadiusRequestWithBody generates requests for PutManagedRadius with any type of body
func NewPutManagedRadiusRequestWithBody(server string, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managedRadiusID", runtime.ParamLocationPath, managedRadiusID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/managed-radius/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Secret != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret", runtime.ParamLocationQuery, *params.Secret); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetPlatformsRequest generates requests for GetPlatforms
func NewGetPlatformsRequest(server string, params *GetPlatformsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutPlatformRequest calls the generic PutPlatform builder with application/json body
func NewPutPlatformRequest(server string, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPlatformRequestWithBody(server, platformSlug, params, "application/json", bodyReader)
}

// NewPutPlatformRequestWithBody generates requests for PutPlatform with any type of body
func NewPutPlatformRequestWithBody(server string, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platformSlug", runtime.ParamLocationPath, platformSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platforms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListBrowserRequest generates requests for ListBrowser
func NewListBrowserRequest(server string, params *ListBrowserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostBrowserRequest calls the generic PostBrowser builder with application/json body
func NewPostBrowserRequest(server string, params *PostBrowserParams, body PostBrowserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBrowserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostBrowserRequestWithBody generates requests for PostBrowser with any type of body
func NewPostBrowserRequestWithBody(server string, params *PostBrowserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteBrowserRequest generates requests for DeleteBrowser
func NewDeleteBrowserRequest(server string, browserID BrowserID, params *DeleteBrowserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "browserID", runtime.ParamLocationPath, browserID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/browser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetBrowserRequest generates requests for GetBrowser
func NewGetBrowserRequest(server string, browserID BrowserID, params *GetBrowserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "browserID", runtime.ParamLocationPath, browserID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/browser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutBrowserRequest calls the generic PutBrowser builder with application/json body
func NewPutBrowserRequest(server string, browserID BrowserID, params *PutBrowserParams, body PutBrowserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutBrowserRequestWithBody(server, browserID, params, "application/json", bodyReader)
}

// NewPutBrowserRequestWithBody generates requests for PutBrowser with any type of body
func NewPutBrowserRequestWithBody(server string, browserID BrowserID, params *PutBrowserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "browserID", runtime.ParamLocationPath, browserID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/browser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListEthernetRequest generates requests for ListEthernet
func NewListEthernetRequest(server string, params *ListEthernetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/ethernet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostEthernetRequest calls the generic PostEthernet builder with application/json body
func NewPostEthernetRequest(server string, params *PostEthernetParams, body PostEthernetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEthernetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostEthernetRequestWithBody generates requests for PostEthernet with any type of body
func NewPostEthernetRequestWithBody(server string, params *PostEthernetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/ethernet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteEthernetRequest generates requests for DeleteEthernet
func NewDeleteEthernetRequest(server string, ethernetID EthernetID, params *DeleteEthernetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ethernetID", runtime.ParamLocationPath, ethernetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/ethernet/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetEthernetRequest generates requests for GetEthernet
func NewGetEthernetRequest(server string, ethernetID EthernetID, params *GetEthernetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ethernetID", runtime.ParamLocationPath, ethernetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/ethernet/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutEthernetRequest calls the generic PutEthernet builder with application/json body
func NewPutEthernetRequest(server string, ethernetID EthernetID, params *PutEthernetParams, body PutEthernetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutEthernetRequestWithBody(server, ethernetID, params, "application/json", bodyReader)
}

// NewPutEthernetRequestWithBody generates requests for PutEthernet with any type of body
func NewPutEthernetRequestWithBody(server string, ethernetID EthernetID, params *PutEthernetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ethernetID", runtime.ParamLocationPath, ethernetID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/ethernet/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListVpnRequest generates requests for ListVpn
func NewListVpnRequest(server string, params *ListVpnParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/vpn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostVpnRequest calls the generic PostVpn builder with application/json body
func NewPostVpnRequest(server string, params *PostVpnParams, body PostVpnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVpnRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostVpnRequestWithBody generates requests for PostVpn with any type of body
func NewPostVpnRequestWithBody(server string, params *PostVpnParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/vpn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteVpnRequest generates requests for DeleteVpn
func NewDeleteVpnRequest(server string, vpnID VpnID, params *DeleteVpnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpnID", runtime.ParamLocationPath, vpnID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/vpn/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetVpnRequest generates requests for GetVpn
func NewGetVpnRequest(server string, vpnID VpnID, params *GetVpnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpnID", runtime.ParamLocationPath, vpnID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/vpn/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutVpnRequest calls the generic PutVpn builder with application/json body
func NewPutVpnRequest(server string, vpnID VpnID, params *PutVpnParams, body PutVpnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutVpnRequestWithBody(server, vpnID, params, "application/json", bodyReader)
}

// NewPutVpnRequestWithBody generates requests for PutVpn with any type of body
func NewPutVpnRequestWithBody(server string, vpnID VpnID, params *PutVpnParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpnID", runtime.ParamLocationPath, vpnID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/vpn/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListWifiRequest generates requests for ListWifi
func NewListWifiRequest(server string, params *ListWifiParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/wifi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostWifiRequest calls the generic PostWifi builder with application/json body
func NewPostWifiRequest(server string, params *PostWifiParams, body PostWifiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWifiRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostWifiRequestWithBody generates requests for PostWifi with any type of body
func NewPostWifiRequestWithBody(server string, params *PostWifiParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/wifi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteWifiRequest generates requests for DeleteWifi
func NewDeleteWifiRequest(server string, wifiID WifiID, params *DeleteWifiParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wifiID", runtime.ParamLocationPath, wifiID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/wifi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetWifiRequest generates requests for GetWifi
func NewGetWifiRequest(server string, wifiID WifiID, params *GetWifiParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wifiID", runtime.ParamLocationPath, wifiID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/wifi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutWifiRequest calls the generic PutWifi builder with application/json body
func NewPutWifiRequest(server string, wifiID WifiID, params *PutWifiParams, body PutWifiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutWifiRequestWithBody(server, wifiID, params, "application/json", bodyReader)
}

// NewPutWifiRequestWithBody generates requests for PutWifi with any type of body
func NewPutWifiRequestWithBody(server string, wifiID WifiID, params *PutWifiParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wifiID", runtime.ParamLocationPath, wifiID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protect/wifi/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteIdentityProviderRequest generates requests for DeleteIdentityProvider
func NewDeleteIdentityProviderRequest(server string, params *DeleteIdentityProviderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetIdentityProviderRequest generates requests for GetIdentityProvider
func NewGetIdentityProviderRequest(server string, params *GetIdentityProviderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPutIdentityProviderRequest calls the generic PutIdentityProvider builder with application/json body
func NewPutIdentityProviderRequest(server string, params *PutIdentityProviderParams, body PutIdentityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutIdentityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPutIdentityProviderRequestWithBody generates requests for PutIdentityProvider with any type of body
func NewPutIdentityProviderRequestWithBody(server string, params *PutIdentityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewListIdpClientsRequest generates requests for ListIdpClients
func NewListIdpClientsRequest(server string, params *ListIdpClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewPostIdpClientsRequest calls the generic PostIdpClients builder with application/json body
func NewPostIdpClientsRequest(server string, params *PostIdpClientsParams, body PostIdpClientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostIdpClientsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostIdpClientsRequestWithBody generates requests for PostIdpClients with any type of body
func NewPostIdpClientsRequestWithBody(server string, params *PostIdpClientsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewDeleteIdpClientRequest generates requests for DeleteIdpClient
func NewDeleteIdpClientRequest(server string, idpClientID IdpClientID, params *DeleteIdpClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "idpClientID", runtime.ParamLocationPath, idpClientID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

// NewGetIdpClientRequest generates requests for GetIdpClient
func NewGetIdpClientRequest(server string, idpClientID IdpClientID, params *GetIdpClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "idpClientID", runtime.ParamLocationPath, idpClientID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sso/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestId != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-Id", headerParam0)
		}

		if params.Accept != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccountsWithResponse request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error)

	// PostAccountsWithBodyWithResponse request with any body
	PostAccountsWithBodyWithResponse(ctx context.Context, params *PostAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error)

	PostAccountsWithResponse(ctx context.Context, params *PostAccountsParams, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error)

	// DeleteAccountWithResponse request
	DeleteAccountWithResponse(ctx context.Context, accountID AccountID, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, accountID AccountID, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error)

	// PutAccountWithBodyWithResponse request with any body
	PutAccountWithBodyWithResponse(ctx context.Context, accountID AccountID, params *PutAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAccountResponse, error)

	PutAccountWithResponse(ctx context.Context, accountID AccountID, params *PutAccountParams, body PutAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAccountResponse, error)

	// PostAuthWithBodyWithResponse request with any body
	PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	// GetAuthoritiesWithResponse request
	GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error)

	// PostAuthoritiesWithBodyWithResponse request with any body
	PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	// PostAuthoritiesCsrWithBodyWithResponse request with any body
	PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	// DeleteAuthorityWithResponse request
	DeleteAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error)

	// GetAuthorityWithResponse request
	GetAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error)

	// ListAuthorityProvisionersWithResponse request
	ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error)

	// PostAuthorityProvisionersWithBodyWithResponse request with any body
	PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	// DeleteProvisionerWithResponse request
	DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error)

	// GetProvisionerWithResponse request
	GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error)

	// PostWebhooksWithBodyWithResponse request with any body
	PostWebhooksWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	PostWebhooksWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// PostAuthorityRootWithBodyWithResponse request with any body
	PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	// ListCertificatesWithResponse request
	ListCertificatesWithResponse(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*ListCertificatesResponse, error)

	// GetCertificateWithResponse request
	GetCertificateWithResponse(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*GetCertificateResponse, error)

	// DeleteCredentialWithResponse request
	DeleteCredentialWithResponse(ctx context.Context, credentialID CredentialID, params *DeleteCredentialParams, reqEditors ...RequestEditorFn) (*DeleteCredentialResponse, error)

	// GetCredentialWithResponse request
	GetCredentialWithResponse(ctx context.Context, credentialID CredentialID, params *GetCredentialParams, reqEditors ...RequestEditorFn) (*GetCredentialResponse, error)

	// PutCredentialWithBodyWithResponse request with any body
	PutCredentialWithBodyWithResponse(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCredentialResponse, error)

	PutCredentialWithResponse(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, body PutCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCredentialResponse, error)

	// PostCredentialsWithBodyWithResponse request with any body
	PostCredentialsWithBodyWithResponse(ctx context.Context, params *PostCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCredentialsResponse, error)

	PostCredentialsWithResponse(ctx context.Context, params *PostCredentialsParams, body PostCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCredentialsResponse, error)

	// ListDevicesWithResponse request
	ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error)

	// PostDevicesWithBodyWithResponse request with any body
	PostDevicesWithBodyWithResponse(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error)

	PostDevicesWithResponse(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error)

	// DeleteDeviceWithResponse request
	DeleteDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error)

	// GetDeviceWithResponse request
	GetDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*GetDeviceResponse, error)

	// PatchDeviceWithBodyWithResponse request with any body
	PatchDeviceWithBodyWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error)

	PatchDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error)

	// ListEndpointConfigurationsWithResponse request
	ListEndpointConfigurationsWithResponse(ctx context.Context, params *ListEndpointConfigurationsParams, reqEditors ...RequestEditorFn) (*ListEndpointConfigurationsResponse, error)

	// PostEndpointConfigurationsWithBodyWithResponse request with any body
	PostEndpointConfigurationsWithBodyWithResponse(ctx context.Context, params *PostEndpointConfigurationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEndpointConfigurationsResponse, error)

	PostEndpointConfigurationsWithResponse(ctx context.Context, params *PostEndpointConfigurationsParams, body PostEndpointConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEndpointConfigurationsResponse, error)

	// DeleteEndpointConfigurationWithResponse request
	DeleteEndpointConfigurationWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *DeleteEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*DeleteEndpointConfigurationResponse, error)

	// GetEndpointConfigurationWithResponse request
	GetEndpointConfigurationWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *GetEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*GetEndpointConfigurationResponse, error)

	// PutEndpointConfigurationWithBodyWithResponse request with any body
	PutEndpointConfigurationWithBodyWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEndpointConfigurationResponse, error)

	PutEndpointConfigurationWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, body PutEndpointConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEndpointConfigurationResponse, error)

	// ListManagedRadiusWithResponse request
	ListManagedRadiusWithResponse(ctx context.Context, params *ListManagedRadiusParams, reqEditors ...RequestEditorFn) (*ListManagedRadiusResponse, error)

	// PostManagedRadiusWithBodyWithResponse request with any body
	PostManagedRadiusWithBodyWithResponse(ctx context.Context, params *PostManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostManagedRadiusResponse, error)

	PostManagedRadiusWithResponse(ctx context.Context, params *PostManagedRadiusParams, body PostManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostManagedRadiusResponse, error)

	// DeleteManagedRadiusWithResponse request
	DeleteManagedRadiusWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *DeleteManagedRadiusParams, reqEditors ...RequestEditorFn) (*DeleteManagedRadiusResponse, error)

	// GetManagedRadiusWithResponse request
	GetManagedRadiusWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *GetManagedRadiusParams, reqEditors ...RequestEditorFn) (*GetManagedRadiusResponse, error)

	// PutManagedRadiusWithBodyWithResponse request with any body
	PutManagedRadiusWithBodyWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutManagedRadiusResponse, error)

	PutManagedRadiusWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, body PutManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutManagedRadiusResponse, error)

	// GetPlatformsWithResponse request
	GetPlatformsWithResponse(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*GetPlatformsResponse, error)

	// PutPlatformWithBodyWithResponse request with any body
	PutPlatformWithBodyWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error)

	PutPlatformWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error)

	// ListBrowserWithResponse request
	ListBrowserWithResponse(ctx context.Context, params *ListBrowserParams, reqEditors ...RequestEditorFn) (*ListBrowserResponse, error)

	// PostBrowserWithBodyWithResponse request with any body
	PostBrowserWithBodyWithResponse(ctx context.Context, params *PostBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBrowserResponse, error)

	PostBrowserWithResponse(ctx context.Context, params *PostBrowserParams, body PostBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBrowserResponse, error)

	// DeleteBrowserWithResponse request
	DeleteBrowserWithResponse(ctx context.Context, browserID BrowserID, params *DeleteBrowserParams, reqEditors ...RequestEditorFn) (*DeleteBrowserResponse, error)

	// GetBrowserWithResponse request
	GetBrowserWithResponse(ctx context.Context, browserID BrowserID, params *GetBrowserParams, reqEditors ...RequestEditorFn) (*GetBrowserResponse, error)

	// PutBrowserWithBodyWithResponse request with any body
	PutBrowserWithBodyWithResponse(ctx context.Context, browserID BrowserID, params *PutBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBrowserResponse, error)

	PutBrowserWithResponse(ctx context.Context, browserID BrowserID, params *PutBrowserParams, body PutBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBrowserResponse, error)

	// ListEthernetWithResponse request
	ListEthernetWithResponse(ctx context.Context, params *ListEthernetParams, reqEditors ...RequestEditorFn) (*ListEthernetResponse, error)

	// PostEthernetWithBodyWithResponse request with any body
	PostEthernetWithBodyWithResponse(ctx context.Context, params *PostEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEthernetResponse, error)

	PostEthernetWithResponse(ctx context.Context, params *PostEthernetParams, body PostEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEthernetResponse, error)

	// DeleteEthernetWithResponse request
	DeleteEthernetWithResponse(ctx context.Context, ethernetID EthernetID, params *DeleteEthernetParams, reqEditors ...RequestEditorFn) (*DeleteEthernetResponse, error)

	// GetEthernetWithResponse request
	GetEthernetWithResponse(ctx context.Context, ethernetID EthernetID, params *GetEthernetParams, reqEditors ...RequestEditorFn) (*GetEthernetResponse, error)

	// PutEthernetWithBodyWithResponse request with any body
	PutEthernetWithBodyWithResponse(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEthernetResponse, error)

	PutEthernetWithResponse(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, body PutEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEthernetResponse, error)

	// ListVpnWithResponse request
	ListVpnWithResponse(ctx context.Context, params *ListVpnParams, reqEditors ...RequestEditorFn) (*ListVpnResponse, error)

	// PostVpnWithBodyWithResponse request with any body
	PostVpnWithBodyWithResponse(ctx context.Context, params *PostVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVpnResponse, error)

	PostVpnWithResponse(ctx context.Context, params *PostVpnParams, body PostVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVpnResponse, error)

	// DeleteVpnWithResponse request
	DeleteVpnWithResponse(ctx context.Context, vpnID VpnID, params *DeleteVpnParams, reqEditors ...RequestEditorFn) (*DeleteVpnResponse, error)

	// GetVpnWithResponse request
	GetVpnWithResponse(ctx context.Context, vpnID VpnID, params *GetVpnParams, reqEditors ...RequestEditorFn) (*GetVpnResponse, error)

	// PutVpnWithBodyWithResponse request with any body
	PutVpnWithBodyWithResponse(ctx context.Context, vpnID VpnID, params *PutVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVpnResponse, error)

	PutVpnWithResponse(ctx context.Context, vpnID VpnID, params *PutVpnParams, body PutVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*PutVpnResponse, error)

	// ListWifiWithResponse request
	ListWifiWithResponse(ctx context.Context, params *ListWifiParams, reqEditors ...RequestEditorFn) (*ListWifiResponse, error)

	// PostWifiWithBodyWithResponse request with any body
	PostWifiWithBodyWithResponse(ctx context.Context, params *PostWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWifiResponse, error)

	PostWifiWithResponse(ctx context.Context, params *PostWifiParams, body PostWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWifiResponse, error)

	// DeleteWifiWithResponse request
	DeleteWifiWithResponse(ctx context.Context, wifiID WifiID, params *DeleteWifiParams, reqEditors ...RequestEditorFn) (*DeleteWifiResponse, error)

	// GetWifiWithResponse request
	GetWifiWithResponse(ctx context.Context, wifiID WifiID, params *GetWifiParams, reqEditors ...RequestEditorFn) (*GetWifiResponse, error)

	// PutWifiWithBodyWithResponse request with any body
	PutWifiWithBodyWithResponse(ctx context.Context, wifiID WifiID, params *PutWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWifiResponse, error)

	PutWifiWithResponse(ctx context.Context, wifiID WifiID, params *PutWifiParams, body PutWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*PutWifiResponse, error)

	// DeleteIdentityProviderWithResponse request
	DeleteIdentityProviderWithResponse(ctx context.Context, params *DeleteIdentityProviderParams, reqEditors ...RequestEditorFn) (*DeleteIdentityProviderResponse, error)

	// GetIdentityProviderWithResponse request
	GetIdentityProviderWithResponse(ctx context.Context, params *GetIdentityProviderParams, reqEditors ...RequestEditorFn) (*GetIdentityProviderResponse, error)

	// PutIdentityProviderWithBodyWithResponse request with any body
	PutIdentityProviderWithBodyWithResponse(ctx context.Context, params *PutIdentityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutIdentityProviderResponse, error)

	PutIdentityProviderWithResponse(ctx context.Context, params *PutIdentityProviderParams, body PutIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*PutIdentityProviderResponse, error)

	// ListIdpClientsWithResponse request
	ListIdpClientsWithResponse(ctx context.Context, params *ListIdpClientsParams, reqEditors ...RequestEditorFn) (*ListIdpClientsResponse, error)

	// PostIdpClientsWithBodyWithResponse request with any body
	PostIdpClientsWithBodyWithResponse(ctx context.Context, params *PostIdpClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIdpClientsResponse, error)

	PostIdpClientsWithResponse(ctx context.Context, params *PostIdpClientsParams, body PostIdpClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIdpClientsResponse, error)

	// DeleteIdpClientWithResponse request
	DeleteIdpClientWithResponse(ctx context.Context, idpClientID IdpClientID, params *DeleteIdpClientParams, reqEditors ...RequestEditorFn) (*DeleteIdpClientResponse, error)

	// GetIdpClientWithResponse request
	GetIdpClientWithResponse(ctx context.Context, idpClientID IdpClientID, params *GetIdpClientParams, reqEditors ...RequestEditorFn) (*GetIdpClientResponse, error)
}

type ListAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Account
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Account
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Token *string `json:"token,omitempty"`
	}
	JSON400 *N400
	JSON401 *N401
	JSON403 *N403
	JSON500 *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Authority
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Authority
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON409      *N409
	JSON412      *N412
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesCsrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthorityCsr
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON409      *N409
	JSON412      *N412
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesCsrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesCsrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Provisioner
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Provisioner
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *N409
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Provisioner
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProvisionerWebhook
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *N409
	JSON412      *N412
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProvisionerWebhook
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostAuthorityRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]X509Certificate
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *X509Certificate
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credential
	JSON400      *N400
	JSON401      *N401
	JSON404      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credential
	JSON400      *N400
	JSON401      *N401
	JSON404      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Credential
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Device
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Device
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Device
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PatchDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEndpointConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointConfiguration
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListEndpointConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndpointConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEndpointConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndpointConfiguration
	JSON400      *N400
	JSON401      *N401
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostEndpointConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEndpointConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEndpointConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteEndpointConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEndpointConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEndpointConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfiguration
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetEndpointConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEndpointConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutEndpointConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfiguration
	JSON400      *N400
	JSON401      *N401
	JSON404      *N404
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutEndpointConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutEndpointConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListManagedRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ManagedRadius
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListManagedRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListManagedRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostManagedRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedRadius
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostManagedRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostManagedRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManagedRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteManagedRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManagedRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManagedRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedRadius
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetManagedRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManagedRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutManagedRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedRadius
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON409      *N409
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutManagedRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutManagedRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Platform
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetPlatformsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Platform
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBrowserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Browser
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListBrowserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBrowserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBrowserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Browser
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostBrowserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBrowserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBrowserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteBrowserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBrowserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrowserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Browser
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetBrowserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrowserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutBrowserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Browser
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutBrowserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutBrowserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEthernetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Ethernet
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListEthernetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEthernetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEthernetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ethernet
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostEthernetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEthernetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEthernetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteEthernetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEthernetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEthernetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ethernet
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetEthernetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEthernetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutEthernetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ethernet
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutEthernetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutEthernetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVpnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Vpn
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListVpnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVpnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVpnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Vpn
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostVpnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVpnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteVpnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVpnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vpn
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetVpnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVpnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutVpnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vpn
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutVpnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutVpnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWifiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Wifi
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListWifiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWifiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWifiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Wifi
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostWifiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWifiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWifiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteWifiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWifiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWifiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Wifi
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetWifiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWifiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWifiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Wifi
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutWifiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWifiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProvider
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutIdentityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProvider
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PutIdentityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutIdentityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIdpClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProvider
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r ListIdpClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIdpClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostIdpClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IdentityProvider
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON422      *N422
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r PostIdpClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostIdpClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIdpClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r DeleteIdpClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIdpClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdpClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityProvider
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
}

// Status returns HTTPResponse.Status
func (r GetIdpClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdpClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountsWithResponse request returning *ListAccountsResponse
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResponse(rsp)
}

// PostAccountsWithBodyWithResponse request with arbitrary body returning *PostAccountsResponse
func (c *ClientWithResponses) PostAccountsWithBodyWithResponse(ctx context.Context, params *PostAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error) {
	rsp, err := c.PostAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccountsResponse(rsp)
}

func (c *ClientWithResponses) PostAccountsWithResponse(ctx context.Context, params *PostAccountsParams, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error) {
	rsp, err := c.PostAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccountsResponse(rsp)
}

// DeleteAccountWithResponse request returning *DeleteAccountResponse
func (c *ClientWithResponses) DeleteAccountWithResponse(ctx context.Context, accountID AccountID, params *DeleteAccountParams, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error) {
	rsp, err := c.DeleteAccount(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResponse(rsp)
}

// GetAccountWithResponse request returning *GetAccountResponse
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, accountID AccountID, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error) {
	rsp, err := c.GetAccount(ctx, accountID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResponse(rsp)
}

// PutAccountWithBodyWithResponse request with arbitrary body returning *PutAccountResponse
func (c *ClientWithResponses) PutAccountWithBodyWithResponse(ctx context.Context, accountID AccountID, params *PutAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAccountResponse, error) {
	rsp, err := c.PutAccountWithBody(ctx, accountID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAccountResponse(rsp)
}

func (c *ClientWithResponses) PutAccountWithResponse(ctx context.Context, accountID AccountID, params *PutAccountParams, body PutAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAccountResponse, error) {
	rsp, err := c.PutAccount(ctx, accountID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAccountResponse(rsp)
}

// PostAuthWithBodyWithResponse request with arbitrary body returning *PostAuthResponse
func (c *ClientWithResponses) PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

func (c *ClientWithResponses) PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

// GetAuthoritiesWithResponse request returning *GetAuthoritiesResponse
func (c *ClientWithResponses) GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error) {
	rsp, err := c.GetAuthorities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthoritiesResponse(rsp)
}

// PostAuthoritiesWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesResponse
func (c *ClientWithResponses) PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthoritiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthorities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

// PostAuthoritiesCsrWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesCsrResponse
func (c *ClientWithResponses) PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsrWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsr(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

// DeleteAuthorityWithResponse request returning *DeleteAuthorityResponse
func (c *ClientWithResponses) DeleteAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error) {
	rsp, err := c.DeleteAuthority(ctx, authorityDomainOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorityResponse(rsp)
}

// GetAuthorityWithResponse request returning *GetAuthorityResponse
func (c *ClientWithResponses) GetAuthorityWithResponse(ctx context.Context, authorityDomainOrID AuthorityDomainOrID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error) {
	rsp, err := c.GetAuthority(ctx, authorityDomainOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorityResponse(rsp)
}

// ListAuthorityProvisionersWithResponse request returning *ListAuthorityProvisionersResponse
func (c *ClientWithResponses) ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error) {
	rsp, err := c.ListAuthorityProvisioners(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthorityProvisionersResponse(rsp)
}

// PostAuthorityProvisionersWithBodyWithResponse request with arbitrary body returning *PostAuthorityProvisionersResponse
func (c *ClientWithResponses) PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisionersWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisioners(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

// DeleteProvisionerWithResponse request returning *DeleteProvisionerResponse
func (c *ClientWithResponses) DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error) {
	rsp, err := c.DeleteProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProvisionerResponse(rsp)
}

// GetProvisionerWithResponse request returning *GetProvisionerResponse
func (c *ClientWithResponses) GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error) {
	rsp, err := c.GetProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProvisionerResponse(rsp)
}

// PostWebhooksWithBodyWithResponse request with arbitrary body returning *PostWebhooksResponse
func (c *ClientWithResponses) PostWebhooksWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooksWithBody(ctx, authorityID, provisionerNameOrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

func (c *ClientWithResponses) PostWebhooksWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooks(ctx, authorityID, provisionerNameOrID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, authorityID, provisionerNameOrID, webhookNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, authorityID, provisionerNameOrID, webhookNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// PostAuthorityRootWithBodyWithResponse request with arbitrary body returning *PostAuthorityRootResponse
func (c *ClientWithResponses) PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRootWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRoot(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

// ListCertificatesWithResponse request returning *ListCertificatesResponse
func (c *ClientWithResponses) ListCertificatesWithResponse(ctx context.Context, params *ListCertificatesParams, reqEditors ...RequestEditorFn) (*ListCertificatesResponse, error) {
	rsp, err := c.ListCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCertificatesResponse(rsp)
}

// GetCertificateWithResponse request returning *GetCertificateResponse
func (c *ClientWithResponses) GetCertificateWithResponse(ctx context.Context, serialNumber SerialNumber, params *GetCertificateParams, reqEditors ...RequestEditorFn) (*GetCertificateResponse, error) {
	rsp, err := c.GetCertificate(ctx, serialNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateResponse(rsp)
}

// DeleteCredentialWithResponse request returning *DeleteCredentialResponse
func (c *ClientWithResponses) DeleteCredentialWithResponse(ctx context.Context, credentialID CredentialID, params *DeleteCredentialParams, reqEditors ...RequestEditorFn) (*DeleteCredentialResponse, error) {
	rsp, err := c.DeleteCredential(ctx, credentialID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialResponse(rsp)
}

// GetCredentialWithResponse request returning *GetCredentialResponse
func (c *ClientWithResponses) GetCredentialWithResponse(ctx context.Context, credentialID CredentialID, params *GetCredentialParams, reqEditors ...RequestEditorFn) (*GetCredentialResponse, error) {
	rsp, err := c.GetCredential(ctx, credentialID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialResponse(rsp)
}

// PutCredentialWithBodyWithResponse request with arbitrary body returning *PutCredentialResponse
func (c *ClientWithResponses) PutCredentialWithBodyWithResponse(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCredentialResponse, error) {
	rsp, err := c.PutCredentialWithBody(ctx, credentialID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCredentialResponse(rsp)
}

func (c *ClientWithResponses) PutCredentialWithResponse(ctx context.Context, credentialID CredentialID, params *PutCredentialParams, body PutCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCredentialResponse, error) {
	rsp, err := c.PutCredential(ctx, credentialID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCredentialResponse(rsp)
}

// PostCredentialsWithBodyWithResponse request with arbitrary body returning *PostCredentialsResponse
func (c *ClientWithResponses) PostCredentialsWithBodyWithResponse(ctx context.Context, params *PostCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCredentialsResponse, error) {
	rsp, err := c.PostCredentialsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCredentialsResponse(rsp)
}

func (c *ClientWithResponses) PostCredentialsWithResponse(ctx context.Context, params *PostCredentialsParams, body PostCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCredentialsResponse, error) {
	rsp, err := c.PostCredentials(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCredentialsResponse(rsp)
}

// ListDevicesWithResponse request returning *ListDevicesResponse
func (c *ClientWithResponses) ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error) {
	rsp, err := c.ListDevices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDevicesResponse(rsp)
}

// PostDevicesWithBodyWithResponse request with arbitrary body returning *PostDevicesResponse
func (c *ClientWithResponses) PostDevicesWithBodyWithResponse(ctx context.Context, params *PostDevicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error) {
	rsp, err := c.PostDevicesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDevicesResponse(rsp)
}

func (c *ClientWithResponses) PostDevicesWithResponse(ctx context.Context, params *PostDevicesParams, body PostDevicesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDevicesResponse, error) {
	rsp, err := c.PostDevices(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDevicesResponse(rsp)
}

// DeleteDeviceWithResponse request returning *DeleteDeviceResponse
func (c *ClientWithResponses) DeleteDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error) {
	rsp, err := c.DeleteDevice(ctx, deviceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceResponse(rsp)
}

// GetDeviceWithResponse request returning *GetDeviceResponse
func (c *ClientWithResponses) GetDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *GetDeviceParams, reqEditors ...RequestEditorFn) (*GetDeviceResponse, error) {
	rsp, err := c.GetDevice(ctx, deviceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceResponse(rsp)
}

// PatchDeviceWithBodyWithResponse request with arbitrary body returning *PatchDeviceResponse
func (c *ClientWithResponses) PatchDeviceWithBodyWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error) {
	rsp, err := c.PatchDeviceWithBody(ctx, deviceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDeviceResponse(rsp)
}

func (c *ClientWithResponses) PatchDeviceWithResponse(ctx context.Context, deviceID DeviceID, params *PatchDeviceParams, body PatchDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDeviceResponse, error) {
	rsp, err := c.PatchDevice(ctx, deviceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDeviceResponse(rsp)
}

// ListEndpointConfigurationsWithResponse request returning *ListEndpointConfigurationsResponse
func (c *ClientWithResponses) ListEndpointConfigurationsWithResponse(ctx context.Context, params *ListEndpointConfigurationsParams, reqEditors ...RequestEditorFn) (*ListEndpointConfigurationsResponse, error) {
	rsp, err := c.ListEndpointConfigurations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEndpointConfigurationsResponse(rsp)
}

// PostEndpointConfigurationsWithBodyWithResponse request with arbitrary body returning *PostEndpointConfigurationsResponse
func (c *ClientWithResponses) PostEndpointConfigurationsWithBodyWithResponse(ctx context.Context, params *PostEndpointConfigurationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEndpointConfigurationsResponse, error) {
	rsp, err := c.PostEndpointConfigurationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEndpointConfigurationsResponse(rsp)
}

func (c *ClientWithResponses) PostEndpointConfigurationsWithResponse(ctx context.Context, params *PostEndpointConfigurationsParams, body PostEndpointConfigurationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEndpointConfigurationsResponse, error) {
	rsp, err := c.PostEndpointConfigurations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEndpointConfigurationsResponse(rsp)
}

// DeleteEndpointConfigurationWithResponse request returning *DeleteEndpointConfigurationResponse
func (c *ClientWithResponses) DeleteEndpointConfigurationWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *DeleteEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*DeleteEndpointConfigurationResponse, error) {
	rsp, err := c.DeleteEndpointConfiguration(ctx, endpointConfigurationID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEndpointConfigurationResponse(rsp)
}

// GetEndpointConfigurationWithResponse request returning *GetEndpointConfigurationResponse
func (c *ClientWithResponses) GetEndpointConfigurationWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *GetEndpointConfigurationParams, reqEditors ...RequestEditorFn) (*GetEndpointConfigurationResponse, error) {
	rsp, err := c.GetEndpointConfiguration(ctx, endpointConfigurationID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEndpointConfigurationResponse(rsp)
}

// PutEndpointConfigurationWithBodyWithResponse request with arbitrary body returning *PutEndpointConfigurationResponse
func (c *ClientWithResponses) PutEndpointConfigurationWithBodyWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEndpointConfigurationResponse, error) {
	rsp, err := c.PutEndpointConfigurationWithBody(ctx, endpointConfigurationID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEndpointConfigurationResponse(rsp)
}

func (c *ClientWithResponses) PutEndpointConfigurationWithResponse(ctx context.Context, endpointConfigurationID EndpointConfigurationID, params *PutEndpointConfigurationParams, body PutEndpointConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEndpointConfigurationResponse, error) {
	rsp, err := c.PutEndpointConfiguration(ctx, endpointConfigurationID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEndpointConfigurationResponse(rsp)
}

// ListManagedRadiusWithResponse request returning *ListManagedRadiusResponse
func (c *ClientWithResponses) ListManagedRadiusWithResponse(ctx context.Context, params *ListManagedRadiusParams, reqEditors ...RequestEditorFn) (*ListManagedRadiusResponse, error) {
	rsp, err := c.ListManagedRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListManagedRadiusResponse(rsp)
}

// PostManagedRadiusWithBodyWithResponse request with arbitrary body returning *PostManagedRadiusResponse
func (c *ClientWithResponses) PostManagedRadiusWithBodyWithResponse(ctx context.Context, params *PostManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostManagedRadiusResponse, error) {
	rsp, err := c.PostManagedRadiusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostManagedRadiusResponse(rsp)
}

func (c *ClientWithResponses) PostManagedRadiusWithResponse(ctx context.Context, params *PostManagedRadiusParams, body PostManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostManagedRadiusResponse, error) {
	rsp, err := c.PostManagedRadius(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostManagedRadiusResponse(rsp)
}

// DeleteManagedRadiusWithResponse request returning *DeleteManagedRadiusResponse
func (c *ClientWithResponses) DeleteManagedRadiusWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *DeleteManagedRadiusParams, reqEditors ...RequestEditorFn) (*DeleteManagedRadiusResponse, error) {
	rsp, err := c.DeleteManagedRadius(ctx, managedRadiusID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManagedRadiusResponse(rsp)
}

// GetManagedRadiusWithResponse request returning *GetManagedRadiusResponse
func (c *ClientWithResponses) GetManagedRadiusWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *GetManagedRadiusParams, reqEditors ...RequestEditorFn) (*GetManagedRadiusResponse, error) {
	rsp, err := c.GetManagedRadius(ctx, managedRadiusID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManagedRadiusResponse(rsp)
}

// PutManagedRadiusWithBodyWithResponse request with arbitrary body returning *PutManagedRadiusResponse
func (c *ClientWithResponses) PutManagedRadiusWithBodyWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutManagedRadiusResponse, error) {
	rsp, err := c.PutManagedRadiusWithBody(ctx, managedRadiusID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutManagedRadiusResponse(rsp)
}

func (c *ClientWithResponses) PutManagedRadiusWithResponse(ctx context.Context, managedRadiusID ManagedRadiusID, params *PutManagedRadiusParams, body PutManagedRadiusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutManagedRadiusResponse, error) {
	rsp, err := c.PutManagedRadius(ctx, managedRadiusID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutManagedRadiusResponse(rsp)
}

// GetPlatformsWithResponse request returning *GetPlatformsResponse
func (c *ClientWithResponses) GetPlatformsWithResponse(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*GetPlatformsResponse, error) {
	rsp, err := c.GetPlatforms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformsResponse(rsp)
}

// PutPlatformWithBodyWithResponse request with arbitrary body returning *PutPlatformResponse
func (c *ClientWithResponses) PutPlatformWithBodyWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error) {
	rsp, err := c.PutPlatformWithBody(ctx, platformSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlatformResponse(rsp)
}

func (c *ClientWithResponses) PutPlatformWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error) {
	rsp, err := c.PutPlatform(ctx, platformSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlatformResponse(rsp)
}

// ListBrowserWithResponse request returning *ListBrowserResponse
func (c *ClientWithResponses) ListBrowserWithResponse(ctx context.Context, params *ListBrowserParams, reqEditors ...RequestEditorFn) (*ListBrowserResponse, error) {
	rsp, err := c.ListBrowser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBrowserResponse(rsp)
}

// PostBrowserWithBodyWithResponse request with arbitrary body returning *PostBrowserResponse
func (c *ClientWithResponses) PostBrowserWithBodyWithResponse(ctx context.Context, params *PostBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBrowserResponse, error) {
	rsp, err := c.PostBrowserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBrowserResponse(rsp)
}

func (c *ClientWithResponses) PostBrowserWithResponse(ctx context.Context, params *PostBrowserParams, body PostBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBrowserResponse, error) {
	rsp, err := c.PostBrowser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBrowserResponse(rsp)
}

// DeleteBrowserWithResponse request returning *DeleteBrowserResponse
func (c *ClientWithResponses) DeleteBrowserWithResponse(ctx context.Context, browserID BrowserID, params *DeleteBrowserParams, reqEditors ...RequestEditorFn) (*DeleteBrowserResponse, error) {
	rsp, err := c.DeleteBrowser(ctx, browserID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBrowserResponse(rsp)
}

// GetBrowserWithResponse request returning *GetBrowserResponse
func (c *ClientWithResponses) GetBrowserWithResponse(ctx context.Context, browserID BrowserID, params *GetBrowserParams, reqEditors ...RequestEditorFn) (*GetBrowserResponse, error) {
	rsp, err := c.GetBrowser(ctx, browserID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrowserResponse(rsp)
}

// PutBrowserWithBodyWithResponse request with arbitrary body returning *PutBrowserResponse
func (c *ClientWithResponses) PutBrowserWithBodyWithResponse(ctx context.Context, browserID BrowserID, params *PutBrowserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutBrowserResponse, error) {
	rsp, err := c.PutBrowserWithBody(ctx, browserID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBrowserResponse(rsp)
}

func (c *ClientWithResponses) PutBrowserWithResponse(ctx context.Context, browserID BrowserID, params *PutBrowserParams, body PutBrowserJSONRequestBody, reqEditors ...RequestEditorFn) (*PutBrowserResponse, error) {
	rsp, err := c.PutBrowser(ctx, browserID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutBrowserResponse(rsp)
}

// ListEthernetWithResponse request returning *ListEthernetResponse
func (c *ClientWithResponses) ListEthernetWithResponse(ctx context.Context, params *ListEthernetParams, reqEditors ...RequestEditorFn) (*ListEthernetResponse, error) {
	rsp, err := c.ListEthernet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEthernetResponse(rsp)
}

// PostEthernetWithBodyWithResponse request with arbitrary body returning *PostEthernetResponse
func (c *ClientWithResponses) PostEthernetWithBodyWithResponse(ctx context.Context, params *PostEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEthernetResponse, error) {
	rsp, err := c.PostEthernetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEthernetResponse(rsp)
}

func (c *ClientWithResponses) PostEthernetWithResponse(ctx context.Context, params *PostEthernetParams, body PostEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEthernetResponse, error) {
	rsp, err := c.PostEthernet(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEthernetResponse(rsp)
}

// DeleteEthernetWithResponse request returning *DeleteEthernetResponse
func (c *ClientWithResponses) DeleteEthernetWithResponse(ctx context.Context, ethernetID EthernetID, params *DeleteEthernetParams, reqEditors ...RequestEditorFn) (*DeleteEthernetResponse, error) {
	rsp, err := c.DeleteEthernet(ctx, ethernetID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEthernetResponse(rsp)
}

// GetEthernetWithResponse request returning *GetEthernetResponse
func (c *ClientWithResponses) GetEthernetWithResponse(ctx context.Context, ethernetID EthernetID, params *GetEthernetParams, reqEditors ...RequestEditorFn) (*GetEthernetResponse, error) {
	rsp, err := c.GetEthernet(ctx, ethernetID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEthernetResponse(rsp)
}

// PutEthernetWithBodyWithResponse request with arbitrary body returning *PutEthernetResponse
func (c *ClientWithResponses) PutEthernetWithBodyWithResponse(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEthernetResponse, error) {
	rsp, err := c.PutEthernetWithBody(ctx, ethernetID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEthernetResponse(rsp)
}

func (c *ClientWithResponses) PutEthernetWithResponse(ctx context.Context, ethernetID EthernetID, params *PutEthernetParams, body PutEthernetJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEthernetResponse, error) {
	rsp, err := c.PutEthernet(ctx, ethernetID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEthernetResponse(rsp)
}

// ListVpnWithResponse request returning *ListVpnResponse
func (c *ClientWithResponses) ListVpnWithResponse(ctx context.Context, params *ListVpnParams, reqEditors ...RequestEditorFn) (*ListVpnResponse, error) {
	rsp, err := c.ListVpn(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVpnResponse(rsp)
}

// PostVpnWithBodyWithResponse request with arbitrary body returning *PostVpnResponse
func (c *ClientWithResponses) PostVpnWithBodyWithResponse(ctx context.Context, params *PostVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVpnResponse, error) {
	rsp, err := c.PostVpnWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVpnResponse(rsp)
}

func (c *ClientWithResponses) PostVpnWithResponse(ctx context.Context, params *PostVpnParams, body PostVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVpnResponse, error) {
	rsp, err := c.PostVpn(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVpnResponse(rsp)
}

// DeleteVpnWithResponse request returning *DeleteVpnResponse
func (c *ClientWithResponses) DeleteVpnWithResponse(ctx context.Context, vpnID VpnID, params *DeleteVpnParams, reqEditors ...RequestEditorFn) (*DeleteVpnResponse, error) {
	rsp, err := c.DeleteVpn(ctx, vpnID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnResponse(rsp)
}

// GetVpnWithResponse request returning *GetVpnResponse
func (c *ClientWithResponses) GetVpnWithResponse(ctx context.Context, vpnID VpnID, params *GetVpnParams, reqEditors ...RequestEditorFn) (*GetVpnResponse, error) {
	rsp, err := c.GetVpn(ctx, vpnID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVpnResponse(rsp)
}

// PutVpnWithBodyWithResponse request with arbitrary body returning *PutVpnResponse
func (c *ClientWithResponses) PutVpnWithBodyWithResponse(ctx context.Context, vpnID VpnID, params *PutVpnParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVpnResponse, error) {
	rsp, err := c.PutVpnWithBody(ctx, vpnID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVpnResponse(rsp)
}

func (c *ClientWithResponses) PutVpnWithResponse(ctx context.Context, vpnID VpnID, params *PutVpnParams, body PutVpnJSONRequestBody, reqEditors ...RequestEditorFn) (*PutVpnResponse, error) {
	rsp, err := c.PutVpn(ctx, vpnID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVpnResponse(rsp)
}

// ListWifiWithResponse request returning *ListWifiResponse
func (c *ClientWithResponses) ListWifiWithResponse(ctx context.Context, params *ListWifiParams, reqEditors ...RequestEditorFn) (*ListWifiResponse, error) {
	rsp, err := c.ListWifi(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWifiResponse(rsp)
}

// PostWifiWithBodyWithResponse request with arbitrary body returning *PostWifiResponse
func (c *ClientWithResponses) PostWifiWithBodyWithResponse(ctx context.Context, params *PostWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWifiResponse, error) {
	rsp, err := c.PostWifiWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWifiResponse(rsp)
}

func (c *ClientWithResponses) PostWifiWithResponse(ctx context.Context, params *PostWifiParams, body PostWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWifiResponse, error) {
	rsp, err := c.PostWifi(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWifiResponse(rsp)
}

// DeleteWifiWithResponse request returning *DeleteWifiResponse
func (c *ClientWithResponses) DeleteWifiWithResponse(ctx context.Context, wifiID WifiID, params *DeleteWifiParams, reqEditors ...RequestEditorFn) (*DeleteWifiResponse, error) {
	rsp, err := c.DeleteWifi(ctx, wifiID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWifiResponse(rsp)
}

// GetWifiWithResponse request returning *GetWifiResponse
func (c *ClientWithResponses) GetWifiWithResponse(ctx context.Context, wifiID WifiID, params *GetWifiParams, reqEditors ...RequestEditorFn) (*GetWifiResponse, error) {
	rsp, err := c.GetWifi(ctx, wifiID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWifiResponse(rsp)
}

// PutWifiWithBodyWithResponse request with arbitrary body returning *PutWifiResponse
func (c *ClientWithResponses) PutWifiWithBodyWithResponse(ctx context.Context, wifiID WifiID, params *PutWifiParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWifiResponse, error) {
	rsp, err := c.PutWifiWithBody(ctx, wifiID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWifiResponse(rsp)
}

func (c *ClientWithResponses) PutWifiWithResponse(ctx context.Context, wifiID WifiID, params *PutWifiParams, body PutWifiJSONRequestBody, reqEditors ...RequestEditorFn) (*PutWifiResponse, error) {
	rsp, err := c.PutWifi(ctx, wifiID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWifiResponse(rsp)
}

// DeleteIdentityProviderWithResponse request returning *DeleteIdentityProviderResponse
func (c *ClientWithResponses) DeleteIdentityProviderWithResponse(ctx context.Context, params *DeleteIdentityProviderParams, reqEditors ...RequestEditorFn) (*DeleteIdentityProviderResponse, error) {
	rsp, err := c.DeleteIdentityProvider(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIdentityProviderResponse(rsp)
}

// GetIdentityProviderWithResponse request returning *GetIdentityProviderResponse
func (c *ClientWithResponses) GetIdentityProviderWithResponse(ctx context.Context, params *GetIdentityProviderParams, reqEditors ...RequestEditorFn) (*GetIdentityProviderResponse, error) {
	rsp, err := c.GetIdentityProvider(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityProviderResponse(rsp)
}

// PutIdentityProviderWithBodyWithResponse request with arbitrary body returning *PutIdentityProviderResponse
func (c *ClientWithResponses) PutIdentityProviderWithBodyWithResponse(ctx context.Context, params *PutIdentityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutIdentityProviderResponse, error) {
	rsp, err := c.PutIdentityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutIdentityProviderResponse(rsp)
}

func (c *ClientWithResponses) PutIdentityProviderWithResponse(ctx context.Context, params *PutIdentityProviderParams, body PutIdentityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*PutIdentityProviderResponse, error) {
	rsp, err := c.PutIdentityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutIdentityProviderResponse(rsp)
}

// ListIdpClientsWithResponse request returning *ListIdpClientsResponse
func (c *ClientWithResponses) ListIdpClientsWithResponse(ctx context.Context, params *ListIdpClientsParams, reqEditors ...RequestEditorFn) (*ListIdpClientsResponse, error) {
	rsp, err := c.ListIdpClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIdpClientsResponse(rsp)
}

// PostIdpClientsWithBodyWithResponse request with arbitrary body returning *PostIdpClientsResponse
func (c *ClientWithResponses) PostIdpClientsWithBodyWithResponse(ctx context.Context, params *PostIdpClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIdpClientsResponse, error) {
	rsp, err := c.PostIdpClientsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIdpClientsResponse(rsp)
}

func (c *ClientWithResponses) PostIdpClientsWithResponse(ctx context.Context, params *PostIdpClientsParams, body PostIdpClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIdpClientsResponse, error) {
	rsp, err := c.PostIdpClients(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIdpClientsResponse(rsp)
}

// DeleteIdpClientWithResponse request returning *DeleteIdpClientResponse
func (c *ClientWithResponses) DeleteIdpClientWithResponse(ctx context.Context, idpClientID IdpClientID, params *DeleteIdpClientParams, reqEditors ...RequestEditorFn) (*DeleteIdpClientResponse, error) {
	rsp, err := c.DeleteIdpClient(ctx, idpClientID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIdpClientResponse(rsp)
}

// GetIdpClientWithResponse request returning *GetIdpClientResponse
func (c *ClientWithResponses) GetIdpClientWithResponse(ctx context.Context, idpClientID IdpClientID, params *GetIdpClientParams, reqEditors ...RequestEditorFn) (*GetIdpClientResponse, error) {
	rsp, err := c.GetIdpClient(ctx, idpClientID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdpClientResponse(rsp)
}

// ParseListAccountsResponse parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResponse(rsp *http.Response) (*ListAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAccountsResponse parses an HTTP response from a PostAccountsWithResponse call
func ParsePostAccountsResponse(rsp *http.Response) (*PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAccountResponse parses an HTTP response from a DeleteAccountWithResponse call
func ParseDeleteAccountResponse(rsp *http.Response) (*DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccountResponse parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResponse(rsp *http.Response) (*GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutAccountResponse parses an HTTP response from a PutAccountWithResponse call
func ParsePutAccountResponse(rsp *http.Response) (*PutAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthResponse parses an HTTP response from a PostAuthWithResponse call
func ParsePostAuthResponse(rsp *http.Response) (*PostAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthoritiesResponse parses an HTTP response from a GetAuthoritiesWithResponse call
func ParseGetAuthoritiesResponse(rsp *http.Response) (*GetAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesResponse parses an HTTP response from a PostAuthoritiesWithResponse call
func ParsePostAuthoritiesResponse(rsp *http.Response) (*PostAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesCsrResponse parses an HTTP response from a PostAuthoritiesCsrWithResponse call
func ParsePostAuthoritiesCsrResponse(rsp *http.Response) (*PostAuthoritiesCsrResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesCsrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthorityCsr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorityResponse parses an HTTP response from a DeleteAuthorityWithResponse call
func ParseDeleteAuthorityResponse(rsp *http.Response) (*DeleteAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthorityResponse parses an HTTP response from a GetAuthorityWithResponse call
func ParseGetAuthorityResponse(rsp *http.Response) (*GetAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuthorityProvisionersResponse parses an HTTP response from a ListAuthorityProvisionersWithResponse call
func ParseListAuthorityProvisionersResponse(rsp *http.Response) (*ListAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityProvisionersResponse parses an HTTP response from a PostAuthorityProvisionersWithResponse call
func ParsePostAuthorityProvisionersResponse(rsp *http.Response) (*PostAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProvisionerResponse parses an HTTP response from a DeleteProvisionerWithResponse call
func ParseDeleteProvisionerResponse(rsp *http.Response) (*DeleteProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProvisionerResponse parses an HTTP response from a GetProvisionerWithResponse call
func ParseGetProvisionerResponse(rsp *http.Response) (*GetProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWebhooksResponse parses an HTTP response from a PostWebhooksWithResponse call
func ParsePostWebhooksResponse(rsp *http.Response) (*PostWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProvisionerWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProvisionerWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityRootResponse parses an HTTP response from a PostAuthorityRootWithResponse call
func ParsePostAuthorityRootResponse(rsp *http.Response) (*PostAuthorityRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCertificatesResponse parses an HTTP response from a ListCertificatesWithResponse call
func ParseListCertificatesResponse(rsp *http.Response) (*ListCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []X509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateResponse parses an HTTP response from a GetCertificateWithResponse call
func ParseGetCertificateResponse(rsp *http.Response) (*GetCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest X509Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCredentialResponse parses an HTTP response from a DeleteCredentialWithResponse call
func ParseDeleteCredentialResponse(rsp *http.Response) (*DeleteCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredentialResponse parses an HTTP response from a GetCredentialWithResponse call
func ParseGetCredentialResponse(rsp *http.Response) (*GetCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutCredentialResponse parses an HTTP response from a PutCredentialWithResponse call
func ParsePutCredentialResponse(rsp *http.Response) (*PutCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCredentialsResponse parses an HTTP response from a PostCredentialsWithResponse call
func ParsePostCredentialsResponse(rsp *http.Response) (*PostCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDevicesResponse parses an HTTP response from a ListDevicesWithResponse call
func ParseListDevicesResponse(rsp *http.Response) (*ListDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDevicesResponse parses an HTTP response from a PostDevicesWithResponse call
func ParsePostDevicesResponse(rsp *http.Response) (*PostDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDeviceResponse parses an HTTP response from a DeleteDeviceWithResponse call
func ParseDeleteDeviceResponse(rsp *http.Response) (*DeleteDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDeviceResponse parses an HTTP response from a GetDeviceWithResponse call
func ParseGetDeviceResponse(rsp *http.Response) (*GetDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchDeviceResponse parses an HTTP response from a PatchDeviceWithResponse call
func ParsePatchDeviceResponse(rsp *http.Response) (*PatchDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Device
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEndpointConfigurationsResponse parses an HTTP response from a ListEndpointConfigurationsWithResponse call
func ParseListEndpointConfigurationsResponse(rsp *http.Response) (*ListEndpointConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEndpointConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostEndpointConfigurationsResponse parses an HTTP response from a PostEndpointConfigurationsWithResponse call
func ParsePostEndpointConfigurationsResponse(rsp *http.Response) (*PostEndpointConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEndpointConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndpointConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEndpointConfigurationResponse parses an HTTP response from a DeleteEndpointConfigurationWithResponse call
func ParseDeleteEndpointConfigurationResponse(rsp *http.Response) (*DeleteEndpointConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEndpointConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEndpointConfigurationResponse parses an HTTP response from a GetEndpointConfigurationWithResponse call
func ParseGetEndpointConfigurationResponse(rsp *http.Response) (*GetEndpointConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEndpointConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutEndpointConfigurationResponse parses an HTTP response from a PutEndpointConfigurationWithResponse call
func ParsePutEndpointConfigurationResponse(rsp *http.Response) (*PutEndpointConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutEndpointConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListManagedRadiusResponse parses an HTTP response from a ListManagedRadiusWithResponse call
func ParseListManagedRadiusResponse(rsp *http.Response) (*ListManagedRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListManagedRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ManagedRadius
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostManagedRadiusResponse parses an HTTP response from a PostManagedRadiusWithResponse call
func ParsePostManagedRadiusResponse(rsp *http.Response) (*PostManagedRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostManagedRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedRadius
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteManagedRadiusResponse parses an HTTP response from a DeleteManagedRadiusWithResponse call
func ParseDeleteManagedRadiusResponse(rsp *http.Response) (*DeleteManagedRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManagedRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetManagedRadiusResponse parses an HTTP response from a GetManagedRadiusWithResponse call
func ParseGetManagedRadiusResponse(rsp *http.Response) (*GetManagedRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManagedRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedRadius
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutManagedRadiusResponse parses an HTTP response from a PutManagedRadiusWithResponse call
func ParsePutManagedRadiusResponse(rsp *http.Response) (*PutManagedRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutManagedRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedRadius
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformsResponse parses an HTTP response from a GetPlatformsWithResponse call
func ParseGetPlatformsResponse(rsp *http.Response) (*GetPlatformsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Platform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutPlatformResponse parses an HTTP response from a PutPlatformWithResponse call
func ParsePutPlatformResponse(rsp *http.Response) (*PutPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Platform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBrowserResponse parses an HTTP response from a ListBrowserWithResponse call
func ParseListBrowserResponse(rsp *http.Response) (*ListBrowserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBrowserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Browser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBrowserResponse parses an HTTP response from a PostBrowserWithResponse call
func ParsePostBrowserResponse(rsp *http.Response) (*PostBrowserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBrowserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Browser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBrowserResponse parses an HTTP response from a DeleteBrowserWithResponse call
func ParseDeleteBrowserResponse(rsp *http.Response) (*DeleteBrowserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBrowserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBrowserResponse parses an HTTP response from a GetBrowserWithResponse call
func ParseGetBrowserResponse(rsp *http.Response) (*GetBrowserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrowserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Browser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutBrowserResponse parses an HTTP response from a PutBrowserWithResponse call
func ParsePutBrowserResponse(rsp *http.Response) (*PutBrowserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutBrowserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Browser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEthernetResponse parses an HTTP response from a ListEthernetWithResponse call
func ParseListEthernetResponse(rsp *http.Response) (*ListEthernetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEthernetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Ethernet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostEthernetResponse parses an HTTP response from a PostEthernetWithResponse call
func ParsePostEthernetResponse(rsp *http.Response) (*PostEthernetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEthernetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ethernet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEthernetResponse parses an HTTP response from a DeleteEthernetWithResponse call
func ParseDeleteEthernetResponse(rsp *http.Response) (*DeleteEthernetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEthernetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEthernetResponse parses an HTTP response from a GetEthernetWithResponse call
func ParseGetEthernetResponse(rsp *http.Response) (*GetEthernetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEthernetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ethernet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutEthernetResponse parses an HTTP response from a PutEthernetWithResponse call
func ParsePutEthernetResponse(rsp *http.Response) (*PutEthernetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutEthernetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ethernet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListVpnResponse parses an HTTP response from a ListVpnWithResponse call
func ParseListVpnResponse(rsp *http.Response) (*ListVpnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVpnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Vpn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostVpnResponse parses an HTTP response from a PostVpnWithResponse call
func ParsePostVpnResponse(rsp *http.Response) (*PostVpnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVpnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Vpn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpnResponse parses an HTTP response from a DeleteVpnWithResponse call
func ParseDeleteVpnResponse(rsp *http.Response) (*DeleteVpnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVpnResponse parses an HTTP response from a GetVpnWithResponse call
func ParseGetVpnResponse(rsp *http.Response) (*GetVpnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVpnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vpn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutVpnResponse parses an HTTP response from a PutVpnWithResponse call
func ParsePutVpnResponse(rsp *http.Response) (*PutVpnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutVpnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vpn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListWifiResponse parses an HTTP response from a ListWifiWithResponse call
func ParseListWifiResponse(rsp *http.Response) (*ListWifiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWifiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Wifi
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWifiResponse parses an HTTP response from a PostWifiWithResponse call
func ParsePostWifiResponse(rsp *http.Response) (*PostWifiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWifiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Wifi
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWifiResponse parses an HTTP response from a DeleteWifiWithResponse call
func ParseDeleteWifiResponse(rsp *http.Response) (*DeleteWifiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWifiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWifiResponse parses an HTTP response from a GetWifiWithResponse call
func ParseGetWifiResponse(rsp *http.Response) (*GetWifiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWifiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Wifi
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutWifiResponse parses an HTTP response from a PutWifiWithResponse call
func ParsePutWifiResponse(rsp *http.Response) (*PutWifiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWifiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Wifi
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIdentityProviderResponse parses an HTTP response from a DeleteIdentityProviderWithResponse call
func ParseDeleteIdentityProviderResponse(rsp *http.Response) (*DeleteIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIdentityProviderResponse parses an HTTP response from a GetIdentityProviderWithResponse call
func ParseGetIdentityProviderResponse(rsp *http.Response) (*GetIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutIdentityProviderResponse parses an HTTP response from a PutIdentityProviderWithResponse call
func ParsePutIdentityProviderResponse(rsp *http.Response) (*PutIdentityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutIdentityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIdpClientsResponse parses an HTTP response from a ListIdpClientsWithResponse call
func ParseListIdpClientsResponse(rsp *http.Response) (*ListIdpClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIdpClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostIdpClientsResponse parses an HTTP response from a PostIdpClientsWithResponse call
func ParsePostIdpClientsResponse(rsp *http.Response) (*PostIdpClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostIdpClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest N422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIdpClientResponse parses an HTTP response from a DeleteIdpClientWithResponse call
func ParseDeleteIdpClientResponse(rsp *http.Response) (*DeleteIdpClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIdpClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIdpClientResponse parses an HTTP response from a GetIdpClientWithResponse call
func ParseGetIdpClientResponse(rsp *http.Response) (*GetIdpClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdpClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"LHXbEjvvPt39/wEAAP//c8Q2BVMWAgA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
