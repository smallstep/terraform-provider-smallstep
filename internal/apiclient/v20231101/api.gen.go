// Package v20231101 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20231101

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AcmeAttestationProvisionerAttestationFormats.
const (
	AcmeAttestationProvisionerAttestationFormatsApple AcmeAttestationProvisionerAttestationFormats = "apple"
	AcmeAttestationProvisionerAttestationFormatsStep  AcmeAttestationProvisionerAttestationFormats = "step"
	AcmeAttestationProvisionerAttestationFormatsTpm   AcmeAttestationProvisionerAttestationFormats = "tpm"
)

// Defines values for AcmeProvisionerChallenges.
const (
	Dns01     AcmeProvisionerChallenges = "dns-01"
	Http01    AcmeProvisionerChallenges = "http-01"
	TlsAlpn01 AcmeProvisionerChallenges = "tls-alpn-01"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
	AuthorityTypeManaged  AuthorityType = "managed"
)

// Defines values for DeviceCollectionDeviceType.
const (
	DeviceCollectionDeviceTypeAwsVm   DeviceCollectionDeviceType = "aws-vm"
	DeviceCollectionDeviceTypeAzureVm DeviceCollectionDeviceType = "azure-vm"
	DeviceCollectionDeviceTypeGcpVm   DeviceCollectionDeviceType = "gcp-vm"
	DeviceCollectionDeviceTypeTpm     DeviceCollectionDeviceType = "tpm"
)

// Defines values for EndpointCertificateInfoType.
const (
	EndpointCertificateInfoTypeSSHHOST EndpointCertificateInfoType = "SSH_HOST"
	EndpointCertificateInfoTypeSSHUSER EndpointCertificateInfoType = "SSH_USER"
	EndpointCertificateInfoTypeX509    EndpointCertificateInfoType = "X509"
)

// Defines values for EndpointKeyInfoFormat.
const (
	EndpointKeyInfoFormatCLASSIC EndpointKeyInfoFormat = "CLASSIC"
	EndpointKeyInfoFormatDEFAULT EndpointKeyInfoFormat = "DEFAULT"
	EndpointKeyInfoFormatOPENSSH EndpointKeyInfoFormat = "OPENSSH"
	EndpointKeyInfoFormatPKCS8   EndpointKeyInfoFormat = "PKCS8"
	EndpointKeyInfoFormatTSS2    EndpointKeyInfoFormat = "TSS2"
)

// Defines values for EndpointKeyInfoProtection.
const (
	EndpointKeyInfoProtectionDEFAULT              EndpointKeyInfoProtection = "DEFAULT"
	EndpointKeyInfoProtectionHARDWARE             EndpointKeyInfoProtection = "HARDWARE"
	EndpointKeyInfoProtectionHARDWAREATTESTED     EndpointKeyInfoProtection = "HARDWARE_ATTESTED"
	EndpointKeyInfoProtectionHARDWAREWITHFALLBACK EndpointKeyInfoProtection = "HARDWARE_WITH_FALLBACK"
	EndpointKeyInfoProtectionNONE                 EndpointKeyInfoProtection = "NONE"
)

// Defines values for EndpointKeyInfoType.
const (
	DEFAULT   EndpointKeyInfoType = "DEFAULT"
	ECDSAP256 EndpointKeyInfoType = "ECDSA_P256"
	ECDSAP384 EndpointKeyInfoType = "ECDSA_P384"
	ECDSAP521 EndpointKeyInfoType = "ECDSA_P521"
	ED25519   EndpointKeyInfoType = "ED25519"
	RSA2048   EndpointKeyInfoType = "RSA_2048"
	RSA3072   EndpointKeyInfoType = "RSA_3072"
	RSA4096   EndpointKeyInfoType = "RSA_4096"
)

// Defines values for EndpointReloadInfoMethod.
const (
	AUTOMATIC EndpointReloadInfoMethod = "AUTOMATIC"
	CUSTOM    EndpointReloadInfoMethod = "CUSTOM"
	DBUS      EndpointReloadInfoMethod = "DBUS"
	SIGNAL    EndpointReloadInfoMethod = "SIGNAL"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for NewPlatformPlatformType.
const (
	NewPlatformPlatformTypeAws   NewPlatformPlatformType = "aws"
	NewPlatformPlatformTypeAzure NewPlatformPlatformType = "azure"
	NewPlatformPlatformTypeGcp   NewPlatformPlatformType = "gcp"
)

// Defines values for PlatformPlatformType.
const (
	PlatformPlatformTypeAws   PlatformPlatformType = "aws"
	PlatformPlatformTypeAzure PlatformPlatformType = "azure"
	PlatformPlatformTypeGcp   PlatformPlatformType = "gcp"
)

// Defines values for ProvisionerType.
const (
	ACME            ProvisionerType = "ACME"
	ACMEATTESTATION ProvisionerType = "ACME_ATTESTATION"
	AWS             ProvisionerType = "AWS"
	AZURE           ProvisionerType = "AZURE"
	GCP             ProvisionerType = "GCP"
	JWK             ProvisionerType = "JWK"
	OIDC            ProvisionerType = "OIDC"
	SCEP            ProvisionerType = "SCEP"
	X5C             ProvisionerType = "X5C"
)

// Defines values for ProvisionerWebhookCertType.
const (
	ProvisionerWebhookCertTypeALL  ProvisionerWebhookCertType = "ALL"
	ProvisionerWebhookCertTypeSSH  ProvisionerWebhookCertType = "SSH"
	ProvisionerWebhookCertTypeX509 ProvisionerWebhookCertType = "X509"
)

// Defines values for ProvisionerWebhookKind.
const (
	ENRICHING ProvisionerWebhookKind = "ENRICHING"
)

// Defines values for ProvisionerWebhookServerType.
const (
	EXTERNAL          ProvisionerWebhookServerType = "EXTERNAL"
	HOSTEDATTESTATION ProvisionerWebhookServerType = "HOSTED_ATTESTATION"
)

// Defines values for ScepProvisionerEncryptionAlgorithmIdentifier.
const (
	AES128CBC ScepProvisionerEncryptionAlgorithmIdentifier = "AES_128_CBC"
	AES128GCM ScepProvisionerEncryptionAlgorithmIdentifier = "AES_128_GCM"
	AES256CBC ScepProvisionerEncryptionAlgorithmIdentifier = "AES_256_CBC"
	AES256GCM ScepProvisionerEncryptionAlgorithmIdentifier = "AES_256_GCM"
	DESCBC    ScepProvisionerEncryptionAlgorithmIdentifier = "DES_CBC"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// AcmeAttestationProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [device-attest-01 challenge of the ACME protocol](https://smallstep.com/blog/acme-managed-device-attestation-explained/).
type AcmeAttestationProvisioner struct {
	// AttestationFormats The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default.
	AttestationFormats []AcmeAttestationProvisionerAttestationFormats `json:"attestationFormats"`

	// AttestationRoots A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
	AttestationRoots *[]string `json:"attestationRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// AcmeAttestationProvisionerAttestationFormats defines model for AcmeAttestationProvisioner.AttestationFormats.
type AcmeAttestationProvisionerAttestationFormats string

// AcmeProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [ACME protocol](https://smallstep.com/docs/step-ca/acme-basics/#acme-challenges).
type AcmeProvisioner struct {
	// Challenges Which ACME challenge types are allowed.
	Challenges []AcmeProvisionerChallenges `json:"challenges"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
	RequireEAB bool `json:"requireEAB"`
}

// AcmeProvisionerChallenges defines model for AcmeProvisioner.Challenges.
type AcmeProvisionerChallenges string

// AttestationAuthority An attestation authority used with the device-attest-01 ACME challenge to verify a device's hardware identity. This object is experimental and subject to change.
type AttestationAuthority struct {
	// AttestorIntermediates The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by devices.
	AttestorIntermediates *string `json:"attestorIntermediates,omitempty"`

	// AttestorRoots The pem-encoded list of certificates used to verify the attestation certificates submitted by devices.
	AttestorRoots string `json:"attestorRoots"`

	// CreatedAt Timestamp in RFC3339 format when the attestation authority was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this attestation authority. Read only.
	Id *string `json:"id,omitempty"`

	// Name The name of the attestation authority.
	Name string `json:"name"`

	// Root The pem-encoded root certificate of this attestation authority. This is generated server-side when the attestation authority is created. This certificate should be used in the `attestationRoots` field of an ACME_ATTESTATION provisioner with the `tpm` format.
	Root *string `json:"root,omitempty"`

	// Slug A short name for this attestation authority. Read only.
	Slug *string `json:"slug,omitempty"`
}

// Authority An X509 authority hosted by Smallstep.
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only).
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created.
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached.
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority.
	Id string `json:"id"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Root The root certificate in pem format.
	Root *string `json:"root,omitempty"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root.
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority.
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format.
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR.
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// AwsAccounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
type AwsAccounts = []string

// AwsDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
type AwsDisableCustomSANs = bool

// AwsPlatform Configuration for an AWS platform.
type AwsPlatform struct {
	AccountId string `json:"accountId"`

	// Name A friendly name for this AWS account.
	Name string `json:"name"`

	// RoleArn A role ARN that allows the Smallstep Platform to manage resources on your behalf.
	RoleArn *string `json:"roleArn,omitempty"`
}

// AwsProvisioner The [AWS provisioner](https://smallstep.com/docs/step-ca/provisioners/#aws) grants a certificate to an Amazon EC2 instance using the Instance Identity Document.
type AwsProvisioner struct {
	// Accounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
	Accounts AwsAccounts `json:"accounts"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
	DisableCustomSANs *AwsDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`
}

// AwsVM Configuration for an AWS provisioner for a device collection of AWS VMs.
type AwsVM struct {
	// Accounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
	Accounts AwsAccounts `json:"accounts"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
	DisableCustomSANs *AwsDisableCustomSANs `json:"disableCustomSANs,omitempty"`
}

// AzureAudience Defaults to https://management.azure.com/ but it can be changed if necessary.
type AzureAudience = string

// AzureDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
type AzureDisableCustomSANs = bool

// AzurePlatform Microsoft Azure
type AzurePlatform struct {
	// ClientId The client ID of an Azure Service Principal that allows the Smallstep Platform to manage resources on your behalf.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecret The client secret of an Azure Service Principal that allows the Smallstep Platform to manage resources on your behalf.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Name A friendly name for this Azure connection
	Name string `json:"name"`

	// ResourceGroups A list of resource groups that are allowed to enroll with the Smallstep Platform.
	ResourceGroups []string `json:"resourceGroups"`

	// TenantId The Azure Entra tenant ID
	TenantId string `json:"tenantId"`
}

// AzureProvisioner The [Azure provisioner](https://smallstep.com/docs/step-ca/provisioners/#azure) grants certificates to Microsoft Azure instances using the managed identities tokens.
type AzureProvisioner struct {
	// Audience Defaults to https://management.azure.com/ but it can be changed if necessary.
	Audience *AzureAudience `json:"audience,omitempty"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
	DisableCustomSANs *AzureDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// ResourceGroups The list of resource group names that are allowed to use this provisioner.
	ResourceGroups AzureResourceGroups `json:"resourceGroups"`

	// TenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
	TenantID AzureTenantID `json:"tenantID"`
}

// AzureResourceGroups The list of resource group names that are allowed to use this provisioner.
type AzureResourceGroups = []string

// AzureTenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
type AzureTenantID = string

// AzureVM defines model for azureVM.
type AzureVM struct {
	// Audience Defaults to https://management.azure.com/ but it can be changed if necessary.
	Audience *AzureAudience `json:"audience,omitempty"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
	DisableCustomSANs *AzureDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// ResourceGroups The list of resource group names that are allowed to use this provisioner.
	ResourceGroups AzureResourceGroups `json:"resourceGroups"`

	// TenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
	TenantID AzureTenantID `json:"tenantID"`
}

// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
type BasicAuth struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// CertificateField A certificate field that takes a single string value, e.g. Common Name.
type CertificateField struct {
	union json.RawMessage
}

// CertificateFieldDeviceMetadata defines model for certificateFieldDeviceMetadata.
type CertificateFieldDeviceMetadata struct {
	DeviceMetadata string `json:"deviceMetadata"`
}

// CertificateFieldList A certificate field that accepts multiple string values, e.g. SANs.
type CertificateFieldList struct {
	// DeviceMetadata A value populated from a key in the device's metadata.
	DeviceMetadata *[]string `json:"deviceMetadata,omitempty"`

	// Static A literal value.
	Static *[]string `json:"static,omitempty"`
}

// CertificateFieldStatic defines model for certificateFieldStatic.
type CertificateFieldStatic struct {
	Static string `json:"static"`
}

// Collection A collection of instances.
type Collection struct {
	// CreatedAt Timestamp in RFC3339 format when the collections was created
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the collection.
	DisplayName string `json:"displayName"`

	// InstanceCount The number of instances in the collection.
	InstanceCount int `json:"instanceCount"`

	// SchemaURI Reference to a schema that all instances in the collection must conform to.
	SchemaURI *string `json:"schemaURI,omitempty"`

	// Slug A lowercase name identifying the collection.
	Slug string `json:"slug"`

	// UpdatedAt Timestamp in RFC3339 format when the collections was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// CollectionInstance An instance in a collection.
type CollectionInstance struct {
	// CreatedAt Timestamp in RFC3339 format when the instance was added to the collection.
	CreatedAt time.Time `json:"createdAt"`

	// Data The instance data.
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp in RFC3339 format when the instance was last changed.
	UpdatedAt time.Time `json:"updatedAt"`
}

// DeviceCollection Configuration to create a new device collection.
type DeviceCollection struct {
	// AdminEmails Users that will have admin access to manage the agents authority, which will be created if it does not already exist. Ignored if the agent authority already exists. Never returned in API responses.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// DeviceType Must match the deviceTypeConfiguration. Cannot be changed.
	DeviceType              DeviceCollectionDeviceType               `json:"deviceType"`
	DeviceTypeConfiguration DeviceCollection_DeviceTypeConfiguration `json:"deviceTypeConfiguration"`
	DisplayName             string                                   `json:"displayName"`
	Slug                    string                                   `json:"slug"`
}

// DeviceCollectionDeviceType Must match the deviceTypeConfiguration. Cannot be changed.
type DeviceCollectionDeviceType string

// DeviceCollection_DeviceTypeConfiguration defines model for DeviceCollection.DeviceTypeConfiguration.
type DeviceCollection_DeviceTypeConfiguration struct {
	union json.RawMessage
}

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizationalUnit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// EndpointCertificateInfo Details on a managed certificate.
type EndpointCertificateInfo struct {
	// CrtFile The filepath where the certificate is to be stored.
	CrtFile *string `json:"crtFile,omitempty"`

	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// Gid GID of the files where the certificate is stored.
	Gid *int `json:"gid,omitempty"`

	// KeyFile The filepath where the key is to be stored.
	KeyFile *string `json:"keyFile,omitempty"`

	// Mode Permission bits of the files where the certificate is stored.
	Mode *int `json:"mode,omitempty"`

	// RootFile The filepath where the root certificate is to be stored.
	RootFile *string `json:"rootFile,omitempty"`

	// Type The type of certificate.
	Type EndpointCertificateInfoType `json:"type"`

	// Uid UID of the files where the certificate is stored.
	Uid *int `json:"uid,omitempty"`
}

// EndpointCertificateInfoType The type of certificate.
type EndpointCertificateInfoType string

// EndpointHook A list of commands to run before and after a certificate is granted.
type EndpointHook struct {
	// After List of commands to run after the operation.
	After *[]string `json:"after,omitempty"`

	// Before List of commands to run before the operation.
	Before *[]string `json:"before,omitempty"`

	// OnError List of commands to run when the operation fails.
	OnError *[]string `json:"onError,omitempty"`

	// Shell The shell to use to execute the commands.
	Shell *string `json:"shell,omitempty"`
}

// EndpointHooks The collection of commands to run when a certificate for a managed endpoint is signed or renewed.
type EndpointHooks struct {
	// Renew A list of commands to run before and after a certificate is granted.
	Renew *EndpointHook `json:"renew,omitempty"`

	// Sign A list of commands to run before and after a certificate is granted.
	Sign *EndpointHook `json:"sign,omitempty"`
}

// EndpointKeyInfo The attributes of the cryptographic key.
type EndpointKeyInfo struct {
	// Format The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used.
	Format *EndpointKeyInfoFormat `json:"format,omitempty"`

	// Protection Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`.
	Protection *EndpointKeyInfoProtection `json:"protection,omitempty"`

	// PubFile A CSR or SSH public key to use instead of generating one.
	PubFile *string `json:"pubFile,omitempty"`

	// Type The key type used. The current DEFAULT type is ECDSA_P256.
	Type *EndpointKeyInfoType `json:"type,omitempty"`
}

// EndpointKeyInfoFormat The format used to encode the private key. For X509 keys the default format is PKCS#8. The classic format is PKCS#1 for RSA keys, SEC 1 for ECDSA keys, and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format. When a hardware module is used to store the keys the default will be a JSON representation of the key, except on Linux where tss2 will be used.
type EndpointKeyInfoFormat string

// EndpointKeyInfoProtection Whether to use a hardware module to store the private key for a workload certificate. If set to `NONE` no hardware module will be used. If set to `DEFAULT` a hardware module will only be used with format `TSS2`. `HARDWARE_WITH_FALLBACK` can only be used with the key format `DEFAULT`.
type EndpointKeyInfoProtection string

// EndpointKeyInfoType The key type used. The current DEFAULT type is ECDSA_P256.
type EndpointKeyInfoType string

// EndpointReloadInfo The properties used to reload a service.
type EndpointReloadInfo struct {
	// Method Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`.
	Method EndpointReloadInfoMethod `json:"method"`

	// PidFile File that holds the pid of the process to signal. Required when method is SIGNAL.
	PidFile *string `json:"pidFile,omitempty"`

	// Signal The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
	Signal *int `json:"signal,omitempty"`

	// UnitName The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
	UnitName *string `json:"unitName,omitempty"`
}

// EndpointReloadInfoMethod Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`.
type EndpointReloadInfoMethod string

// EnrollmentToken A JWT that can be used to enroll devices with the Smallstep Agent
type EnrollmentToken struct {
	// Id The unique identifier of the token
	Id *string `json:"id,omitempty"`

	// Secret The JWT itself; this value cannot be retrieved after initially generated and should be kept secret
	Secret *string `json:"secret,omitempty"`

	// Title The name of the token
	Title *string `json:"title,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error.
	Message string `json:"message"`
}

// GcpDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
type GcpDisableCustomSANs = bool

// GcpPlatform Google Cloud Platform
type GcpPlatform struct {
	// Name A friendly name for this GCP connection
	Name string `json:"name"`

	// ProjectIds The project IDs where the resources are located.
	ProjectIds []string `json:"projectIds"`

	// ServiceAccountKey A JSON-formatted service account key that allows the Smallstep Platform to manage resources on your behalf.
	ServiceAccountKey *string `json:"serviceAccountKey,omitempty"`

	// ServiceAccounts GCE service accounts that are allowed to enroll with the Smallstep Platform.
	ServiceAccounts *[]string `json:"serviceAccounts,omitempty"`
}

// GcpProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
type GcpProjectIDs = []string

// GcpProvisioner The [GCP provisioner](https://smallstep.com/docs/step-ca/provisioners/#gcp) grants a certificate to a Google Compute Engine instance using its identity token. At least one service account or project ID must be set.
type GcpProvisioner struct {
	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
	DisableCustomSANs *GcpDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`

	// ProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
	ProjectIDs *GcpProjectIDs `json:"projectIDs,omitempty"`

	// ServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
	ServiceAccounts *GcpServiceAccounts `json:"serviceAccounts,omitempty"`
}

// GcpServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
type GcpServiceAccounts = []string

// GcpVM Configuration for the GCP provisioner for device collections of GCP instances. At least one service account or project ID must be set.
type GcpVM struct {
	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
	DisableCustomSANs *GcpDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// ProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
	ProjectIDs *GcpProjectIDs `json:"projectIDs,omitempty"`

	// ServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
	ServiceAccounts *GcpServiceAccounts `json:"serviceAccounts,omitempty"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to.
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant.
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names.
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts.
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values.
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider.
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group.
	Id *string `json:"id,omitempty"`

	// Name The name of the group.
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username.
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered.
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion.
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any.
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp in RFC3339 format when the host was registered.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation.
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host.
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp in RFC3339 format when the host was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
type InstanceAge = string

// JwkProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#jwk) that uses public-key cryptography to sign and validate a JSON Web Token (JWT).
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key.
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key.
	Key interface{} `json:"key"`
}

// NameConstraints X509 certificate name constratins.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical.
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority.
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority.
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority.
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority.
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority.
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority.
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root.
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`
}

// NewCollection Body of a request to create a new collection.
type NewCollection struct {
	// DisplayName A user-friendly name for the collection.
	DisplayName *string `json:"displayName,omitempty"`

	// SchemaURI Reference to a schema that all instances in the collection must conform to.
	SchemaURI *string `json:"schemaURI,omitempty"`

	// Slug A lowercase name identifying the collection.
	Slug string `json:"slug"`
}

// NewEnrollmentToken The body of a request to generate a new device enrollment token.
type NewEnrollmentToken struct {
	// Title The name of the device enrollment token
	Title *string `json:"title,omitempty"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to.
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewPlatform Configuration to create a new platform.
type NewPlatform struct {
	DisplayName           string                            `json:"displayName"`
	PlatformConfiguration NewPlatform_PlatformConfiguration `json:"platformConfiguration"`

	// PlatformType Determines which set of fields to use in platformConfiguration. Cannot be changed.
	PlatformType NewPlatformPlatformType `json:"platformType"`
	Slug         string                  `json:"slug"`
}

// NewPlatform_PlatformConfiguration defines model for NewPlatform.PlatformConfiguration.
type NewPlatform_PlatformConfiguration struct {
	union json.RawMessage
}

// NewPlatformPlatformType Determines which set of fields to use in platformConfiguration. Cannot be changed.
type NewPlatformPlatformType string

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag.
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag.
	Value *string `json:"value,omitempty"`
}

// OidcProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#oauthoidc-single-sign-on) that is configured to trust and accept an OAuth provider's ID tokens for authentication. By default, the issued certificate will use the subject (sub) claim from the identity token as its subject. The value of the token's email claim is also included as an email SAN in the certificate.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// Platform A platform with a list of configurations.
type Platform struct {
	DisplayName            string                                 `json:"displayName"`
	PlatformConfigurations []Platform_PlatformConfigurations_Item `json:"platformConfigurations"`

	// PlatformType The type used in platformConfiguration.
	PlatformType PlatformPlatformType `json:"platformType"`
	Slug         string               `json:"slug"`
}

// Platform_PlatformConfigurations_Item defines model for platform.platformConfigurations.Item.
type Platform_PlatformConfigurations_Item struct {
	union json.RawMessage
}

// PlatformPlatformType The type used in platformConfiguration.
type PlatformPlatformType string

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID.
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group.
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group.
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group.
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user.
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory.
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell.
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user.
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user.
	Username *string `json:"username,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner.
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner.
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh      *SshOptions           `json:"ssh,omitempty"`
	Webhooks *[]ProvisionerWebhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates.
	X509 *X509Options `json:"x509,omitempty"`
}

// ProvisionerWebhook A [webhook](https://smallstep.com/docs/step-ca/webhooks/) to call when a certificate request is being processed.
type ProvisionerWebhook struct {
	// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BasicAuth *BasicAuth `json:"basicAuth,omitempty"`

	// BearerToken Webhook requests will include an Authorization header with the token. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BearerToken *string                    `json:"bearerToken,omitempty"`
	CertType    ProvisionerWebhookCertType `json:"certType"`

	// CollectionSlug For HOSTED_ATTESTATION webhooks, the collectionSlug is a reference to the collection that holds the devices that may be issued certificates. This collection must already exist. Required for `HOSTED_ATTESTATION` webhook servers; not allowed for `EXTERNAL`.
	CollectionSlug *string `json:"collectionSlug,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created. Will be sent to the webhook server in every request in the `X-Smallstep-Webhook-ID` header.
	Id *string `json:"id,omitempty"`

	// Kind The webhook kind indicates how and when it is called.
	//
	// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
	Kind ProvisionerWebhookKind `json:"kind"`

	// Name The name of the webhook. For `ENRICHING` webhooks, the returned data can be referenced in the certificate under the path `.Webhooks.<name>`. Must be unique to the provisioner.
	Name string `json:"name"`

	// Secret The shared secret used to authenticate the payload sent to the webhook server. Generated server-side. This is returned only for `EXTERNAL` webhook servers and only once, at the time of creation.
	Secret *string `json:"secret,omitempty"`

	// ServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
	//
	// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
	ServerType ProvisionerWebhookServerType `json:"serverType"`

	// Url The URL of the webhook server. Required for `EXTERNAL` webhook servers; read-only for hosted webhook servers.
	Url *string `json:"url,omitempty"`
}

// ProvisionerWebhookCertType defines model for ProvisionerWebhook.CertType.
type ProvisionerWebhookCertType string

// ProvisionerWebhookKind The webhook kind indicates how and when it is called.
//
// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
type ProvisionerWebhookKind string

// ProvisionerWebhookServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
//
// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
type ProvisionerWebhookServerType string

// ScepProvisioner The [SCEP provisioner](https://smallstep.com/docs/step-ca/provisioners/#scep) grants certificates to clients using the SCEP protocol. This type is currently experimental and subject to change.
type ScepProvisioner struct {
	// AutogenerateDecrypter Automatically generate a new RSA decrypter instead of providing one.
	AutogenerateDecrypter *bool `json:"autogenerateDecrypter,omitempty"`

	// Challenge A static challenge secret.
	Challenge *string `json:"challenge,omitempty"`

	// DecrypterCertificate A pem-encoded certificate for an RSA public key.
	DecrypterCertificate *string `json:"decrypterCertificate,omitempty"`

	// DecrypterKey The pem-encoded RSA private key, corresponding to the certificate public key.
	DecrypterKey *string `json:"decrypterKey,omitempty"`

	// DecrypterKeyPassword The password for the pem-encoded RSA private key, if any.
	DecrypterKeyPassword *string `json:"decrypterKeyPassword,omitempty"`

	// EncryptionAlgorithmIdentifier The encryption algorithm used for encrypting responses to the SCEP client:
	//  * `DES_CBC`    - [DES in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.1) - `1.3.14.3.2.7`
	//  * `AES_128_CBC` - [AES-128 in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.5) - `2.16.840.1.101.3.4.1.2`
	//  * `AES_128_GCM` - [AES-128 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.6`
	//  * `AES_256_CBC` - [AES-256 in CBC mode](https://www.rfc-editor.org/rfc/rfc3565.html#section-4.1) - `2.16.840.1.101.3.4.1.42`
	//  * `AES_256_GCM` - [AES-256 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.46`
	EncryptionAlgorithmIdentifier *ScepProvisionerEncryptionAlgorithmIdentifier `json:"encryptionAlgorithmIdentifier,omitempty"`

	// ExcludeIntermediate Exclude the intermediate CA certificate in SCEP responses.
	ExcludeIntermediate *bool `json:"excludeIntermediate,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// IncludeRoot Include the root CA certificate in SCEP responses.
	IncludeRoot *bool `json:"includeRoot,omitempty"`

	// MinimumPublicKeyLength The minimum number of bits for RSA public keys accepted in SCEP requests.
	MinimumPublicKeyLength *int `json:"minimumPublicKeyLength,omitempty"`
}

// ScepProvisionerEncryptionAlgorithmIdentifier The encryption algorithm used for encrypting responses to the SCEP client:
//   - `DES_CBC`    - [DES in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.1) - `1.3.14.3.2.7`
//   - `AES_128_CBC` - [AES-128 in CBC mode](https://www.rfc-editor.org/rfc/rfc8018.html#appendix-B.2.5) - `2.16.840.1.101.3.4.1.2`
//   - `AES_128_GCM` - [AES-128 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.6`
//   - `AES_256_CBC` - [AES-256 in CBC mode](https://www.rfc-editor.org/rfc/rfc3565.html#section-4.1) - `2.16.840.1.101.3.4.1.42`
//   - `AES_256_GCM` - [AES-256 in GCM mode](https://www.rfc-editor.org/rfc/rfc5084.html#section-3.2) - `2.16.840.1.101.3.4.1.46`
type ScepProvisionerEncryptionAlgorithmIdentifier string

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag.
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag.
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag.
	Value *string `json:"value,omitempty"`
}

// Tpm Configuration for a device collection of machines with TPMs.
type Tpm struct {
	// AttestorIntermediates The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
	AttestorIntermediates *string `json:"attestorIntermediates,omitempty"`

	// AttestorRoots The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
	AttestorRoots *string `json:"attestorRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider.
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name.
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name.
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name.
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user.
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// Workload defines model for workload.
type Workload struct {
	// AdminEmails Users that will have admin access to manage the workloads authority, which will be created if it does not already exist. Ignored if the workloads authority already exists. Never returned in responses.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CertificateInfo Details on a managed certificate.
	CertificateInfo *EndpointCertificateInfo `json:"certificateInfo,omitempty"`

	// DisplayName A friendly name for the workload. Also used as the Common Name, if no static SANs are provided.
	DisplayName string `json:"displayName"`

	// Hooks The collection of commands to run when a certificate for a managed endpoint is signed or renewed.
	Hooks *EndpointHooks `json:"hooks,omitempty"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`

	// Slug Used as the identifier for the workload.
	Slug string `json:"slug"`

	// WorkloadType The type of workload being deployed.
	// Possible values are `etcd` `generic` `git` `grafana` `haproxy` `httpd` `kafka` `mysql` `nginx` `nodejs` `postgres` `redis` `tomcat` and `zookeeper`.
	// Use `generic` for a basic certificate workload.
	WorkloadType string `json:"workloadType"`
	union        json.RawMessage
}

// X509Fields defines model for x509Fields.
type X509Fields struct {
	// CommonName A certificate field that takes a single string value, e.g. Common Name.
	CommonName *CertificateField `json:"commonName,omitempty"`

	// Country A certificate field that accepts multiple string values, e.g. SANs.
	Country *CertificateFieldList `json:"country,omitempty"`

	// Locality A certificate field that accepts multiple string values, e.g. SANs.
	Locality *CertificateFieldList `json:"locality,omitempty"`

	// Organization A certificate field that accepts multiple string values, e.g. SANs.
	Organization *CertificateFieldList `json:"organization,omitempty"`

	// OrganizationalUnit A certificate field that accepts multiple string values, e.g. SANs.
	OrganizationalUnit *CertificateFieldList `json:"organizationalUnit,omitempty"`

	// PostalCode A certificate field that accepts multiple string values, e.g. SANs.
	PostalCode *CertificateFieldList `json:"postalCode,omitempty"`

	// Province A certificate field that accepts multiple string values, e.g. SANs.
	Province *CertificateFieldList `json:"province,omitempty"`

	// Sans A certificate field that accepts multiple string values, e.g. SANs.
	Sans *CertificateFieldList `json:"sans,omitempty"`

	// StreetAddress A certificate field that accepts multiple string values, e.g. SANs.
	StreetAddress *CertificateFieldList `json:"streetAddress,omitempty"`
}

// X509Issuer A Customized X509 issuer for an authority.
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm.
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer.
	Name string `json:"name"`

	// NameConstraints X509 certificate name constratins.
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm.
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates.
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// X5cProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#x5c---x509-certificate) that authenticates a certificate request with an existing x509 certificate.
type X5cProvisioner struct {
	// Roots A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
	Roots []string `json:"roots"`
}

// Accept defines model for accept.
type Accept = string

// AttestationAuthorityID defines model for attestationAuthorityID.
type AttestationAuthorityID = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// CollectionSlug defines model for collectionSlug.
type CollectionSlug = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InstanceID defines model for instanceID.
type InstanceID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// PlatformSlug defines model for platformSlug.
type PlatformSlug = string

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// WebhookNameOrID defines model for webhookNameOrID.
type WebhookNameOrID = string

// WorkloadSlug defines model for workloadSlug.
type WorkloadSlug = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N422 defines model for 422.
type N422 = Error

// N500 defines model for 500.
type N500 = Error

// GetAttestationAuthoritiesParams defines parameters for GetAttestationAuthorities.
type GetAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesParams defines parameters for PostAttestationAuthorities.
type PostAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAttestationAuthorityParams defines parameters for DeleteAttestationAuthority.
type DeleteAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAttestationAuthorityParams defines parameters for GetAttestationAuthority.
type GetAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
	TeamSlug *string                   `json:"teamSlug,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostWebhooksParams defines parameters for PostWebhooks.
type PostWebhooksParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWebhookParams defines parameters for DeleteWebhook.
type DeleteWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostCollectionsParams defines parameters for PostCollections.
type PostCollectionsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteCollectionParams defines parameters for DeleteCollection.
type DeleteCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCollectionParams defines parameters for GetCollection.
type GetCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCollectionParams defines parameters for PutCollection.
type PutCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteCollectionInstanceParams defines parameters for DeleteCollectionInstance.
type DeleteCollectionInstanceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCollectionInstanceParams defines parameters for GetCollectionInstance.
type GetCollectionInstanceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCollectionInstanceJSONBody defines parameters for PutCollectionInstance.
type PutCollectionInstanceJSONBody struct {
	Data interface{} `json:"data"`
}

// PutCollectionInstanceParams defines parameters for PutCollectionInstance.
type PutCollectionInstanceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCollectionInstanceDataParams defines parameters for GetCollectionInstanceData.
type GetCollectionInstanceDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCollectionInstanceDataJSONBody defines parameters for PutCollectionInstanceData.
type PutCollectionInstanceDataJSONBody = interface{}

// PutCollectionInstanceDataParams defines parameters for PutCollectionInstanceData.
type PutCollectionInstanceDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListCollectionInstancesParams defines parameters for ListCollectionInstances.
type ListCollectionInstancesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteDeviceCollectionParams defines parameters for DeleteDeviceCollection.
type DeleteDeviceCollectionParams struct {
	// Purge Delete all workloads and devices in the collection.
	// The API will return 422 if the device collection is not empty and the purge flag is not set.
	Purge *bool `form:"purge,omitempty" json:"purge,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetDeviceCollectionParams defines parameters for GetDeviceCollection.
type GetDeviceCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutDeviceCollectionParams defines parameters for PutDeviceCollection.
type PutDeviceCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWorkloadParams defines parameters for DeleteWorkload.
type DeleteWorkloadParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWorkloadParams defines parameters for GetWorkload.
type GetWorkloadParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutWorkloadParams defines parameters for PutWorkload.
type PutWorkloadParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostDeviceEnrollmentTokenParams defines parameters for PostDeviceEnrollmentToken.
type PostDeviceEnrollmentTokenParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to `true` the results will only include active hosts. If set to `false` the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to `true` the results will include only bastion hosts and if set to `false` the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetPlatformsParams defines parameters for GetPlatforms.
type GetPlatformsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutPlatformParams defines parameters for PutPlatform.
type PutPlatformParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesJSONRequestBody defines body for PostAttestationAuthorities for application/json ContentType.
type PostAttestationAuthoritiesJSONRequestBody = AttestationAuthority

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostWebhooksJSONRequestBody defines body for PostWebhooks for application/json ContentType.
type PostWebhooksJSONRequestBody = ProvisionerWebhook

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostCollectionsJSONRequestBody defines body for PostCollections for application/json ContentType.
type PostCollectionsJSONRequestBody = NewCollection

// PutCollectionJSONRequestBody defines body for PutCollection for application/json ContentType.
type PutCollectionJSONRequestBody = Collection

// PutCollectionInstanceJSONRequestBody defines body for PutCollectionInstance for application/json ContentType.
type PutCollectionInstanceJSONRequestBody PutCollectionInstanceJSONBody

// PutCollectionInstanceDataJSONRequestBody defines body for PutCollectionInstanceData for application/json ContentType.
type PutCollectionInstanceDataJSONRequestBody = PutCollectionInstanceDataJSONBody

// PutDeviceCollectionJSONRequestBody defines body for PutDeviceCollection for application/json ContentType.
type PutDeviceCollectionJSONRequestBody = DeviceCollection

// PutWorkloadJSONRequestBody defines body for PutWorkload for application/json ContentType.
type PutWorkloadJSONRequestBody = Workload

// PostDeviceEnrollmentTokenJSONRequestBody defines body for PostDeviceEnrollmentToken for application/json ContentType.
type PostDeviceEnrollmentTokenJSONRequestBody = NewEnrollmentToken

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PutPlatformJSONRequestBody defines body for PutPlatform for application/json ContentType.
type PutPlatformJSONRequestBody = NewPlatform

// AsCertificateFieldStatic returns the union data inside the CertificateField as a CertificateFieldStatic
func (t CertificateField) AsCertificateFieldStatic() (CertificateFieldStatic, error) {
	var body CertificateFieldStatic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCertificateFieldStatic overwrites any union data inside the CertificateField as the provided CertificateFieldStatic
func (t *CertificateField) FromCertificateFieldStatic(v CertificateFieldStatic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCertificateFieldStatic performs a merge with any union data inside the CertificateField, using the provided CertificateFieldStatic
func (t *CertificateField) MergeCertificateFieldStatic(v CertificateFieldStatic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCertificateFieldDeviceMetadata returns the union data inside the CertificateField as a CertificateFieldDeviceMetadata
func (t CertificateField) AsCertificateFieldDeviceMetadata() (CertificateFieldDeviceMetadata, error) {
	var body CertificateFieldDeviceMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCertificateFieldDeviceMetadata overwrites any union data inside the CertificateField as the provided CertificateFieldDeviceMetadata
func (t *CertificateField) FromCertificateFieldDeviceMetadata(v CertificateFieldDeviceMetadata) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCertificateFieldDeviceMetadata performs a merge with any union data inside the CertificateField, using the provided CertificateFieldDeviceMetadata
func (t *CertificateField) MergeCertificateFieldDeviceMetadata(v CertificateFieldDeviceMetadata) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CertificateField) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CertificateField) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsVM returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a AwsVM
func (t DeviceCollection_DeviceTypeConfiguration) AsAwsVM() (AwsVM, error) {
	var body AwsVM
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsVM overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided AwsVM
func (t *DeviceCollection_DeviceTypeConfiguration) FromAwsVM(v AwsVM) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsVM performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided AwsVM
func (t *DeviceCollection_DeviceTypeConfiguration) MergeAwsVM(v AwsVM) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureVM returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a AzureVM
func (t DeviceCollection_DeviceTypeConfiguration) AsAzureVM() (AzureVM, error) {
	var body AzureVM
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureVM overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided AzureVM
func (t *DeviceCollection_DeviceTypeConfiguration) FromAzureVM(v AzureVM) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureVM performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided AzureVM
func (t *DeviceCollection_DeviceTypeConfiguration) MergeAzureVM(v AzureVM) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGcpVM returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a GcpVM
func (t DeviceCollection_DeviceTypeConfiguration) AsGcpVM() (GcpVM, error) {
	var body GcpVM
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpVM overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided GcpVM
func (t *DeviceCollection_DeviceTypeConfiguration) FromGcpVM(v GcpVM) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpVM performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided GcpVM
func (t *DeviceCollection_DeviceTypeConfiguration) MergeGcpVM(v GcpVM) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTpm returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a Tpm
func (t DeviceCollection_DeviceTypeConfiguration) AsTpm() (Tpm, error) {
	var body Tpm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTpm overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided Tpm
func (t *DeviceCollection_DeviceTypeConfiguration) FromTpm(v Tpm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTpm performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided Tpm
func (t *DeviceCollection_DeviceTypeConfiguration) MergeTpm(v Tpm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DeviceCollection_DeviceTypeConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeviceCollection_DeviceTypeConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsPlatform returns the union data inside the NewPlatform_PlatformConfiguration as a AwsPlatform
func (t NewPlatform_PlatformConfiguration) AsAwsPlatform() (AwsPlatform, error) {
	var body AwsPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsPlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided AwsPlatform
func (t *NewPlatform_PlatformConfiguration) FromAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsPlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided AwsPlatform
func (t *NewPlatform_PlatformConfiguration) MergeAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzurePlatform returns the union data inside the NewPlatform_PlatformConfiguration as a AzurePlatform
func (t NewPlatform_PlatformConfiguration) AsAzurePlatform() (AzurePlatform, error) {
	var body AzurePlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzurePlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided AzurePlatform
func (t *NewPlatform_PlatformConfiguration) FromAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzurePlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided AzurePlatform
func (t *NewPlatform_PlatformConfiguration) MergeAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGcpPlatform returns the union data inside the NewPlatform_PlatformConfiguration as a GcpPlatform
func (t NewPlatform_PlatformConfiguration) AsGcpPlatform() (GcpPlatform, error) {
	var body GcpPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpPlatform overwrites any union data inside the NewPlatform_PlatformConfiguration as the provided GcpPlatform
func (t *NewPlatform_PlatformConfiguration) FromGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpPlatform performs a merge with any union data inside the NewPlatform_PlatformConfiguration, using the provided GcpPlatform
func (t *NewPlatform_PlatformConfiguration) MergeGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NewPlatform_PlatformConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewPlatform_PlatformConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsPlatform returns the union data inside the Platform_PlatformConfigurations_Item as a AwsPlatform
func (t Platform_PlatformConfigurations_Item) AsAwsPlatform() (AwsPlatform, error) {
	var body AwsPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsPlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided AwsPlatform
func (t *Platform_PlatformConfigurations_Item) FromAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsPlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided AwsPlatform
func (t *Platform_PlatformConfigurations_Item) MergeAwsPlatform(v AwsPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzurePlatform returns the union data inside the Platform_PlatformConfigurations_Item as a AzurePlatform
func (t Platform_PlatformConfigurations_Item) AsAzurePlatform() (AzurePlatform, error) {
	var body AzurePlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzurePlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided AzurePlatform
func (t *Platform_PlatformConfigurations_Item) FromAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzurePlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided AzurePlatform
func (t *Platform_PlatformConfigurations_Item) MergeAzurePlatform(v AzurePlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGcpPlatform returns the union data inside the Platform_PlatformConfigurations_Item as a GcpPlatform
func (t Platform_PlatformConfigurations_Item) AsGcpPlatform() (GcpPlatform, error) {
	var body GcpPlatform
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpPlatform overwrites any union data inside the Platform_PlatformConfigurations_Item as the provided GcpPlatform
func (t *Platform_PlatformConfigurations_Item) FromGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpPlatform performs a merge with any union data inside the Platform_PlatformConfigurations_Item, using the provided GcpPlatform
func (t *Platform_PlatformConfigurations_Item) MergeGcpPlatform(v GcpPlatform) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Platform_PlatformConfigurations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Platform_PlatformConfigurations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeProvisioner returns the union data inside the Provisioner as a AcmeProvisioner
func (t Provisioner) AsAcmeProvisioner() (AcmeProvisioner, error) {
	var body AcmeProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeProvisioner overwrites any union data inside the Provisioner as the provided AcmeProvisioner
func (t *Provisioner) FromAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeProvisioner
func (t *Provisioner) MergeAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeAttestationProvisioner returns the union data inside the Provisioner as a AcmeAttestationProvisioner
func (t Provisioner) AsAcmeAttestationProvisioner() (AcmeAttestationProvisioner, error) {
	var body AcmeAttestationProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeAttestationProvisioner overwrites any union data inside the Provisioner as the provided AcmeAttestationProvisioner
func (t *Provisioner) FromAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeAttestationProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeAttestationProvisioner
func (t *Provisioner) MergeAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsX5cProvisioner returns the union data inside the Provisioner as a X5cProvisioner
func (t Provisioner) AsX5cProvisioner() (X5cProvisioner, error) {
	var body X5cProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX5cProvisioner overwrites any union data inside the Provisioner as the provided X5cProvisioner
func (t *Provisioner) FromX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX5cProvisioner performs a merge with any union data inside the Provisioner, using the provided X5cProvisioner
func (t *Provisioner) MergeX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAwsProvisioner returns the union data inside the Provisioner as a AwsProvisioner
func (t Provisioner) AsAwsProvisioner() (AwsProvisioner, error) {
	var body AwsProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsProvisioner overwrites any union data inside the Provisioner as the provided AwsProvisioner
func (t *Provisioner) FromAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsProvisioner performs a merge with any union data inside the Provisioner, using the provided AwsProvisioner
func (t *Provisioner) MergeAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGcpProvisioner returns the union data inside the Provisioner as a GcpProvisioner
func (t Provisioner) AsGcpProvisioner() (GcpProvisioner, error) {
	var body GcpProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpProvisioner overwrites any union data inside the Provisioner as the provided GcpProvisioner
func (t *Provisioner) FromGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpProvisioner performs a merge with any union data inside the Provisioner, using the provided GcpProvisioner
func (t *Provisioner) MergeGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureProvisioner returns the union data inside the Provisioner as a AzureProvisioner
func (t Provisioner) AsAzureProvisioner() (AzureProvisioner, error) {
	var body AzureProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureProvisioner overwrites any union data inside the Provisioner as the provided AzureProvisioner
func (t *Provisioner) FromAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureProvisioner performs a merge with any union data inside the Provisioner, using the provided AzureProvisioner
func (t *Provisioner) MergeAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsScepProvisioner returns the union data inside the Provisioner as a ScepProvisioner
func (t Provisioner) AsScepProvisioner() (ScepProvisioner, error) {
	var body ScepProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScepProvisioner overwrites any union data inside the Provisioner as the provided ScepProvisioner
func (t *Provisioner) FromScepProvisioner(v ScepProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScepProvisioner performs a merge with any union data inside the Provisioner, using the provided ScepProvisioner
func (t *Provisioner) MergeScepProvisioner(v ScepProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsX509Fields returns the union data inside the Workload as a X509Fields
func (t Workload) AsX509Fields() (X509Fields, error) {
	var body X509Fields
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX509Fields overwrites any union data inside the Workload as the provided X509Fields
func (t *Workload) FromX509Fields(v X509Fields) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX509Fields performs a merge with any union data inside the Workload, using the provided X509Fields
func (t *Workload) MergeX509Fields(v X509Fields) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Workload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AdminEmails != nil {
		object["adminEmails"], err = json.Marshal(t.AdminEmails)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'adminEmails': %w", err)
		}
	}

	if t.CertificateInfo != nil {
		object["certificateInfo"], err = json.Marshal(t.CertificateInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificateInfo': %w", err)
		}
	}

	object["displayName"], err = json.Marshal(t.DisplayName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'displayName': %w", err)
	}

	if t.Hooks != nil {
		object["hooks"], err = json.Marshal(t.Hooks)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hooks': %w", err)
		}
	}

	if t.KeyInfo != nil {
		object["keyInfo"], err = json.Marshal(t.KeyInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keyInfo': %w", err)
		}
	}

	if t.ReloadInfo != nil {
		object["reloadInfo"], err = json.Marshal(t.ReloadInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reloadInfo': %w", err)
		}
	}

	object["slug"], err = json.Marshal(t.Slug)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'slug': %w", err)
	}

	object["workloadType"], err = json.Marshal(t.WorkloadType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'workloadType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Workload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["adminEmails"]; found {
		err = json.Unmarshal(raw, &t.AdminEmails)
		if err != nil {
			return fmt.Errorf("error reading 'adminEmails': %w", err)
		}
	}

	if raw, found := object["certificateInfo"]; found {
		err = json.Unmarshal(raw, &t.CertificateInfo)
		if err != nil {
			return fmt.Errorf("error reading 'certificateInfo': %w", err)
		}
	}

	if raw, found := object["displayName"]; found {
		err = json.Unmarshal(raw, &t.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'displayName': %w", err)
		}
	}

	if raw, found := object["hooks"]; found {
		err = json.Unmarshal(raw, &t.Hooks)
		if err != nil {
			return fmt.Errorf("error reading 'hooks': %w", err)
		}
	}

	if raw, found := object["keyInfo"]; found {
		err = json.Unmarshal(raw, &t.KeyInfo)
		if err != nil {
			return fmt.Errorf("error reading 'keyInfo': %w", err)
		}
	}

	if raw, found := object["reloadInfo"]; found {
		err = json.Unmarshal(raw, &t.ReloadInfo)
		if err != nil {
			return fmt.Errorf("error reading 'reloadInfo': %w", err)
		}
	}

	if raw, found := object["slug"]; found {
		err = json.Unmarshal(raw, &t.Slug)
		if err != nil {
			return fmt.Errorf("error reading 'slug': %w", err)
		}
	}

	if raw, found := object["workloadType"]; found {
		err = json.Unmarshal(raw, &t.WorkloadType)
		if err != nil {
			return fmt.Errorf("error reading 'workloadType': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAttestationAuthorities request
	GetAttestationAuthorities(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAttestationAuthorities request with any body
	PostAttestationAuthoritiesWithBody(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAttestationAuthorities(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAttestationAuthority request
	DeleteAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttestationAuthority request
	GetAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuth request with any body
	PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorities request
	GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorities request with any body
	PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthoritiesCsr request with any body
	PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthority request
	DeleteAuthority(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthority request
	GetAuthority(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthorityProvisioners request
	ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityProvisioners request with any body
	PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProvisioner request
	DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProvisioner request
	GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooks request with any body
	PostWebhooksWithBody(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWebhooks(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorityRoot request with any body
	PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollections request
	ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollections request with any body
	PostCollectionsWithBody(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollections(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollection request
	DeleteCollection(ctx context.Context, collectionSlug CollectionSlug, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollection request
	GetCollection(ctx context.Context, collectionSlug CollectionSlug, params *GetCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutCollection request with any body
	PutCollectionWithBody(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutCollection(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollectionInstance request
	DeleteCollectionInstance(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *DeleteCollectionInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionInstance request
	GetCollectionInstance(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutCollectionInstance request with any body
	PutCollectionInstanceWithBody(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutCollectionInstance(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, body PutCollectionInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionInstanceData request
	GetCollectionInstanceData(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutCollectionInstanceData request with any body
	PutCollectionInstanceDataWithBody(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutCollectionInstanceData(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, body PutCollectionInstanceDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollectionInstances request
	ListCollectionInstances(ctx context.Context, collectionSlug CollectionSlug, params *ListCollectionInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeviceCollection request
	DeleteDeviceCollection(ctx context.Context, collectionSlug CollectionSlug, params *DeleteDeviceCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeviceCollection request
	GetDeviceCollection(ctx context.Context, collectionSlug CollectionSlug, params *GetDeviceCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDeviceCollection request with any body
	PutDeviceCollectionWithBody(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutDeviceCollection(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, body PutDeviceCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkload request
	DeleteWorkload(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *DeleteWorkloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkload request
	GetWorkload(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *GetWorkloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutWorkload request with any body
	PutWorkloadWithBody(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutWorkload(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, body PutWorkloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDeviceEnrollmentToken request with any body
	PostDeviceEnrollmentTokenWithBody(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDeviceEnrollmentToken(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, body PostDeviceEnrollmentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGrants request
	GetSshGrants(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSshGrants request with any body
	PostSshGrantsWithBody(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSshGrants(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSshGrant request
	DeleteSshGrant(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGrant request
	GetSshGrant(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGroups request
	GetSshGroups(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshGroup request
	GetSshGroup(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshHosts request
	GetSshHosts(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshHost request
	GetSshHost(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHostsHostIDTags request with any body
	PostHostsHostIDTagsWithBody(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHostsHostIDTags(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterSshHost request
	UnregisterSshHost(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatforms request
	GetPlatforms(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPlatform request with any body
	PutPlatformWithBody(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPlatform(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshHostTags request
	GetSshHostTags(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshUsers request
	GetSshUsers(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAttestationAuthorities(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttestationAuthoritiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttestationAuthoritiesWithBody(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttestationAuthoritiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAttestationAuthorities(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAttestationAuthoritiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAttestationAuthorityRequest(c.Server, attestationAuthorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttestationAuthority(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttestationAuthorityRequest(c.Server, attestationAuthorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorities(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthoritiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesWithBody(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorities(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsrWithBody(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthoritiesCsr(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthoritiesCsrRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthority(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorityRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthority(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorityRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthorityProvisionersRequest(c.Server, authorityID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisionersWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityProvisioners(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityProvisionersRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProvisioner(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProvisionerRequest(c.Server, authorityID, provisionerNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWithBody(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequestWithBody(c.Server, authorityID, provisionerNameOrID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooks(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequest(c.Server, authorityID, provisionerNameOrID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, authorityID, provisionerNameOrID, webhookNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, authorityID, provisionerNameOrID, webhookNameOrID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRootWithBody(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequestWithBody(c.Server, authorityID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorityRoot(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorityRootRequest(c.Server, authorityID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsWithBody(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollections(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollection(ctx context.Context, collectionSlug CollectionSlug, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollection(ctx context.Context, collectionSlug CollectionSlug, params *GetCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollectionWithBody(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionRequestWithBody(c.Server, collectionSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollection(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionRequest(c.Server, collectionSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollectionInstance(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *DeleteCollectionInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionInstanceRequest(c.Server, collectionSlug, instanceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionInstance(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionInstanceRequest(c.Server, collectionSlug, instanceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollectionInstanceWithBody(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionInstanceRequestWithBody(c.Server, collectionSlug, instanceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollectionInstance(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, body PutCollectionInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionInstanceRequest(c.Server, collectionSlug, instanceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionInstanceData(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionInstanceDataRequest(c.Server, collectionSlug, instanceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollectionInstanceDataWithBody(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionInstanceDataRequestWithBody(c.Server, collectionSlug, instanceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutCollectionInstanceData(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, body PutCollectionInstanceDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutCollectionInstanceDataRequest(c.Server, collectionSlug, instanceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollectionInstances(ctx context.Context, collectionSlug CollectionSlug, params *ListCollectionInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollectionInstancesRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeviceCollection(ctx context.Context, collectionSlug CollectionSlug, params *DeleteDeviceCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceCollectionRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeviceCollection(ctx context.Context, collectionSlug CollectionSlug, params *GetDeviceCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceCollectionRequest(c.Server, collectionSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDeviceCollectionWithBody(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDeviceCollectionRequestWithBody(c.Server, collectionSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDeviceCollection(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, body PutDeviceCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDeviceCollectionRequest(c.Server, collectionSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkload(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *DeleteWorkloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkloadRequest(c.Server, collectionSlug, workloadSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkload(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *GetWorkloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkloadRequest(c.Server, collectionSlug, workloadSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkloadWithBody(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkloadRequestWithBody(c.Server, collectionSlug, workloadSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutWorkload(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, body PutWorkloadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutWorkloadRequest(c.Server, collectionSlug, workloadSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeviceEnrollmentTokenWithBody(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeviceEnrollmentTokenRequestWithBody(c.Server, collectionSlug, instanceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDeviceEnrollmentToken(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, body PostDeviceEnrollmentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDeviceEnrollmentTokenRequest(c.Server, collectionSlug, instanceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGrants(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGrantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSshGrantsWithBody(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSshGrantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSshGrants(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSshGrantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSshGrant(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSshGrantRequest(c.Server, grantID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGrant(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGrantRequest(c.Server, grantID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGroups(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshGroup(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshGroupRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshHosts(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshHost(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshHostRequest(c.Server, hostID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostsHostIDTagsWithBody(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostsHostIDTagsRequestWithBody(c.Server, hostID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHostsHostIDTags(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHostsHostIDTagsRequest(c.Server, hostID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterSshHost(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterSshHostRequest(c.Server, hostID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatforms(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlatformWithBody(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlatformRequestWithBody(c.Server, platformSlug, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlatform(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlatformRequest(c.Server, platformSlug, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshHostTags(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshHostTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshUsers(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAttestationAuthoritiesRequest generates requests for GetAttestationAuthorities
func NewGetAttestationAuthoritiesRequest(server string, params *GetAttestationAuthoritiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAttestationAuthoritiesRequest calls the generic PostAttestationAuthorities builder with application/json body
func NewPostAttestationAuthoritiesRequest(server string, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAttestationAuthoritiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAttestationAuthoritiesRequestWithBody generates requests for PostAttestationAuthorities with any type of body
func NewPostAttestationAuthoritiesRequestWithBody(server string, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteAttestationAuthorityRequest generates requests for DeleteAttestationAuthority
func NewDeleteAttestationAuthorityRequest(server string, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, attestationAuthorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetAttestationAuthorityRequest generates requests for GetAttestationAuthority
func NewGetAttestationAuthorityRequest(server string, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, attestationAuthorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attestation-authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthRequest calls the generic PostAuth builder with application/json body
func NewPostAuthRequest(server string, body PostAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthRequestWithBody generates requests for PostAuth with any type of body
func NewPostAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthoritiesRequest generates requests for GetAuthorities
func NewGetAuthoritiesRequest(server string, params *GetAuthoritiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthoritiesRequest calls the generic PostAuthorities builder with application/json body
func NewPostAuthoritiesRequest(server string, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesRequestWithBody generates requests for PostAuthorities with any type of body
func NewPostAuthoritiesRequestWithBody(server string, params *PostAuthoritiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthoritiesCsrRequest calls the generic PostAuthoritiesCsr builder with application/json body
func NewPostAuthoritiesCsrRequest(server string, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthoritiesCsrRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthoritiesCsrRequestWithBody generates requests for PostAuthoritiesCsr with any type of body
func NewPostAuthoritiesCsrRequestWithBody(server string, params *PostAuthoritiesCsrParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/csr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteAuthorityRequest generates requests for DeleteAuthority
func NewDeleteAuthorityRequest(server string, authorityID AuthorityID, params *DeleteAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetAuthorityRequest generates requests for GetAuthority
func NewGetAuthorityRequest(server string, authorityID AuthorityID, params *GetAuthorityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewListAuthorityProvisionersRequest generates requests for ListAuthorityProvisioners
func NewListAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *ListAuthorityProvisionersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthorityProvisionersRequest calls the generic PostAuthorityProvisioners builder with application/json body
func NewPostAuthorityProvisionersRequest(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityProvisionersRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityProvisionersRequestWithBody generates requests for PostAuthorityProvisioners with any type of body
func NewPostAuthorityProvisionersRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteProvisionerRequest generates requests for DeleteProvisioner
func NewDeleteProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetProvisionerRequest generates requests for GetProvisioner
func NewGetProvisionerRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostWebhooksRequest calls the generic PostWebhooks builder with application/json body
func NewPostWebhooksRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWebhooksRequestWithBody(server, authorityID, provisionerNameOrID, params, "application/json", bodyReader)
}

// NewPostWebhooksRequestWithBody generates requests for PostWebhooks with any type of body
func NewPostWebhooksRequestWithBody(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, webhookNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, provisionerNameOrID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, webhookNameOrID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/provisioners/%s/webhooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostAuthorityRootRequest calls the generic PostAuthorityRoot builder with application/json body
func NewPostAuthorityRootRequest(server string, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorityRootRequestWithBody(server, authorityID, params, "application/json", bodyReader)
}

// NewPostAuthorityRootRequestWithBody generates requests for PostAuthorityRoot with any type of body
func NewPostAuthorityRootRequestWithBody(server string, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, authorityID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorities/%s/root", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewListCollectionsRequest generates requests for ListCollections
func NewListCollectionsRequest(server string, params *ListCollectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostCollectionsRequest calls the generic PostCollections builder with application/json body
func NewPostCollectionsRequest(server string, params *PostCollectionsParams, body PostCollectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCollectionsRequestWithBody generates requests for PostCollections with any type of body
func NewPostCollectionsRequestWithBody(server string, params *PostCollectionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteCollectionRequest generates requests for DeleteCollection
func NewDeleteCollectionRequest(server string, collectionSlug CollectionSlug, params *DeleteCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetCollectionRequest generates requests for GetCollection
func NewGetCollectionRequest(server string, collectionSlug CollectionSlug, params *GetCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutCollectionRequest calls the generic PutCollection builder with application/json body
func NewPutCollectionRequest(server string, collectionSlug CollectionSlug, params *PutCollectionParams, body PutCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCollectionRequestWithBody(server, collectionSlug, params, "application/json", bodyReader)
}

// NewPutCollectionRequestWithBody generates requests for PutCollection with any type of body
func NewPutCollectionRequestWithBody(server string, collectionSlug CollectionSlug, params *PutCollectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteCollectionInstanceRequest generates requests for DeleteCollectionInstance
func NewDeleteCollectionInstanceRequest(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *DeleteCollectionInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/instances/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetCollectionInstanceRequest generates requests for GetCollectionInstance
func NewGetCollectionInstanceRequest(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/instances/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutCollectionInstanceRequest calls the generic PutCollectionInstance builder with application/json body
func NewPutCollectionInstanceRequest(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, body PutCollectionInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCollectionInstanceRequestWithBody(server, collectionSlug, instanceID, params, "application/json", bodyReader)
}

// NewPutCollectionInstanceRequestWithBody generates requests for PutCollectionInstance with any type of body
func NewPutCollectionInstanceRequestWithBody(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/instances/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetCollectionInstanceDataRequest generates requests for GetCollectionInstanceData
func NewGetCollectionInstanceDataRequest(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/instances/%s/data", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutCollectionInstanceDataRequest calls the generic PutCollectionInstanceData builder with application/json body
func NewPutCollectionInstanceDataRequest(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, body PutCollectionInstanceDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCollectionInstanceDataRequestWithBody(server, collectionSlug, instanceID, params, "application/json", bodyReader)
}

// NewPutCollectionInstanceDataRequestWithBody generates requests for PutCollectionInstanceData with any type of body
func NewPutCollectionInstanceDataRequestWithBody(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/instances/%s/data", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewListCollectionInstancesRequest generates requests for ListCollectionInstances
func NewListCollectionInstancesRequest(server string, collectionSlug CollectionSlug, params *ListCollectionInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteDeviceCollectionRequest generates requests for DeleteDeviceCollection
func NewDeleteDeviceCollectionRequest(server string, collectionSlug CollectionSlug, params *DeleteDeviceCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Purge != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purge", runtime.ParamLocationQuery, *params.Purge); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetDeviceCollectionRequest generates requests for GetDeviceCollection
func NewGetDeviceCollectionRequest(server string, collectionSlug CollectionSlug, params *GetDeviceCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutDeviceCollectionRequest calls the generic PutDeviceCollection builder with application/json body
func NewPutDeviceCollectionRequest(server string, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, body PutDeviceCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutDeviceCollectionRequestWithBody(server, collectionSlug, params, "application/json", bodyReader)
}

// NewPutDeviceCollectionRequestWithBody generates requests for PutDeviceCollection with any type of body
func NewPutDeviceCollectionRequestWithBody(server string, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteWorkloadRequest generates requests for DeleteWorkload
func NewDeleteWorkloadRequest(server string, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *DeleteWorkloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workloadSlug", runtime.ParamLocationPath, workloadSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s/workloads/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetWorkloadRequest generates requests for GetWorkload
func NewGetWorkloadRequest(server string, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *GetWorkloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workloadSlug", runtime.ParamLocationPath, workloadSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s/workloads/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutWorkloadRequest calls the generic PutWorkload builder with application/json body
func NewPutWorkloadRequest(server string, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, body PutWorkloadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutWorkloadRequestWithBody(server, collectionSlug, workloadSlug, params, "application/json", bodyReader)
}

// NewPutWorkloadRequestWithBody generates requests for PutWorkload with any type of body
func NewPutWorkloadRequestWithBody(server string, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workloadSlug", runtime.ParamLocationPath, workloadSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s/workloads/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostDeviceEnrollmentTokenRequest calls the generic PostDeviceEnrollmentToken builder with application/json body
func NewPostDeviceEnrollmentTokenRequest(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, body PostDeviceEnrollmentTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDeviceEnrollmentTokenRequestWithBody(server, collectionSlug, instanceID, params, "application/json", bodyReader)
}

// NewPostDeviceEnrollmentTokenRequestWithBody generates requests for PostDeviceEnrollmentToken with any type of body
func NewPostDeviceEnrollmentTokenRequestWithBody(server string, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, collectionSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, instanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-collections/%s/%s/enrollment-token", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGrantsRequest generates requests for GetSshGrants
func NewGetSshGrantsRequest(server string, params *GetSshGrantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostSshGrantsRequest calls the generic PostSshGrants builder with application/json body
func NewPostSshGrantsRequest(server string, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSshGrantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostSshGrantsRequestWithBody generates requests for PostSshGrants with any type of body
func NewPostSshGrantsRequestWithBody(server string, params *PostSshGrantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewDeleteSshGrantRequest generates requests for DeleteSshGrant
func NewDeleteSshGrantRequest(server string, grantID GrantID, params *DeleteSshGrantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grantID", runtime.ParamLocationPath, grantID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGrantRequest generates requests for GetSshGrant
func NewGetSshGrantRequest(server string, grantID GrantID, params *GetSshGrantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grantID", runtime.ParamLocationPath, grantID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGroupsRequest generates requests for GetSshGroups
func NewGetSshGroupsRequest(server string, params *GetSshGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshGroupRequest generates requests for GetSshGroup
func NewGetSshGroupRequest(server string, groupID GroupID, params *GetSshGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupID", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshHostsRequest generates requests for GetSshHosts
func NewGetSshHostsRequest(server string, params *GetSshHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Bastion != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bastion", runtime.ParamLocationQuery, *params.Bastion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshHostRequest generates requests for GetSshHost
func NewGetSshHostRequest(server string, hostID HostID, params *GetSshHostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostID", runtime.ParamLocationPath, hostID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPostHostsHostIDTagsRequest calls the generic PostHostsHostIDTags builder with application/json body
func NewPostHostsHostIDTagsRequest(server string, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostHostsHostIDTagsRequestWithBody(server, hostID, params, "application/json", bodyReader)
}

// NewPostHostsHostIDTagsRequestWithBody generates requests for PostHostsHostIDTags with any type of body
func NewPostHostsHostIDTagsRequestWithBody(server string, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostID", runtime.ParamLocationPath, hostID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewUnregisterSshHostRequest generates requests for UnregisterSshHost
func NewUnregisterSshHostRequest(server string, hostID HostID, params *UnregisterSshHostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostID", runtime.ParamLocationPath, hostID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/unregister", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetPlatformsRequest generates requests for GetPlatforms
func NewGetPlatformsRequest(server string, params *GetPlatformsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewPutPlatformRequest calls the generic PutPlatform builder with application/json body
func NewPutPlatformRequest(server string, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPlatformRequestWithBody(server, platformSlug, params, "application/json", bodyReader)
}

// NewPutPlatformRequestWithBody generates requests for PutPlatform with any type of body
func NewPutPlatformRequestWithBody(server string, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platformSlug", runtime.ParamLocationPath, platformSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platforms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshHostTagsRequest generates requests for GetSshHostTags
func NewGetSshHostTagsRequest(server string, params *GetSshHostTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

// NewGetSshUsersRequest generates requests for GetSshUsers
func NewGetSshUsersRequest(server string, params *GetSshUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Pagination != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XRequestId != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, *params.XRequestId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-Id", headerParam0)
	}

	if params.Accept != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", headerParam1)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAttestationAuthorities request
	GetAttestationAuthoritiesWithResponse(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthoritiesResponse, error)

	// PostAttestationAuthorities request with any body
	PostAttestationAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error)

	PostAttestationAuthoritiesWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error)

	// DeleteAttestationAuthority request
	DeleteAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAttestationAuthorityResponse, error)

	// GetAttestationAuthority request
	GetAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthorityResponse, error)

	// PostAuth request with any body
	PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	// GetAuthorities request
	GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error)

	// PostAuthorities request with any body
	PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error)

	// PostAuthoritiesCsr request with any body
	PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error)

	// DeleteAuthority request
	DeleteAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error)

	// GetAuthority request
	GetAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error)

	// ListAuthorityProvisioners request
	ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error)

	// PostAuthorityProvisioners request with any body
	PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error)

	// DeleteProvisioner request
	DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error)

	// GetProvisioner request
	GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error)

	// PostWebhooks request with any body
	PostWebhooksWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	PostWebhooksWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	// DeleteWebhook request
	DeleteWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhook request
	GetWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// PostAuthorityRoot request with any body
	PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error)

	// ListCollections request
	ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error)

	// PostCollections request with any body
	PostCollectionsWithBodyWithResponse(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error)

	PostCollectionsWithResponse(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error)

	// DeleteCollection request
	DeleteCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error)

	// GetCollection request
	GetCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *GetCollectionParams, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error)

	// PutCollection request with any body
	PutCollectionWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionResponse, error)

	PutCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionResponse, error)

	// DeleteCollectionInstance request
	DeleteCollectionInstanceWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *DeleteCollectionInstanceParams, reqEditors ...RequestEditorFn) (*DeleteCollectionInstanceResponse, error)

	// GetCollectionInstance request
	GetCollectionInstanceWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceParams, reqEditors ...RequestEditorFn) (*GetCollectionInstanceResponse, error)

	// PutCollectionInstance request with any body
	PutCollectionInstanceWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionInstanceResponse, error)

	PutCollectionInstanceWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, body PutCollectionInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionInstanceResponse, error)

	// GetCollectionInstanceData request
	GetCollectionInstanceDataWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceDataParams, reqEditors ...RequestEditorFn) (*GetCollectionInstanceDataResponse, error)

	// PutCollectionInstanceData request with any body
	PutCollectionInstanceDataWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionInstanceDataResponse, error)

	PutCollectionInstanceDataWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, body PutCollectionInstanceDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionInstanceDataResponse, error)

	// ListCollectionInstances request
	ListCollectionInstancesWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *ListCollectionInstancesParams, reqEditors ...RequestEditorFn) (*ListCollectionInstancesResponse, error)

	// DeleteDeviceCollection request
	DeleteDeviceCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *DeleteDeviceCollectionParams, reqEditors ...RequestEditorFn) (*DeleteDeviceCollectionResponse, error)

	// GetDeviceCollection request
	GetDeviceCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *GetDeviceCollectionParams, reqEditors ...RequestEditorFn) (*GetDeviceCollectionResponse, error)

	// PutDeviceCollection request with any body
	PutDeviceCollectionWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDeviceCollectionResponse, error)

	PutDeviceCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, body PutDeviceCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDeviceCollectionResponse, error)

	// DeleteWorkload request
	DeleteWorkloadWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *DeleteWorkloadParams, reqEditors ...RequestEditorFn) (*DeleteWorkloadResponse, error)

	// GetWorkload request
	GetWorkloadWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *GetWorkloadParams, reqEditors ...RequestEditorFn) (*GetWorkloadResponse, error)

	// PutWorkload request with any body
	PutWorkloadWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkloadResponse, error)

	PutWorkloadWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, body PutWorkloadJSONRequestBody, reqEditors ...RequestEditorFn) (*PutWorkloadResponse, error)

	// PostDeviceEnrollmentToken request with any body
	PostDeviceEnrollmentTokenWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeviceEnrollmentTokenResponse, error)

	PostDeviceEnrollmentTokenWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, body PostDeviceEnrollmentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeviceEnrollmentTokenResponse, error)

	// GetSshGrants request
	GetSshGrantsWithResponse(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*GetSshGrantsResponse, error)

	// PostSshGrants request with any body
	PostSshGrantsWithBodyWithResponse(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error)

	PostSshGrantsWithResponse(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error)

	// DeleteSshGrant request
	DeleteSshGrantWithResponse(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*DeleteSshGrantResponse, error)

	// GetSshGrant request
	GetSshGrantWithResponse(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*GetSshGrantResponse, error)

	// GetSshGroups request
	GetSshGroupsWithResponse(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*GetSshGroupsResponse, error)

	// GetSshGroup request
	GetSshGroupWithResponse(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*GetSshGroupResponse, error)

	// GetSshHosts request
	GetSshHostsWithResponse(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*GetSshHostsResponse, error)

	// GetSshHost request
	GetSshHostWithResponse(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*GetSshHostResponse, error)

	// PostHostsHostIDTags request with any body
	PostHostsHostIDTagsWithBodyWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error)

	PostHostsHostIDTagsWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error)

	// UnregisterSshHost request
	UnregisterSshHostWithResponse(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*UnregisterSshHostResponse, error)

	// GetPlatforms request
	GetPlatformsWithResponse(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*GetPlatformsResponse, error)

	// PutPlatform request with any body
	PutPlatformWithBodyWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error)

	PutPlatformWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error)

	// GetSshHostTags request
	GetSshHostTagsWithResponse(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*GetSshHostTagsResponse, error)

	// GetSshUsers request
	GetSshUsersWithResponse(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*GetSshUsersResponse, error)
}

type GetAttestationAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AttestationAuthority
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAttestationAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttestationAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAttestationAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AttestationAuthority
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAttestationAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAttestationAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAttestationAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAttestationAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAttestationAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttestationAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AttestationAuthority
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAttestationAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttestationAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Token *string `json:"token,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Authority
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Authority
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthoritiesCsrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthorityCsr
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthoritiesCsrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthoritiesCsrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Provisioner
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityProvisionersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Provisioner
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthorityProvisionersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityProvisionersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProvisionerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Provisioner
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetProvisionerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProvisionerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProvisionerWebhook
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProvisionerWebhook
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorityRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authority
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostAuthorityRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorityRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Collection
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Collection
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionInstance
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCollectionInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionInstance
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutCollectionInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCollectionInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionInstanceDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionInstanceDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionInstanceDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCollectionInstanceDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutCollectionInstanceDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCollectionInstanceDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollectionInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CollectionInstance
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCollectionInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollectionInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceCollection
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetDeviceCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDeviceCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceCollection
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutDeviceCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDeviceCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteWorkloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workload
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetWorkloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutWorkloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workload
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutWorkloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutWorkloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDeviceEnrollmentTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EnrollmentToken
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON412      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostDeviceEnrollmentTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDeviceEnrollmentTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Grant
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSshGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Grant
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSshGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSshGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSshGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSshGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSshGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Grant
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Host
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Host
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHostsHostIDTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Tag
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostHostsHostIDTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHostsHostIDTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterSshHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Host
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UnregisterSshHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterSshHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Platform
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPlatformsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Platform
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshHostTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tag
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshHostTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshHostTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSshUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAttestationAuthoritiesWithResponse request returning *GetAttestationAuthoritiesResponse
func (c *ClientWithResponses) GetAttestationAuthoritiesWithResponse(ctx context.Context, params *GetAttestationAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthoritiesResponse, error) {
	rsp, err := c.GetAttestationAuthorities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttestationAuthoritiesResponse(rsp)
}

// PostAttestationAuthoritiesWithBodyWithResponse request with arbitrary body returning *PostAttestationAuthoritiesResponse
func (c *ClientWithResponses) PostAttestationAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error) {
	rsp, err := c.PostAttestationAuthoritiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttestationAuthoritiesResponse(rsp)
}

func (c *ClientWithResponses) PostAttestationAuthoritiesWithResponse(ctx context.Context, params *PostAttestationAuthoritiesParams, body PostAttestationAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAttestationAuthoritiesResponse, error) {
	rsp, err := c.PostAttestationAuthorities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAttestationAuthoritiesResponse(rsp)
}

// DeleteAttestationAuthorityWithResponse request returning *DeleteAttestationAuthorityResponse
func (c *ClientWithResponses) DeleteAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *DeleteAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAttestationAuthorityResponse, error) {
	rsp, err := c.DeleteAttestationAuthority(ctx, attestationAuthorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAttestationAuthorityResponse(rsp)
}

// GetAttestationAuthorityWithResponse request returning *GetAttestationAuthorityResponse
func (c *ClientWithResponses) GetAttestationAuthorityWithResponse(ctx context.Context, attestationAuthorityID AttestationAuthorityID, params *GetAttestationAuthorityParams, reqEditors ...RequestEditorFn) (*GetAttestationAuthorityResponse, error) {
	rsp, err := c.GetAttestationAuthority(ctx, attestationAuthorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttestationAuthorityResponse(rsp)
}

// PostAuthWithBodyWithResponse request with arbitrary body returning *PostAuthResponse
func (c *ClientWithResponses) PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

func (c *ClientWithResponses) PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

// GetAuthoritiesWithResponse request returning *GetAuthoritiesResponse
func (c *ClientWithResponses) GetAuthoritiesWithResponse(ctx context.Context, params *GetAuthoritiesParams, reqEditors ...RequestEditorFn) (*GetAuthoritiesResponse, error) {
	rsp, err := c.GetAuthorities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthoritiesResponse(rsp)
}

// PostAuthoritiesWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesResponse
func (c *ClientWithResponses) PostAuthoritiesWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthoritiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesWithResponse(ctx context.Context, params *PostAuthoritiesParams, body PostAuthoritiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesResponse, error) {
	rsp, err := c.PostAuthorities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesResponse(rsp)
}

// PostAuthoritiesCsrWithBodyWithResponse request with arbitrary body returning *PostAuthoritiesCsrResponse
func (c *ClientWithResponses) PostAuthoritiesCsrWithBodyWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsrWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

func (c *ClientWithResponses) PostAuthoritiesCsrWithResponse(ctx context.Context, params *PostAuthoritiesCsrParams, body PostAuthoritiesCsrJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthoritiesCsrResponse, error) {
	rsp, err := c.PostAuthoritiesCsr(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthoritiesCsrResponse(rsp)
}

// DeleteAuthorityWithResponse request returning *DeleteAuthorityResponse
func (c *ClientWithResponses) DeleteAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *DeleteAuthorityParams, reqEditors ...RequestEditorFn) (*DeleteAuthorityResponse, error) {
	rsp, err := c.DeleteAuthority(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorityResponse(rsp)
}

// GetAuthorityWithResponse request returning *GetAuthorityResponse
func (c *ClientWithResponses) GetAuthorityWithResponse(ctx context.Context, authorityID AuthorityID, params *GetAuthorityParams, reqEditors ...RequestEditorFn) (*GetAuthorityResponse, error) {
	rsp, err := c.GetAuthority(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorityResponse(rsp)
}

// ListAuthorityProvisionersWithResponse request returning *ListAuthorityProvisionersResponse
func (c *ClientWithResponses) ListAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *ListAuthorityProvisionersParams, reqEditors ...RequestEditorFn) (*ListAuthorityProvisionersResponse, error) {
	rsp, err := c.ListAuthorityProvisioners(ctx, authorityID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthorityProvisionersResponse(rsp)
}

// PostAuthorityProvisionersWithBodyWithResponse request with arbitrary body returning *PostAuthorityProvisionersResponse
func (c *ClientWithResponses) PostAuthorityProvisionersWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisionersWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityProvisionersWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityProvisionersParams, body PostAuthorityProvisionersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityProvisionersResponse, error) {
	rsp, err := c.PostAuthorityProvisioners(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityProvisionersResponse(rsp)
}

// DeleteProvisionerWithResponse request returning *DeleteProvisionerResponse
func (c *ClientWithResponses) DeleteProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *DeleteProvisionerParams, reqEditors ...RequestEditorFn) (*DeleteProvisionerResponse, error) {
	rsp, err := c.DeleteProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProvisionerResponse(rsp)
}

// GetProvisionerWithResponse request returning *GetProvisionerResponse
func (c *ClientWithResponses) GetProvisionerWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *GetProvisionerParams, reqEditors ...RequestEditorFn) (*GetProvisionerResponse, error) {
	rsp, err := c.GetProvisioner(ctx, authorityID, provisionerNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProvisionerResponse(rsp)
}

// PostWebhooksWithBodyWithResponse request with arbitrary body returning *PostWebhooksResponse
func (c *ClientWithResponses) PostWebhooksWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooksWithBody(ctx, authorityID, provisionerNameOrID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

func (c *ClientWithResponses) PostWebhooksWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params *PostWebhooksParams, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooks(ctx, authorityID, provisionerNameOrID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, authorityID, provisionerNameOrID, webhookNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, authorityID, provisionerNameOrID, webhookNameOrID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// PostAuthorityRootWithBodyWithResponse request with arbitrary body returning *PostAuthorityRootResponse
func (c *ClientWithResponses) PostAuthorityRootWithBodyWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRootWithBody(ctx, authorityID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorityRootWithResponse(ctx context.Context, authorityID AuthorityID, params *PostAuthorityRootParams, body PostAuthorityRootJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorityRootResponse, error) {
	rsp, err := c.PostAuthorityRoot(ctx, authorityID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorityRootResponse(rsp)
}

// ListCollectionsWithResponse request returning *ListCollectionsResponse
func (c *ClientWithResponses) ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error) {
	rsp, err := c.ListCollections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollectionsResponse(rsp)
}

// PostCollectionsWithBodyWithResponse request with arbitrary body returning *PostCollectionsResponse
func (c *ClientWithResponses) PostCollectionsWithBodyWithResponse(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error) {
	rsp, err := c.PostCollectionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsResponse(rsp)
}

func (c *ClientWithResponses) PostCollectionsWithResponse(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error) {
	rsp, err := c.PostCollections(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsResponse(rsp)
}

// DeleteCollectionWithResponse request returning *DeleteCollectionResponse
func (c *ClientWithResponses) DeleteCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error) {
	rsp, err := c.DeleteCollection(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionResponse(rsp)
}

// GetCollectionWithResponse request returning *GetCollectionResponse
func (c *ClientWithResponses) GetCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *GetCollectionParams, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error) {
	rsp, err := c.GetCollection(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionResponse(rsp)
}

// PutCollectionWithBodyWithResponse request with arbitrary body returning *PutCollectionResponse
func (c *ClientWithResponses) PutCollectionWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionResponse, error) {
	rsp, err := c.PutCollectionWithBody(ctx, collectionSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionResponse(rsp)
}

func (c *ClientWithResponses) PutCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutCollectionParams, body PutCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionResponse, error) {
	rsp, err := c.PutCollection(ctx, collectionSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionResponse(rsp)
}

// DeleteCollectionInstanceWithResponse request returning *DeleteCollectionInstanceResponse
func (c *ClientWithResponses) DeleteCollectionInstanceWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *DeleteCollectionInstanceParams, reqEditors ...RequestEditorFn) (*DeleteCollectionInstanceResponse, error) {
	rsp, err := c.DeleteCollectionInstance(ctx, collectionSlug, instanceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionInstanceResponse(rsp)
}

// GetCollectionInstanceWithResponse request returning *GetCollectionInstanceResponse
func (c *ClientWithResponses) GetCollectionInstanceWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceParams, reqEditors ...RequestEditorFn) (*GetCollectionInstanceResponse, error) {
	rsp, err := c.GetCollectionInstance(ctx, collectionSlug, instanceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionInstanceResponse(rsp)
}

// PutCollectionInstanceWithBodyWithResponse request with arbitrary body returning *PutCollectionInstanceResponse
func (c *ClientWithResponses) PutCollectionInstanceWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionInstanceResponse, error) {
	rsp, err := c.PutCollectionInstanceWithBody(ctx, collectionSlug, instanceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionInstanceResponse(rsp)
}

func (c *ClientWithResponses) PutCollectionInstanceWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceParams, body PutCollectionInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionInstanceResponse, error) {
	rsp, err := c.PutCollectionInstance(ctx, collectionSlug, instanceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionInstanceResponse(rsp)
}

// GetCollectionInstanceDataWithResponse request returning *GetCollectionInstanceDataResponse
func (c *ClientWithResponses) GetCollectionInstanceDataWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *GetCollectionInstanceDataParams, reqEditors ...RequestEditorFn) (*GetCollectionInstanceDataResponse, error) {
	rsp, err := c.GetCollectionInstanceData(ctx, collectionSlug, instanceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionInstanceDataResponse(rsp)
}

// PutCollectionInstanceDataWithBodyWithResponse request with arbitrary body returning *PutCollectionInstanceDataResponse
func (c *ClientWithResponses) PutCollectionInstanceDataWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutCollectionInstanceDataResponse, error) {
	rsp, err := c.PutCollectionInstanceDataWithBody(ctx, collectionSlug, instanceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionInstanceDataResponse(rsp)
}

func (c *ClientWithResponses) PutCollectionInstanceDataWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PutCollectionInstanceDataParams, body PutCollectionInstanceDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PutCollectionInstanceDataResponse, error) {
	rsp, err := c.PutCollectionInstanceData(ctx, collectionSlug, instanceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutCollectionInstanceDataResponse(rsp)
}

// ListCollectionInstancesWithResponse request returning *ListCollectionInstancesResponse
func (c *ClientWithResponses) ListCollectionInstancesWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *ListCollectionInstancesParams, reqEditors ...RequestEditorFn) (*ListCollectionInstancesResponse, error) {
	rsp, err := c.ListCollectionInstances(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollectionInstancesResponse(rsp)
}

// DeleteDeviceCollectionWithResponse request returning *DeleteDeviceCollectionResponse
func (c *ClientWithResponses) DeleteDeviceCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *DeleteDeviceCollectionParams, reqEditors ...RequestEditorFn) (*DeleteDeviceCollectionResponse, error) {
	rsp, err := c.DeleteDeviceCollection(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceCollectionResponse(rsp)
}

// GetDeviceCollectionWithResponse request returning *GetDeviceCollectionResponse
func (c *ClientWithResponses) GetDeviceCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *GetDeviceCollectionParams, reqEditors ...RequestEditorFn) (*GetDeviceCollectionResponse, error) {
	rsp, err := c.GetDeviceCollection(ctx, collectionSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceCollectionResponse(rsp)
}

// PutDeviceCollectionWithBodyWithResponse request with arbitrary body returning *PutDeviceCollectionResponse
func (c *ClientWithResponses) PutDeviceCollectionWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDeviceCollectionResponse, error) {
	rsp, err := c.PutDeviceCollectionWithBody(ctx, collectionSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDeviceCollectionResponse(rsp)
}

func (c *ClientWithResponses) PutDeviceCollectionWithResponse(ctx context.Context, collectionSlug CollectionSlug, params *PutDeviceCollectionParams, body PutDeviceCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDeviceCollectionResponse, error) {
	rsp, err := c.PutDeviceCollection(ctx, collectionSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDeviceCollectionResponse(rsp)
}

// DeleteWorkloadWithResponse request returning *DeleteWorkloadResponse
func (c *ClientWithResponses) DeleteWorkloadWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *DeleteWorkloadParams, reqEditors ...RequestEditorFn) (*DeleteWorkloadResponse, error) {
	rsp, err := c.DeleteWorkload(ctx, collectionSlug, workloadSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkloadResponse(rsp)
}

// GetWorkloadWithResponse request returning *GetWorkloadResponse
func (c *ClientWithResponses) GetWorkloadWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *GetWorkloadParams, reqEditors ...RequestEditorFn) (*GetWorkloadResponse, error) {
	rsp, err := c.GetWorkload(ctx, collectionSlug, workloadSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkloadResponse(rsp)
}

// PutWorkloadWithBodyWithResponse request with arbitrary body returning *PutWorkloadResponse
func (c *ClientWithResponses) PutWorkloadWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutWorkloadResponse, error) {
	rsp, err := c.PutWorkloadWithBody(ctx, collectionSlug, workloadSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkloadResponse(rsp)
}

func (c *ClientWithResponses) PutWorkloadWithResponse(ctx context.Context, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params *PutWorkloadParams, body PutWorkloadJSONRequestBody, reqEditors ...RequestEditorFn) (*PutWorkloadResponse, error) {
	rsp, err := c.PutWorkload(ctx, collectionSlug, workloadSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutWorkloadResponse(rsp)
}

// PostDeviceEnrollmentTokenWithBodyWithResponse request with arbitrary body returning *PostDeviceEnrollmentTokenResponse
func (c *ClientWithResponses) PostDeviceEnrollmentTokenWithBodyWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDeviceEnrollmentTokenResponse, error) {
	rsp, err := c.PostDeviceEnrollmentTokenWithBody(ctx, collectionSlug, instanceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeviceEnrollmentTokenResponse(rsp)
}

func (c *ClientWithResponses) PostDeviceEnrollmentTokenWithResponse(ctx context.Context, collectionSlug CollectionSlug, instanceID InstanceID, params *PostDeviceEnrollmentTokenParams, body PostDeviceEnrollmentTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDeviceEnrollmentTokenResponse, error) {
	rsp, err := c.PostDeviceEnrollmentToken(ctx, collectionSlug, instanceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDeviceEnrollmentTokenResponse(rsp)
}

// GetSshGrantsWithResponse request returning *GetSshGrantsResponse
func (c *ClientWithResponses) GetSshGrantsWithResponse(ctx context.Context, params *GetSshGrantsParams, reqEditors ...RequestEditorFn) (*GetSshGrantsResponse, error) {
	rsp, err := c.GetSshGrants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGrantsResponse(rsp)
}

// PostSshGrantsWithBodyWithResponse request with arbitrary body returning *PostSshGrantsResponse
func (c *ClientWithResponses) PostSshGrantsWithBodyWithResponse(ctx context.Context, params *PostSshGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error) {
	rsp, err := c.PostSshGrantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSshGrantsResponse(rsp)
}

func (c *ClientWithResponses) PostSshGrantsWithResponse(ctx context.Context, params *PostSshGrantsParams, body PostSshGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSshGrantsResponse, error) {
	rsp, err := c.PostSshGrants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSshGrantsResponse(rsp)
}

// DeleteSshGrantWithResponse request returning *DeleteSshGrantResponse
func (c *ClientWithResponses) DeleteSshGrantWithResponse(ctx context.Context, grantID GrantID, params *DeleteSshGrantParams, reqEditors ...RequestEditorFn) (*DeleteSshGrantResponse, error) {
	rsp, err := c.DeleteSshGrant(ctx, grantID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSshGrantResponse(rsp)
}

// GetSshGrantWithResponse request returning *GetSshGrantResponse
func (c *ClientWithResponses) GetSshGrantWithResponse(ctx context.Context, grantID GrantID, params *GetSshGrantParams, reqEditors ...RequestEditorFn) (*GetSshGrantResponse, error) {
	rsp, err := c.GetSshGrant(ctx, grantID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGrantResponse(rsp)
}

// GetSshGroupsWithResponse request returning *GetSshGroupsResponse
func (c *ClientWithResponses) GetSshGroupsWithResponse(ctx context.Context, params *GetSshGroupsParams, reqEditors ...RequestEditorFn) (*GetSshGroupsResponse, error) {
	rsp, err := c.GetSshGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGroupsResponse(rsp)
}

// GetSshGroupWithResponse request returning *GetSshGroupResponse
func (c *ClientWithResponses) GetSshGroupWithResponse(ctx context.Context, groupID GroupID, params *GetSshGroupParams, reqEditors ...RequestEditorFn) (*GetSshGroupResponse, error) {
	rsp, err := c.GetSshGroup(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshGroupResponse(rsp)
}

// GetSshHostsWithResponse request returning *GetSshHostsResponse
func (c *ClientWithResponses) GetSshHostsWithResponse(ctx context.Context, params *GetSshHostsParams, reqEditors ...RequestEditorFn) (*GetSshHostsResponse, error) {
	rsp, err := c.GetSshHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshHostsResponse(rsp)
}

// GetSshHostWithResponse request returning *GetSshHostResponse
func (c *ClientWithResponses) GetSshHostWithResponse(ctx context.Context, hostID HostID, params *GetSshHostParams, reqEditors ...RequestEditorFn) (*GetSshHostResponse, error) {
	rsp, err := c.GetSshHost(ctx, hostID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshHostResponse(rsp)
}

// PostHostsHostIDTagsWithBodyWithResponse request with arbitrary body returning *PostHostsHostIDTagsResponse
func (c *ClientWithResponses) PostHostsHostIDTagsWithBodyWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error) {
	rsp, err := c.PostHostsHostIDTagsWithBody(ctx, hostID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostsHostIDTagsResponse(rsp)
}

func (c *ClientWithResponses) PostHostsHostIDTagsWithResponse(ctx context.Context, hostID HostID, params *PostHostsHostIDTagsParams, body PostHostsHostIDTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostHostsHostIDTagsResponse, error) {
	rsp, err := c.PostHostsHostIDTags(ctx, hostID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHostsHostIDTagsResponse(rsp)
}

// UnregisterSshHostWithResponse request returning *UnregisterSshHostResponse
func (c *ClientWithResponses) UnregisterSshHostWithResponse(ctx context.Context, hostID HostID, params *UnregisterSshHostParams, reqEditors ...RequestEditorFn) (*UnregisterSshHostResponse, error) {
	rsp, err := c.UnregisterSshHost(ctx, hostID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterSshHostResponse(rsp)
}

// GetPlatformsWithResponse request returning *GetPlatformsResponse
func (c *ClientWithResponses) GetPlatformsWithResponse(ctx context.Context, params *GetPlatformsParams, reqEditors ...RequestEditorFn) (*GetPlatformsResponse, error) {
	rsp, err := c.GetPlatforms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformsResponse(rsp)
}

// PutPlatformWithBodyWithResponse request with arbitrary body returning *PutPlatformResponse
func (c *ClientWithResponses) PutPlatformWithBodyWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error) {
	rsp, err := c.PutPlatformWithBody(ctx, platformSlug, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlatformResponse(rsp)
}

func (c *ClientWithResponses) PutPlatformWithResponse(ctx context.Context, platformSlug PlatformSlug, params *PutPlatformParams, body PutPlatformJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlatformResponse, error) {
	rsp, err := c.PutPlatform(ctx, platformSlug, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlatformResponse(rsp)
}

// GetSshHostTagsWithResponse request returning *GetSshHostTagsResponse
func (c *ClientWithResponses) GetSshHostTagsWithResponse(ctx context.Context, params *GetSshHostTagsParams, reqEditors ...RequestEditorFn) (*GetSshHostTagsResponse, error) {
	rsp, err := c.GetSshHostTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshHostTagsResponse(rsp)
}

// GetSshUsersWithResponse request returning *GetSshUsersResponse
func (c *ClientWithResponses) GetSshUsersWithResponse(ctx context.Context, params *GetSshUsersParams, reqEditors ...RequestEditorFn) (*GetSshUsersResponse, error) {
	rsp, err := c.GetSshUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshUsersResponse(rsp)
}

// ParseGetAttestationAuthoritiesResponse parses an HTTP response from a GetAttestationAuthoritiesWithResponse call
func ParseGetAttestationAuthoritiesResponse(rsp *http.Response) (*GetAttestationAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttestationAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AttestationAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAttestationAuthoritiesResponse parses an HTTP response from a PostAttestationAuthoritiesWithResponse call
func ParsePostAttestationAuthoritiesResponse(rsp *http.Response) (*PostAttestationAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAttestationAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AttestationAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAttestationAuthorityResponse parses an HTTP response from a DeleteAttestationAuthorityWithResponse call
func ParseDeleteAttestationAuthorityResponse(rsp *http.Response) (*DeleteAttestationAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAttestationAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAttestationAuthorityResponse parses an HTTP response from a GetAttestationAuthorityWithResponse call
func ParseGetAttestationAuthorityResponse(rsp *http.Response) (*GetAttestationAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttestationAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AttestationAuthority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthResponse parses an HTTP response from a PostAuthWithResponse call
func ParsePostAuthResponse(rsp *http.Response) (*PostAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthoritiesResponse parses an HTTP response from a GetAuthoritiesWithResponse call
func ParseGetAuthoritiesResponse(rsp *http.Response) (*GetAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesResponse parses an HTTP response from a PostAuthoritiesWithResponse call
func ParsePostAuthoritiesResponse(rsp *http.Response) (*PostAuthoritiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthoritiesCsrResponse parses an HTTP response from a PostAuthoritiesCsrWithResponse call
func ParsePostAuthoritiesCsrResponse(rsp *http.Response) (*PostAuthoritiesCsrResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthoritiesCsrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthorityCsr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorityResponse parses an HTTP response from a DeleteAuthorityWithResponse call
func ParseDeleteAuthorityResponse(rsp *http.Response) (*DeleteAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthorityResponse parses an HTTP response from a GetAuthorityWithResponse call
func ParseGetAuthorityResponse(rsp *http.Response) (*GetAuthorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuthorityProvisionersResponse parses an HTTP response from a ListAuthorityProvisionersWithResponse call
func ParseListAuthorityProvisionersResponse(rsp *http.Response) (*ListAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityProvisionersResponse parses an HTTP response from a PostAuthorityProvisionersWithResponse call
func ParsePostAuthorityProvisionersResponse(rsp *http.Response) (*PostAuthorityProvisionersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityProvisionersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProvisionerResponse parses an HTTP response from a DeleteProvisionerWithResponse call
func ParseDeleteProvisionerResponse(rsp *http.Response) (*DeleteProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProvisionerResponse parses an HTTP response from a GetProvisionerWithResponse call
func ParseGetProvisionerResponse(rsp *http.Response) (*GetProvisionerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProvisionerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Provisioner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWebhooksResponse parses an HTTP response from a PostWebhooksWithResponse call
func ParsePostWebhooksResponse(rsp *http.Response) (*PostWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProvisionerWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProvisionerWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthorityRootResponse parses an HTTP response from a PostAuthorityRootWithResponse call
func ParsePostAuthorityRootResponse(rsp *http.Response) (*PostAuthorityRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorityRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authority
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCollectionsResponse parses an HTTP response from a ListCollectionsWithResponse call
func ParseListCollectionsResponse(rsp *http.Response) (*ListCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionsResponse parses an HTTP response from a PostCollectionsWithResponse call
func ParsePostCollectionsResponse(rsp *http.Response) (*PostCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionResponse parses an HTTP response from a DeleteCollectionWithResponse call
func ParseDeleteCollectionResponse(rsp *http.Response) (*DeleteCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionResponse parses an HTTP response from a GetCollectionWithResponse call
func ParseGetCollectionResponse(rsp *http.Response) (*GetCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutCollectionResponse parses an HTTP response from a PutCollectionWithResponse call
func ParsePutCollectionResponse(rsp *http.Response) (*PutCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionInstanceResponse parses an HTTP response from a DeleteCollectionInstanceWithResponse call
func ParseDeleteCollectionInstanceResponse(rsp *http.Response) (*DeleteCollectionInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionInstanceResponse parses an HTTP response from a GetCollectionInstanceWithResponse call
func ParseGetCollectionInstanceResponse(rsp *http.Response) (*GetCollectionInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutCollectionInstanceResponse parses an HTTP response from a PutCollectionInstanceWithResponse call
func ParsePutCollectionInstanceResponse(rsp *http.Response) (*PutCollectionInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutCollectionInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionInstanceDataResponse parses an HTTP response from a GetCollectionInstanceDataWithResponse call
func ParseGetCollectionInstanceDataResponse(rsp *http.Response) (*GetCollectionInstanceDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionInstanceDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutCollectionInstanceDataResponse parses an HTTP response from a PutCollectionInstanceDataWithResponse call
func ParsePutCollectionInstanceDataResponse(rsp *http.Response) (*PutCollectionInstanceDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutCollectionInstanceDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCollectionInstancesResponse parses an HTTP response from a ListCollectionInstancesWithResponse call
func ParseListCollectionInstancesResponse(rsp *http.Response) (*ListCollectionInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollectionInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CollectionInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDeviceCollectionResponse parses an HTTP response from a DeleteDeviceCollectionWithResponse call
func ParseDeleteDeviceCollectionResponse(rsp *http.Response) (*DeleteDeviceCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDeviceCollectionResponse parses an HTTP response from a GetDeviceCollectionWithResponse call
func ParseGetDeviceCollectionResponse(rsp *http.Response) (*GetDeviceCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutDeviceCollectionResponse parses an HTTP response from a PutDeviceCollectionWithResponse call
func ParsePutDeviceCollectionResponse(rsp *http.Response) (*PutDeviceCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDeviceCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteWorkloadResponse parses an HTTP response from a DeleteWorkloadWithResponse call
func ParseDeleteWorkloadResponse(rsp *http.Response) (*DeleteWorkloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkloadResponse parses an HTTP response from a GetWorkloadWithResponse call
func ParseGetWorkloadResponse(rsp *http.Response) (*GetWorkloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutWorkloadResponse parses an HTTP response from a PutWorkloadWithResponse call
func ParsePutWorkloadResponse(rsp *http.Response) (*PutWorkloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutWorkloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDeviceEnrollmentTokenResponse parses an HTTP response from a PostDeviceEnrollmentTokenWithResponse call
func ParsePostDeviceEnrollmentTokenResponse(rsp *http.Response) (*PostDeviceEnrollmentTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDeviceEnrollmentTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EnrollmentToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGrantsResponse parses an HTTP response from a GetSshGrantsWithResponse call
func ParseGetSshGrantsResponse(rsp *http.Response) (*GetSshGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Grant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSshGrantsResponse parses an HTTP response from a PostSshGrantsWithResponse call
func ParsePostSshGrantsResponse(rsp *http.Response) (*PostSshGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSshGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Grant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSshGrantResponse parses an HTTP response from a DeleteSshGrantWithResponse call
func ParseDeleteSshGrantResponse(rsp *http.Response) (*DeleteSshGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSshGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGrantResponse parses an HTTP response from a GetSshGrantWithResponse call
func ParseGetSshGrantResponse(rsp *http.Response) (*GetSshGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Grant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGroupsResponse parses an HTTP response from a GetSshGroupsWithResponse call
func ParseGetSshGroupsResponse(rsp *http.Response) (*GetSshGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshGroupResponse parses an HTTP response from a GetSshGroupWithResponse call
func ParseGetSshGroupResponse(rsp *http.Response) (*GetSshGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshHostsResponse parses an HTTP response from a GetSshHostsWithResponse call
func ParseGetSshHostsResponse(rsp *http.Response) (*GetSshHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshHostResponse parses an HTTP response from a GetSshHostWithResponse call
func ParseGetSshHostResponse(rsp *http.Response) (*GetSshHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostHostsHostIDTagsResponse parses an HTTP response from a PostHostsHostIDTagsWithResponse call
func ParsePostHostsHostIDTagsResponse(rsp *http.Response) (*PostHostsHostIDTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHostsHostIDTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterSshHostResponse parses an HTTP response from a UnregisterSshHostWithResponse call
func ParseUnregisterSshHostResponse(rsp *http.Response) (*UnregisterSshHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterSshHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformsResponse parses an HTTP response from a GetPlatformsWithResponse call
func ParseGetPlatformsResponse(rsp *http.Response) (*GetPlatformsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Platform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutPlatformResponse parses an HTTP response from a PutPlatformWithResponse call
func ParsePutPlatformResponse(rsp *http.Response) (*PutPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Platform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshHostTagsResponse parses an HTTP response from a GetSshHostTagsWithResponse call
func ParseGetSshHostTagsResponse(rsp *http.Response) (*GetSshHostTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshHostTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSshUsersResponse parses an HTTP response from a GetSshUsersWithResponse call
func ParseGetSshUsersResponse(rsp *http.Response) (*GetSshUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
