// Package v20230301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20230301

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for ProvisionerType.
const (
	JWK  ProvisionerType = "JWK"
	OIDC ProvisionerType = "OIDC"
)

// Defines values for WebhookCertType.
const (
	ALL  WebhookCertType = "ALL"
	SSH  WebhookCertType = "SSH"
	X509 WebhookCertType = "X509"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// Authority An X509 authority hosted by Smallstep
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only)
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority
	Id string `json:"id"`

	// Name The name of the authority
	Name string `json:"name"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error
	Message string `json:"message"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group
	Id *string `json:"id,omitempty"`

	// Name The name of the group
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp when the host was registered
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp when the host was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Inventory A collection of items
type Inventory struct {
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the inventory
	DisplayName string `json:"displayName"`

	// ItemCount The number of items in the inventory
	ItemCount int `json:"itemCount"`

	// Slug A lowercase name identifying the inventory.
	Slug      string    `json:"slug"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// InventoryItem An item in an inventory
type InventoryItem struct {
	// CreatedAt Timestamp of when the item was added to the inventory
	CreatedAt time.Time `json:"createdAt"`

	// Data The item data
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp of when the item was last changed
	UpdatedAt time.Time `json:"updatedAt"`
}

// JwkProvisioner defines model for jwkProvisioner.
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key
	Key interface{} `json:"key"`
}

// NameConstraints defines model for name-constraints.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewInventory A collection of items
type NewInventory struct {
	// DisplayName A user-friendly name for the inventory
	DisplayName *string `json:"displayName,omitempty"`

	// Slug A lowercase name identifying the inventory.
	Slug string `json:"slug"`
}

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// OidcProvisioner defines model for oidcProvisioner.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user
	Username *string `json:"username,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh *SshOptions `json:"ssh,omitempty"`

	// Webhooks Configuration for a webhook to be called when issuing certificates with this provisioner
	Webhooks *Webhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates
	X509 *X509Options `json:"x509,omitempty"`
}

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// Webhook Configuration for a webhook to be called when issuing certificates with this provisioner
type Webhook struct {
	// CertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
	CertType *WebhookCertType `json:"certType,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the webhook.
	Name *string `json:"name,omitempty"`

	// Url The URL of the webhook server.
	Url *string `json:"url,omitempty"`
}

// WebhookCertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
type WebhookCertType string

// X509Issuer A Customized X509 issuer for an authority
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer
	Name            string           `json:"name"`
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Accept defines model for accept.
type Accept = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InventorySlug defines model for inventorySlug.
type InventorySlug = string

// ItemID defines model for itemID.
type ItemID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N500 defines model for 500.
type N500 = Error

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to true the results will only include active hosts. If set to false the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to true the results will include only bastion hosts and if set to false the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoriesParams defines parameters for ListInventories.
type ListInventoriesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostInventoriesParams defines parameters for PostInventories.
type PostInventoriesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryParams defines parameters for DeleteInventory.
type DeleteInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryParams defines parameters for GetInventory.
type GetInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoryItemsParams defines parameters for ListInventoryItems.
type ListInventoryItemsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryItemParams defines parameters for DeleteInventoryItem.
type DeleteInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemParams defines parameters for GetInventoryItem.
type GetInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemJSONBody defines parameters for PutInventoryItem.
type PutInventoryItemJSONBody struct {
	Data interface{} `json:"data"`
}

// PutInventoryItemParams defines parameters for PutInventoryItem.
type PutInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemDataParams defines parameters for GetInventoryItemData.
type GetInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemDataJSONBody defines parameters for PutInventoryItemData.
type PutInventoryItemDataJSONBody = interface{}

// PutInventoryItemDataParams defines parameters for PutInventoryItemData.
type PutInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PostInventoriesJSONRequestBody defines body for PostInventories for application/json ContentType.
type PostInventoriesJSONRequestBody = NewInventory

// PutInventoryItemJSONRequestBody defines body for PutInventoryItem for application/json ContentType.
type PutInventoryItemJSONRequestBody PutInventoryItemJSONBody

// PutInventoryItemDataJSONRequestBody defines body for PutInventoryItemData for application/json ContentType.
type PutInventoryItemDataJSONRequestBody = PutInventoryItemDataJSONBody

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate
	// (POST /auth)
	PostAuth(w http.ResponseWriter, r *http.Request)
	// List Authorities
	// (GET /authorities)
	GetAuthorities(w http.ResponseWriter, r *http.Request, params GetAuthoritiesParams)
	// Create New Authority
	// (POST /authorities)
	PostAuthorities(w http.ResponseWriter, r *http.Request, params PostAuthoritiesParams)
	// Create New Authority CSR
	// (POST /authorities/csr)
	PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request, params PostAuthoritiesCsrParams)
	// Delete Authority
	// (DELETE /authorities/{authorityID})
	DeleteAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params DeleteAuthorityParams)
	// Get Authority
	// (GET /authorities/{authorityID})
	GetAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params GetAuthorityParams)
	// List Authority Provisioners
	// (GET /authorities/{authorityID}/provisioners)
	ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params ListAuthorityProvisionersParams)
	// Create Authority Provisioner
	// (POST /authorities/{authorityID}/provisioners)
	PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityProvisionersParams)
	// Delete Provisioner
	// (DELETE /authorities/{authorityID}/provisioners/{provisionerNameOrID})
	DeleteProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params DeleteProvisionerParams)
	// Get Provisioner
	// (GET /authorities/{authorityID}/provisioners/{provisionerNameOrID})
	GetProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params GetProvisionerParams)
	// Post Authority External Root
	// (POST /authorities/{authorityID}/root)
	PostAuthorityRoot(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityRootParams)
	// Get SSH Grants
	// (GET /grants)
	GetSshGrants(w http.ResponseWriter, r *http.Request, params GetSshGrantsParams)
	// Create SSH Grant
	// (POST /grants)
	PostSshGrants(w http.ResponseWriter, r *http.Request, params PostSshGrantsParams)
	// Delete SSH Grant
	// (DELETE /grants/{grantID})
	DeleteSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params DeleteSshGrantParams)
	// Get SSH Grant
	// (GET /grants/{grantID})
	GetSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params GetSshGrantParams)
	// Get SSH Groups
	// (GET /groups)
	GetSshGroups(w http.ResponseWriter, r *http.Request, params GetSshGroupsParams)
	// Get SSH Group
	// (GET /groups/{groupID})
	GetSshGroup(w http.ResponseWriter, r *http.Request, groupID GroupID, params GetSshGroupParams)
	// Get SSH Hosts
	// (GET /hosts)
	GetSshHosts(w http.ResponseWriter, r *http.Request, params GetSshHostsParams)
	// Get SSH Host
	// (GET /hosts/{hostID})
	GetSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params GetSshHostParams)
	// Tag SSH Host
	// (POST /hosts/{hostID}/tags)
	PostHostsHostIDTags(w http.ResponseWriter, r *http.Request, hostID HostID, params PostHostsHostIDTagsParams)
	// Unregister SSH Host
	// (POST /hosts/{hostID}/unregister)
	UnregisterSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params UnregisterSshHostParams)
	// List Inventories
	// (GET /inventories)
	ListInventories(w http.ResponseWriter, r *http.Request, params ListInventoriesParams)
	// Create an Inventory
	// (POST /inventories)
	PostInventories(w http.ResponseWriter, r *http.Request, params PostInventoriesParams)
	// Delete Inventory
	// (DELETE /inventories/{inventorySlug})
	DeleteInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params DeleteInventoryParams)
	// Get Inventory
	// (GET /inventories/{inventorySlug})
	GetInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params GetInventoryParams)
	// List Inventory Items
	// (GET /inventories/{inventorySlug}/items)
	ListInventoryItems(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params ListInventoryItemsParams)
	// Delete Inventory Item
	// (DELETE /inventories/{inventorySlug}/items/{itemID})
	DeleteInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params DeleteInventoryItemParams)
	// Get Inventory Item
	// (GET /inventories/{inventorySlug}/items/{itemID})
	GetInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemParams)
	// Save Inventory Item
	// (PUT /inventories/{inventorySlug}/items/{itemID})
	PutInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemParams)
	// Get Inventory Item Data
	// (GET /inventories/{inventorySlug}/items/{itemID}/data)
	GetInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemDataParams)
	// Save Inventory Item Data
	// (PUT /inventories/{inventorySlug}/items/{itemID}/data)
	PutInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemDataParams)
	// Get SSH Host Tags
	// (GET /tags)
	GetSshHostTags(w http.ResponseWriter, r *http.Request, params GetSshHostTagsParams)
	// Get SSH Users
	// (GET /users)
	GetSshUsers(w http.ResponseWriter, r *http.Request, params GetSshUsersParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuth operation middleware
func (siw *ServerInterfaceWrapper) PostAuth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, MtlsScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuth(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthoritiesCsr operation middleware
func (siw *ServerInterfaceWrapper) PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesCsrParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthoritiesCsr(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteProvisioner operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvisioner(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetProvisioner operation middleware
func (siw *ServerInterfaceWrapper) GetProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvisioner(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityRoot operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityRoot(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityRootParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityRoot(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrants operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostSshGrants operation middleware
func (siw *ServerInterfaceWrapper) PostSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSshGrant operation middleware
func (siw *ServerInterfaceWrapper) DeleteSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrant operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroups operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroups(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroup operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithLocation("simple", false, "groupID", runtime.ParamLocationPath, chi.URLParam(r, "groupID"), &groupID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroup(w, r, groupID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHosts operation middleware
func (siw *ServerInterfaceWrapper) GetSshHosts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostsParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", r.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "active", Err: err})
		return
	}

	// ------------- Optional query parameter "bastion" -------------

	err = runtime.BindQueryParameter("form", true, false, "bastion", r.URL.Query(), &params.Bastion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bastion", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHosts(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHost operation middleware
func (siw *ServerInterfaceWrapper) GetSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostHostsHostIDTags operation middleware
func (siw *ServerInterfaceWrapper) PostHostsHostIDTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostHostsHostIDTagsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostHostsHostIDTags(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UnregisterSshHost operation middleware
func (siw *ServerInterfaceWrapper) UnregisterSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnregisterSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventories operation middleware
func (siw *ServerInterfaceWrapper) ListInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoriesParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostInventories operation middleware
func (siw *ServerInterfaceWrapper) PostInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostInventoriesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventory operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventory operation middleware
func (siw *ServerInterfaceWrapper) GetInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventoryItems operation middleware
func (siw *ServerInterfaceWrapper) ListInventoryItems(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoryItemsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventoryItems(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHostTags operation middleware
func (siw *ServerInterfaceWrapper) GetSshHostTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostTagsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHostTags(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshUsers operation middleware
func (siw *ServerInterfaceWrapper) GetSshUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshUsersParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshUsers(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth", wrapper.PostAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities", wrapper.GetAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities", wrapper.PostAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/csr", wrapper.PostAuthoritiesCsr)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}", wrapper.DeleteAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}", wrapper.GetAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.ListAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.PostAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}", wrapper.DeleteProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}", wrapper.GetProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/root", wrapper.PostAuthorityRoot)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants", wrapper.GetSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/grants", wrapper.PostSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/grants/{grantID}", wrapper.DeleteSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants/{grantID}", wrapper.GetSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.GetSshGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{groupID}", wrapper.GetSshGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts", wrapper.GetSshHosts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts/{hostID}", wrapper.GetSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/tags", wrapper.PostHostsHostIDTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/unregister", wrapper.UnregisterSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories", wrapper.ListInventories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/inventories", wrapper.PostInventories)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}", wrapper.DeleteInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}", wrapper.GetInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items", wrapper.ListInventoryItems)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.DeleteInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.GetInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.PutInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.GetInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.PutInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetSshHostTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.GetSshUsers)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9eVPbSro4/FW6NPfWmVMHGdmWbUzV1DvGEHBYgyEreXPaUttW0Ia6ZeOk+O6/6kVS",
	"S2p5ISHhznD+OcHq9elnX7q/a1bghYGPfIK13e/aFEEbReyf7/V+hCBBtt4j9G8bYStyQuIEvrarXTke",
	"wgR6IQjGYD5FPiBTBCKEgziyEHDSv8PAxwiMAnsB5hADi4+pbWnoHnqhi7RdrWEYbd2o60bjqt7aNcxd",
	"o/XR6OwahralRegudiJka7skitGWhq0p8iBdzziIPEi0Xc2GBOnE8ZC2pZFFSEfEJHL8ifbwsKW918/Q",
	"PdH7cYSDSLGPKQIW+wZm0I0RIAGIMQLjIGI78NE9ASGcILrPCOHYJTi3+NOrwbez3r/+pclrUy3jEt3F",
	"CBN9YJdX0QMR/woG+yCMgpljIxuMFmwJlusgn9TAYAz8gKSft9hHjKIZisDccV0wQT6KIEEg8FENvKM/",
	"jegZjF1kEWTTQ0kOBNdym4Ajy0bjlVsYetB1MUGh3gsd/S2KMFt+aTcXAzDjHwU4N1tNw2g0dKOt1w2t",
	"8sArzvo6tH86yroQExDzgX8V3j5saSGMoIeIoEZoWSgkFfgb+AT5BNBBJIwBDmZ44fgTegx8hBrouTgA",
	"jm+5sY0wkM6qgBJh6DoWpNNsz3y7hpOzr82y8/nrKw58bUtz6FI479C2NB96dIQeX/JypIIxmQaRQxaD",
	"/fLmBvv0qOiO0mbJZCEk02wqeZRlsC/PP4mgT5bPfUibqOdNem86ZxCHq+YM4rBqTt57szmnAV6xzeHw",
	"CBwFuGKnov9mkzr+DPkkiBZDN56U58ZuPAGOjXzijBcMS6eUDEUf9TryQ264HIK8ahhAH9AGlA/Qf65Y",
	"Bh9qs/lDOHF8SJQ884J/QyCg7BwC18GErioYfUUWwTVwwClzF/z9/2XjfBo7ESaf/9U0bmLDaLSlL3BM",
	"UPT5X4l4+nsLzKeONQXsd4B8K7ApyOdB7NqUMcvD/m9rjw38v619xdD/29pjg9Cv6fA3PuMeoRvYKIEF",
	"g9tdjBgQBeAkGMjA8mPXhSM37RpGQYgi4iDO/Oh0ZZi9QoRuqCieQUCmiEpvyDk62wprVLvxT2NM6Hat",
	"IHSQDcZR4NERIjRzghi7CxAhEkc+skFOcQCcudXENhXCv7iDwvFvaWwZ5U2cOJ5DMNc1Ym+EInknyWJq",
	"N/4+GkP2GwlA3TAKK2kaW5oH7x0v9rTdumHQPx1f/Fm5OMcnaIIihpziJ45vdL2YLNgebYTC8/RXpn1Q",
	"aYGiM+ih80hFUAeOOAEE6LGDIALX1xmnkcZQU5dqks1ITahTqsU9G11LKTRzeuKyPbJNignod9Mw6P+E",
	"LsCoRpLgTE7vfpfG+58IjbVd7R/bmQGwzb/ibRRFQcTnyMNuD9oJ9LStvLGQV29Vo4vm27m2y/XK5cOo",
	"u7Flm0b96aFx7Qu94xtTDJ81OJpPD45XQTRybBv5zx0W5tPD4iwgYBzE/rPHi+7Tw6If+GPXsZ47x6g3",
	"fgGJQMdFNriIkBX4tiPUoGcMldavkCoDn6DIh24iYHnDZwyXh0Qwc+00tU3LuoYP3reMbma+AmpHcXUj",
	"HV3W5LC2+4ka+8SZoUs0CyxhLnCNRzjPeoQ7SQzdaOr1xpXR2G0au61mrWPsfKSKha3tamNk2vXOyNQ7",
	"I7Ojm2ZnpHc70NTNVt2ArWZj1Gp1M7XjdAF69gz6FrJBT7K1cTyyAw8yVcVb6FC0yTwW6S8Pn0tae2kX",
	"RfC8myKmKPYvTwD0bXDeH14AGCGAfKqt2uCfyfApBB2EQeC7iz+zJYyCwEXQp0cNbc/xDzzouLg82zVG",
	"EVW0IQFTOEOANWZuEcy0ag/61JAouRsI8rBCA8tAEEVwQf+Wjqfa95Q6njKcyPtF1/EPbWnJqaj8Qfwb",
	"nSkqbAdY0Od6KrSm8jHKZoo/QVEYOX6Ft2l41NMbrTawnQniNmpuij8wiIKAAIsiwphyCuZam6J7IHam",
	"mNRR+kSZzZD3Dzg4dzalgTg6q5bNDZGyN6niVJezsnSAK9o4MTi4cfKJ7kasJD0nMayMI5+3NOIQZhL0",
	"yuvJ7LB0Lt3CkQpMMqSxM/EppBITZxxEACZMqEhLCzB3yJR+R/eCA9OjU/Aj2UmnjTsItlv1ug5Nq6Ob",
	"BuroXcNAeqNpm6iLYLMxHtGd0tVqOv1v7+BwcAb6B5dXg1eDfu/qAFwevLk+GF6xrzf+6eBodjo4fN+b",
	"HPRO9w7u97/1zvYmZ2/3eqdXe577zWq+da2vex9P904P9xZ3h8NTs9ubHBz2+/zfN35vfnDUMwa9vcFr",
	"/7TxHvltzzv8OI/n88vG9nHXNBbe1/3Ox6PAa5JmfAA78+H1HrKd3mLvK6lHr278bzPf9o76h82z8e32",
	"X7OP6HL81+XbxVkUBt9O953J6/2esze5vZveOofdubHXf2Pev7rqXZ3uHRz26tf2jX/w5s3xac/pZyvu",
	"He9NJnfT26/nF2/e7PcmZ0e9/b2DnrP3YbQXf7hqdhZ/kcO5+ZfnfkQn3Rv/bLJwP2x7vbetwEVh47jV",
	"+dp/PR9M9vtX9Svr7QnBU3zROOi7743m8NYO68fH8V14++ry3eLD2+bF3Y0/3Tn4143PwHpwtr8E5BuJ",
	"CQVvX+a2VVLuCqpbD7edEnIXeY9DdQkP2Q7jOxjHKKLsJ0TeT2I//eGlMvZQYgB5nzTdn4ri8+MpqP5K",
	"sKP86s79jJnNoMOcOxJd0+Ewp2M/9uiSbDQLQkyXlQhs5WquOJcqixsHE8efxA6eIltXc9kzymFjzJ0f",
	"95TjSKeH8/6qT9+1IJpA3/kmVAMuurEC1azA8wL/TExZRpwg9km0UH5DVBPo2XaEsFqCu4EFXaG5lT7m",
	"F7iiAXS/xL5DlO3CABPo9plnVPU5CmaOb6k/YhQ50D1jnkF1AxIhRKo3+ZAd8758iIBBNAGSwodHfwZU",
	"3gIcj9IoGXeUD4dHgKpT3AuZP690PMVGHQ/mjipV3aRVsolLJLGl3euYBKHrTKYMyox7hQ7uzm59YzQL",
	"Zx4bhdsOdBkJqn3XPIQxnCDu6feEAxiCGXQdm1G5OAVpE2mXMluQ/k5IMDFYlnOFZEyJ8A7yHTPyZ4El",
	"1ezsA5g4M4RBiCLPwUmYFboupb4IswgGYGGiJO6H6TFS00NIfOBBYk0ZT4OTWlngpxEqrV1vNdtox9Sb",
	"ZsvSzR2jqe/UDVO3rZHRseqdjtkZJ7LE3GmYY1i39XbTsHTTtjs6bHSRPu6MzHG9bZp128hMDnvE7As7",
	"SKwbFn/n3l+VOVEZNasQNwIAlGdzoFFcJoQpvoAEPyoHJiIquKYKekoBTnWvCXR8TPhhEDhheilWjcNB",
	"U2UypSedbZX5pZllQ7vK2BH42YHTibHSeBLwX3vlrD1Won2C30lMMY2hKhA9iEM1otM9cf6DmJkRF+y3",
	"EUI+wAum0vI4ji+OiSwSz31Uxm26fracIqrb1s64A+2x3ho3dnSzOYb6TrfT0VsmbDebo5HRHI1Stalp",
	"mu16y9A7DdjQTaOOdIgQ1EetdgeZLWM8btgZqmNC6T45Uo2je4bwNpoxfGcjr0lwSeCbSk2NiRjnngWN",
	"xa7oWN1uVww6au40G0bT0g3bpFvbqes7YwvpowZqtxptsw27dGvcAk4DLEk0JsBkEqFENju+5YSQGtif",
	"sk+fy/Qqw/l7ZkUvM6s4TSks67UJU9DC403Dyu45CK+5H9ZH50MqdiXDsrQ7m7sHoQuyZhz55yLYBMMQ",
	"+TZjZpw2/uAKlys0ri0mCMQ4tBHdH234BwZMSDOfy8X5cPCe/Sws1nX9HQUyP8wDLqNwigeq0+PiiPko",
	"UlcYmELM6ZqyGui6fHfCM0On4dKsVuUzS1B3BDGfaAxdnP1NeZHAam1td9o060T/WRPT1qzAS9hBe2cE",
	"22a3pdtGt6WbsGXrO61WSze7VqPZaddto0uJlsAJXyzrtNMxRy04rutwZNm6abTGOmw1m3oDwQaqm0az",
	"Pd4p85Ac09gSQ5lGfdwYIUO3TdPWzTZs6zvNnaaOmvVxs7VjjtqwkQ1FEPSkkeZoxEhbpDhJ4Gjr9fpV",
	"3dw1m7vNRq3VqX+sdPNVnjDl4KwFiH1CNUr2U+xHaOJggiLZCyUJo/QAqwRgELEILZPF6UQg6bZkyAwH",
	"VLwgOeyEH4hOiWs60eckxSpdwRZwqHKsNm83cg1y0oAY5IC0nmNwut72bER4oNqOac+E3mAeeo9TjaY8",
	"i6jMPxj6r8k7CVT6WCUk3QSQhRy+NXNHi2qMir1liUIq90XgushKTAW+75J9K6PGms5fB4cuXJwpj7nH",
	"mLk+jhzk2+6CS7fEVSKnNZXPmCCvT83pCjGZpqewjSTKp2LINK9ki+V4qdboBnMUWRAL6VuZBVZTLTSH",
	"BGuepWyJyfATS5R3L5OrPJlkuA3Km1aghE7HVEaFVJlmClt6LbYhZ7OycSnCQ1toBsUjWhPDIIFqLGAz",
	"sM9SdsqDzCHy7bO0n2TPK/FwLRpX7pqRuTWF/mQTMi+57sT21scCMKAHrUCFr/PbCynbafd70VniW9Ei",
	"JMg+Rgs1vF+/OwBpK6oLziBB4BYpIXdbNUoYj1zHAq+H52dgjkaiv3R+BTDQ79JGX787Bhe5rK3STikZ",
	"61bgYxJBRyj9RWR2iGNBd6VMZxxBGoqFBD0Y3SIbJIPcqGU8umd5zfb+2XCfRV7yAmdlCC/pfyB5DtEj",
	"xxhcXFJEfGTv68vBo3bAzH5CHg+CdIAfgUE6yOOAkHZ/HBQk0c2c0n0JLSmqorm+JGhP6YUl/wdjANNg",
	"AwlEjBZA4KN55mxfJ3wvrJBcePqTRuX0v2Vr4nOqou8zd/2yUHzq0BdbF39Tk6AqfWD96X9jLgAJRPQ/",
	"nxUQMFlZDmH+UBpA5jHbNBcghISgiA73/3+6uZnrtc9//Tv5x/+oOLPn+APeuV7A1i0t9p27GInP9KiY",
	"DpHFsQYsjLVKYb5vGV2dR7x+UiQ8CgLyqLklTFEuQCafzJ2RxbEIuIkNo2ml47A/UY3/Ss1XQJU28asF",
	"peIUbpRXBvULmWmcoBFPV4aA0xAVQ0pEWx5LW6pWCN9KBpg0IUDGVUninqE5MzkKNFgWuzIvU2cI7K3k",
	"ZT+aHlDBb9Q4bMdREvOrG4ZhTDWmt6RZWdpB/8twcHj25aLRan8ZHvUarTbzTd5fQDI9Qf6ETHlSe5q6",
	"NJCDvmImBmwGpUIMkXboB15ILfWHB3mYg2SbS7heAoon4nEVNCnxtufAGJ4bfa8mNgXUCsS2MiJPKa0i",
	"LFepMUDbZqE46PM/uXtZ4b0USOjzmOz31DfH/09/4bEDpkjQP7OwRcOGCFr1jt5udWzdbHS6+mjH7Ort",
	"MeraEEJYb9Z/TzjtJRKWx8usco9BpoCA3IleESajyPfDnqYnchs9gYunADg2w7reFwoqAicbUyk9SEaj",
	"zMlfSaIsbL0iVF3NYm/RIgVqgj4qmFZgIB2Cl6mvHuShjF4sFHslN87AFji2tdRVIRJ0lGti4STMAMsU",
	"6SwPwQfnIfIH+9QG85FF5OKvGriaIoxEa0a01PxnhBshug+G0Clxy+lE9KiwM2FFyxtk6LLyLhXXY64t",
	"m6cvkYDnhlBtgstC20E+LxEvb4gEt8hXuin5bENkRahCaGD2LZ01GBEo9qqaBKtnCfyxMxFK1YFvh4Ey",
	"dbcwYK4XuL48qVVnGeNlacZYDTMeYLRc6Hir8WCjM5ykMdjykjj7Z7WzylXxvkyf9Zk8WH6i6y+KTol8",
	"KQtLUaUPXXcErVvKbmirNFVOcdxjN5grD4QgH1YjMP+qS3gcodCFFt88QV7oQuJ8o59YS8cW3KS0igw3",
	"VnPnlKgKGF+FmhIjPx/s91c5FuUgukLK8Pg1P/gIhRHCiLkMU4UFEoDuHUww8yFIWVAMIZwZ8kVTJqWo",
	"Mj5x7NqN3xNOAFtWKkYoydSnVqKNXMT+KUWb5MqO2o1/7edGwTz/DLoRgvaCL0zuXrvxb/yeD9KIOvDg",
	"gnNEL3aJE7pI3jGupa2vMYrACLmBPxEXPhT0IZbz5qEkhkO/yrBLnOmLLK6JqkThE2aX5FRUVdBRRKJQ",
	"5Fhi5QzzypGnDXJGJDgofTfJwqtU0Cx/AU9ZPX1iXfu2wBFVbomkcP5Qbook6PlG1KkY6gzK+Tyadxzv",
	"PpjX4wa/pYDRG5XJ1eRGv1IDgK7KDSZC4ieInKgaNTDIslWSgmnmXwg8yLz47gI4vNIax2HoOlkhNjUC",
	"/8BgkORzXYh8rqXYOA08tO9E2q62Tf+5neLWloanyHXph5Hjb48gnmpbWpx2TNNffg4+JgfGgKjCzXSh",
	"qtFEig5tA2wnQlal4s33tGQM3kIVYlu1lTU2kQFNNRBHCxl98wNVYu81VsgBNfKOpwtjfDf62rWa4yZH",
	"3rwGC133fMyQpBCKonrJ6vStbLA+77BuJoccnJRGkSu9qMy9fNUHzWazK0oTauAwJRKeb6Jjx0a1taO2",
	"myRp5PRw5bzqLTjpDmqPz7IrKH/lzHrWcZMDOhc9Kn29TD9ahGwJhekTvy7VRrQt7fW749UOXeG9TQ35",
	"gtbyXQt8JFBv2Q6KVhftuax9IZ78wPIu8xv9JDXAn/85JSTEu9vbORfath1YeJuVtlpQBiPe/pNHWxGZ",
	"BjbmabeJmOz3qFoxQSRviTFlynbGYxQhnwAvsBE3BcXlCKkamePaheS7hm7s6A3zqm7u1lu7jcZHdi5y",
	"cFxDi9fT0aHlnDuv37y5fXt16tQH198G9TOH7J1eDcxh3XJO+q+/2ke3tM2d3cAR9M9mI2eAB97b+MNi",
	"0B7cHizOrj4evTEM2nZ+6p06518P5qf7vflpf+5Y+6+/Db4Gzujo8tW7a7eN3nZD2Hj9AdZfOdcHH4w3",
	"t9Nv9uJ1tzZ8Q66aV28P9MH78Z7ZgsfdN9cXF8PGyeu79/PXc6f3av/sPP42OxoMXx3vz8fRvvvu9k1t",
	"2oRvdr7th3ez3vVVb9CpHd8dvtOvvrx9vTO4vx8c3x6R6cn5zsR8azb8wVt81r27+ECab90394PWufHe",
	"Ofx213c/tFBT9xfjw/dfRuN36L13cnB8bd3O/fGr8x48H57N/EFjeNb4WG93rRk8hGdn/dD+eD/Xg+bb",
	"urV3sbfTsQmcduyLzo5/it9Ox8f77yP49d5Co+jt/sG+2TyZHB0NrTen+pdpezJuXsBve9+84z08Ppoe",
	"252v8bkxa5y10b3j6vt4FN0GftsfHo3c9qhz0WnunESjq8mXc7t/8OXjQf09PGkj27n23105B/f928X+",
	"uXm7uL77+C3GzZOx3rasRjs8nI4jf3A7clukbdnWe9/SXfNq1p5N9p2Ptx/uwt7BKTw+GF+ddb03ncnX",
	"r3fNA0Q+fjw29lvByWF8Mf9iefG8FjSO/dtv2Nu/PTvZef9mb3YybJ7M0yoFu4NGja6hW7Yx1k0I6/oI",
	"dlt6x4JjE9rjnTG0tDSVAroTbVc7GPIghBXNqJzS+V+3bLzg7mDe3H+117qDMLSvorvbL0H47fLV/vtD",
	"eHq196o7GMfvxmYUOKe0D1mwEIfG5CflL86ESjdtV/vQC0/jDuod97zxyZkzIcMmccnOq6ZnmfcfLCv2",
	"e+Gbw44z69O90GGO3kwGex/1c8sgvfdXXzsfPNSdnrx904/CZjwObj2vTqy77nlsSLxZO12AynwOyvtY",
	"CFk4ez5pyJ/8O+9+/1zKnG3qhlkk3tR18EkrdU9MeDa6lmS+t+z6TqtZb+jjtmXoptlo6ztw3NDtujFq",
	"t8wd24JjrWRq8+uOjFwpe7VZyVj8g2SB5pmvVhb5CoEq6hHkDJXE0uV+5XlJxCaF14ldzsIxOTaauySI",
	"aS7B/BL5aA7d3pig6OA+dKJFYjzZ/DYoqmUPh0d9FJF9KazW3qHqrWhzdTIsfG+Y0meqbimGaLAmDoYj",
	"F4llpGkMPHZFO/WS9XjwfulaPHhfXkf2Tb0Ivk7P8dVDmzvis2Jk8UU9rjktF3xVwrt0/LQhiHhLzPyw",
	"iDZFdl4qZvYOs2gKGpfSClx2qEoHHG8PkohqUu1N7S/mi5CrZ5evB1zAiKImxACCT4eBC/1JOm6mRIS3",
	"k9okqNlotk110H+wXski/1S7ECuwcJMNFYtJf/dmlGi16Qkxi/lZbKpA5cWN7PPvCc7zPbjuD6N7jo2o",
	"yazERkkgc9H0EjYKzyIzLU9YxaRUJycu03vetKXiqpts5tnQVZUI2PRkng1NVQkt5Yb4RY3PHNUUYnaT",
	"zTwfVKvQCjY9mWeCag9KVRYI5VUVTin7TBSxQh53ZcETGIbugvuCqNZKNdyy+V/cbyn3AOPpKm8OxlPJ",
	"izNHo2kQ3K70AYl2tAvFsXWSodJZKoCXfFddipqtcWOoFYVUXuEX0Tk63fcbNvGNtgu+fwckeI0DH9Su",
	"FiECDw9b4IbapgO78PkYLQb74ntWMVpodJGVkvKWaSS02PIg/SBaJon3YpeF5v38V/DwAB4o/MSm9kU5",
	"Sb56mBp/W1oQYu3zQ0khz+BRNsBYGUMa7IPyVQwFIAuFIfFYgk+nQYSA44+DtTxjySLw9j8wnurpn39W",
	"BGfzuy0u24PMM2xDAjmSyEZhcgGtvHYxXq1UqqHCWrrzJZirTInpgVu00HkMOIROJGd0ZZkwWXjLRgRF",
	"nuMjnEQJRwtAqQxGSUYVIHDCsjN4MITlimFOCJAzTUjoxvhNxnTRy5JuuGPA6prdTmukjyzY0c0uGuld",
	"Exm6ierjJtppmKOdTuFeiRUJOptWM1al6Ty3RJ9VST7qqF4SPuaFNvKNCssicVsgiLJWiaUj4UoSuuIh",
	"viyJuDRSVvWduFHYjdfLK7xzyWzaVztAmrjLRr6Fhn34d75iO72GRqTaj6HnuMlA+2wclhYgfnkdTOlS",
	"JtnlCs/8Bol6swGblmnorY7R1s1OE+mjbrOjt1pGu9kZWQZsmc/0Bgk2FSvBY8thSJmtht9rXgzyiqOv",
	"DPDyXlKEl3V4+Lx+JXuati2CmBm+2oj1SeJ5y8hF7fFZlpEpxXFFOyAym9UXXa1fW82JQ5HGJJPCkuXw",
	"ZpWrkahnySA89aZyjM1u2qi8Y2ODLBB1fDqPihtd/MEGXHVvhjLcnem/iqKVXOYes0iAaJxoO/zijM1V",
	"dkkdpe351XNa7+Qk8wVTI5AlefViMk09woxuUXtsoEanqaOdels3x62RvmOaTd3oGmPD2rFs0x7n3PTv",
	"xBa3tDiipJsoZBK73k6y5soe22yFS8osaHe+0wREDCrJNZnvi7fUbZW0dCbmeicnef8SEM8xAAfTj3IU",
	"mYOLjqxt0RNWxJKroKmiln4vy4zFyLcBTJ73kVVFtiuR0pwpk8meeVBf7RRTEYhaERKjrcwWSGb9KZkC",
	"yaTKJJaoIvvl+vKk0L8MAoX2lOFjiRrlGhoFP+nHmAQey6xkKCUunhTugiWlomsUPmX0chkERKHM2kt9",
	"GDKWuM4YEcdDT+hekTekzHh2Jj4kcYQAdCcUKFMvd0+lGgbpr80dk/7a3KEazOWwJ34+7g/rXxqGuZN1",
	"KXxsGp1G5UfT6LZXfmzVG7mPw2HljMNh5XzDYeVs0ic612e1n1QugvuuyMpaj6ycpEguK2St/VVFpf18",
	"Vf8ywVe6BeAhV4e3rKviitGKwi4Jx6RILiO8tPhPScGPdt2UbjNd5rsR+y14SIb8V+FNwbDkQhn2znDm",
	"37nGcMI8QJ9uNNuZOAS6w4R0brTPwndznG/ImRyVJTca89mksuVG+6zyxwir7TyaUPmdPFP1M/wwJX/v",
	"T3PEMFb8rD0xDBMrXTHsUlcrpvJgSIfiYH797ip9SYFJaAQjGZEpjBgHIBU17Wq9gNE52xIEJIqZcsCu",
	"ZxeJXHgaRER3nRltxKYUpSZZijwz5vsnAwnQXkxi6F6dDPlrDvQUk1ciICf0xPzGcRgGEfl3sYBTCLXM",
	"WzDkDUu6oBigUAFaekLiH+AQEcK8rARGBNk3/iv27NciiP+g2hNKIoaESuTexYDvM3NgXCHogSEfBKdP",
	"ii2COAKfJKcGxNNRACO7CmthGP7JkvivKP9YBDFDLRItwCeXMzhe7vT5n9uUyhjN4O0JIjrGU2Yx4D+Z",
	"3sBm5k+X0dVSRbZ24//99983vhVHLtCPwB89OcNuF+zxA6w3mn+AZHUTSNAcLmrFVTrbbC4xIkursZCP",
	"UVa+pvVCaE0RaNSM0qnM5/MaZJ9rQTTZFn3x9smgf3A2PNBpH8b5Pe5pkQ66dzHQJAuo8PssVYZ4WlFT",
	"N+o8IRT5MHS0Xa1Zq7MFhZBMGSWwy/iZc1l50SAlDQVh0E5Uv+Wl2irUYK5pcUIDat9cBJjr6enzYnuB",
	"vdjoeZTiJeq8roxfBMT1H8bw4ASJOpkiYxvFvs1lTmqHpqnBI8eH0ZInDTKjmCAoHkJUKMMFblV+zocD",
	"swBAygPoOtgLKYWnyRobPsZVEEDsMB65VvGqBnvqyKjSQNLFbtNG2ethq9rWtexprVVtm1r2ms7ytrSR",
	"LCSYncDZ/ifmtMqoqpedAWIp8o54SSf1bSp+2paeUmFVDbw4MY/rh4j0pGalA93sVaC1fCbZjQNll0np",
	"YHvpA5nSbm6e/ctjT4OCm6FVij0nFIL5UxYXlGryr58LbxFXZLRnTbazxxer0tmlxuJhY2bWKhl4X76p",
	"ZNkNLaq3lXgYQc3HZeR+HDtfagnlLpl6KD/Y2PiJTxTmJtpS2H7S0xDs4qOsDuW/lWjM6lwBuW1Xy96G",
	"W9G23vgBYhRYnruJpJIgC1x8W1z782yodD3aVF8vVLvxL9mrtxhA0B9erv3KC0Ps5HUH7Ex8Or9vAxyP",
	"+F1ySU3s3znY7Tr2Np33b4BEgTIYoXFQejkrraEduagig3s1r+nj6FewG3YP1K9iOclkKrazwfm98KFn",
	"y4eSG5HW4kXfpXePHjifcJHKfbTPC6OpyZVORPkDK+fOUxFvKvPFAlqbCidPxnqyaC0r139REjfAB3FK",
	"q2XSVmJI5I/hkFrVADv+xJVGqThnyepY/KjN8Wh1qVda7X8rYzLXaWv+AHJR5FgHs36BYrNGS+k9t4fP",
	"S9lerqJWsrGLL/+zm0BcOQiP8xl4fu4evjyx0O4p8OSa319irYf5urlV9jpVBsax66Zme+Wei5cPvlDe",
	"U1BezvZfgAL6JHSY+/mZEuJaBolcQrQ2gcm6e5nAfr4KnyOpp1XeC1NtVVzimc8OeqHEpZS4iSL/Y8q5",
	"km6ryXZ9UbX9XfrrDHroPFpTiU90JpnQRuISySCq1unzG1it1Q9jlnZORckivX6rIIuepwa91lGto0Sv",
	"D+JDRJbC1/iV/CRLTnvhKr9Gs14T456fTF/dXMGmVurkURCQX+Ql/Vk6zCvHh67zTaTNiOyagou1l7+t",
	"PedLpfxBuD+TJGfhGJVD4YmDrj+8BGGEZk4QY3cBIuaFlStB/i46nTOfae3G77k4ELOx1mwBuZA7S17N",
	"3SssHL5XSk8rvyJR6WoFcEyYy9fBIOV5rBCJ8tqVntgFy6T8aWH8/4DXJipug/vbsf8uIAJMcUQkVwcK",
	"vFBeTib5fC8OTqvTQ1ktheQflg6+6pWKqiutc8iWJw2nkCmYH7BygSWsXvG4vOp5qXTF2Vxl8BRehlAa",
	"BMavCyD2ygHE7Dm9Fxn+FDKcciwJ7unrFIJ5VbvjJ+mru9V+p/S2eSWzPERkiKeixu1XuJMqXv5V42Ka",
	"+uG6SX1pcieJuGQ3X4uVViI+/xjTk1sjVDHMzl5CI1ap8ptTPXq2nVyvcJi9mcGKEiskeh5LnyasKnAz",
	"z8qF4HwyD400ablYlwNHJHC8hLM296Dk3trIEUDGP7e/s/+vHcXMDmZZEDNB2Md7O7K1P1tfRzV4lzk4",
	"VoNQEktP6c2opL00NChv8EX5eSoHxjI02kxMCUpeR0g9TqJxtpGULFerXdIjFEyPZuYgS06Qr11guf9O",
	"UkEeigpyWZOp3fgDUZ3AnsuaQswqRLMLFHKJVaWxREUntUi5eZesqnShQ3aNQ/KQwar8yoRKGTQ2PakQ",
	"ThxfpJF//jWap7JyXEX8SVFI+jgDLpL/Gbonej+OcBCtJly5MWMAL5J7LYYgAP87FNeMzKl2wK79eKgk",
	"+JxQC+JwhVDjbzY8oVBjeL5SqPFlvAi1pxVq4oGOHxRq/N6ZJxVq/JG8la6EI9qsUhYciZf2nrkooHvd",
	"XBJkW38RBb9WFCRo9RskwVaREgZjEPvsYvCI3Q9OAkCimPv0I4Rjlwh1K/DdBXB89sg74DcO8Zcoa2Aw",
	"Trqya1XKfZNuo4BMk77Qt4Hj5wZi3mRtV7uLEasHTG564tcbSRXMpetAyvt65bgEReCffuDrf44gZoGW",
	"bL18z8sXmvSiK6XDlEdZCrBkLAa4XF++93WBxvqX568Almi0HFoZh9z+Tv+3UhuQRe2ReC2sUiWgDZ5S",
	"I+DsboVCIBbxog88pT4ggPxjfIwj4C/QBlJc3+YL/v7MFlrlXb6CE3HRpNKVzKTJEVvbFd3X0zmUCZw8",
	"dYKfmKIqsU++J5JxYP78bXbnA/T4fTHb/BJKK/BGQhfLv12IgUOkgH2Mk5sbXxjGUzAMisKVDENBoLEf",
	"oYmDCYr+75Dpdbpmeat5es3a/EY5yR94yC6A/O8Wl4/EaPVplxE7eS08f2lBRUGF1Fhhk9JmA2m4Z2+X",
	"Zq+vb2ScFqHwYp7+wnsV8giW4LP867O6VwF5IVlkT/JXRNvzm3oq9UhC96dVknITValKeZi8FCg/YV0D",
	"9FOyWVQSTUEYbH9PD2joxpOlsfoLFHmQriaNptMp0/48QZXdF4sAY8xUuWWXmjm+SpDwaLe85NUhfYpW",
	"2YzF0uT/JBz7sRSC1YhQkUpwiUjkoJkMZQ8RaEMC1f7pJedn/DpWk5VHvDCc9eyoH/Ugr4Nhz6JWIMfg",
	"hCNmCQfcTnXKaiVZcDc/x/9WqMoLnjL+SxVenTbfUOut3NqL/vv8CDGnKy9AgmL/l+hxazODcS3q3f5O",
	"/7d26iFtLKozltNzQWOh4F5fa6GT/CcrLL8uPzKP8I/WcJKTF5lk4mQwnKXF7ctwQVZ91IjwBOqPYOhq",
	"HSjT2GirF/XnSeNOa+Pg8+C5jB0+Rlva0sK4utSA00+eVkAQgQiFLrQQT6IU9zanSFlwjMQKOvoZdYW2",
	"uLw8f+G4XE3GWnxW3IP78PtpOWVM0l2TFLKiaiwp0fmvt3YeScJDOFtbjmymcmwneLeW8PkDS7foL5dB",
	"rNDXwcDBgOLwDLqIl/iwpGhE9DxmSYW96J7yCT5H4pzh0zoYiN9IEAIXzZCbvECQQA+MAntRW0MAsscC",
	"foxwHinYxDXVeo+sRlGp7TMzReiI15y619qJ1PY/T6ACgU0vUnUNqbqUM4TxOpxhbabAAMlcvSsZRFGy",
	"pwziUdL9x8Xy04naFwb0f0PEL+cqVM4nKVmVOYhy6g9eknkoPj/z0DjLc3pMxnay/Ren4K/P2U5g/7sq",
	"eGK88lrO5D3QZ1emxxf106r0+LOmz57MK15SXULnnyiyJS8tycP8+RIL+A1kn+DZbyH54mM67K018ZYO",
	"ezGPT86fuNqGocOGz794VfmOFqMAsa1Sio10T9Apo8uIP4yXf34keW9L+rFciEGheIlwEEeW3IkCstyY",
	"TyZngPFaCRFeEX1l7aFqDDt/U2/gL9lA7mq5h88P/y8AAP//Xr84ZV3iAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
