// Package v20230301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20230301

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for ProvisionerType.
const (
	JWK  ProvisionerType = "JWK"
	OIDC ProvisionerType = "OIDC"
)

// Defines values for WebhookCertType.
const (
	ALL  WebhookCertType = "ALL"
	SSH  WebhookCertType = "SSH"
	X509 WebhookCertType = "X509"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// Authority An X509 authority hosted by Smallstep
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only)
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority
	Id string `json:"id"`

	// Name The name of the authority
	Name string `json:"name"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error
	Message string `json:"message"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group
	Id *string `json:"id,omitempty"`

	// Name The name of the group
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp when the host was registered
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp when the host was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Inventory A collection of items
type Inventory struct {
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the inventory
	DisplayName string `json:"displayName"`

	// ItemCount The number of items in the inventory
	ItemCount int `json:"itemCount"`

	// Slug A lowercase name identifying the inventory.
	Slug      string    `json:"slug"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// InventoryItem An item in an inventory
type InventoryItem struct {
	// CreatedAt Timestamp of when the item was added to the inventory
	CreatedAt time.Time `json:"createdAt"`

	// Data The item data
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp of when the item was last changed
	UpdatedAt time.Time `json:"updatedAt"`
}

// JwkProvisioner defines model for jwkProvisioner.
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key
	Key interface{} `json:"key"`
}

// NameConstraints defines model for name-constraints.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewInventory A collection of items
type NewInventory struct {
	// DisplayName A user-friendly name for the inventory
	DisplayName *string `json:"displayName,omitempty"`

	// Slug A lowercase name identifying the inventory.
	Slug string `json:"slug"`
}

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// OidcProvisioner defines model for oidcProvisioner.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user
	Username *string `json:"username,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh *SshOptions `json:"ssh,omitempty"`

	// Webhooks Configuration for a webhook to be called when issuing certificates with this provisioner
	Webhooks *Webhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates
	X509 *X509Options `json:"x509,omitempty"`
}

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template string `json:"template"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// Webhook Configuration for a webhook to be called when issuing certificates with this provisioner
type Webhook struct {
	// CertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
	CertType *WebhookCertType `json:"certType,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the webhook.
	Name *string `json:"name,omitempty"`

	// Url The URL of the webhook server.
	Url *string `json:"url,omitempty"`
}

// WebhookCertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
type WebhookCertType string

// X509Issuer A Customized X509 issuer for an authority
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer
	Name            string           `json:"name"`
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates
type X509Options struct {
	// Template A JSON representation of the x509 certificate to created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template string `json:"template"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Accept defines model for accept.
type Accept = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InventorySlug defines model for inventorySlug.
type InventorySlug = string

// ItemID defines model for itemID.
type ItemID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// ProvisionerID defines model for provisionerID.
type ProvisionerID = string

// RequestID defines model for requestID.
type RequestID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N500 defines model for 500.
type N500 = Error

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to true the results will only include active hosts. If set to false the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to true the results will include only bastion hosts and if set to false the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoriesParams defines parameters for ListInventories.
type ListInventoriesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostInventoriesParams defines parameters for PostInventories.
type PostInventoriesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryParams defines parameters for DeleteInventory.
type DeleteInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryParams defines parameters for GetInventory.
type GetInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoryItemsParams defines parameters for ListInventoryItems.
type ListInventoryItemsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryItemParams defines parameters for DeleteInventoryItem.
type DeleteInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemParams defines parameters for GetInventoryItem.
type GetInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemJSONBody defines parameters for PutInventoryItem.
type PutInventoryItemJSONBody struct {
	Data interface{} `json:"data"`
}

// PutInventoryItemParams defines parameters for PutInventoryItem.
type PutInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemDataParams defines parameters for GetInventoryItemData.
type GetInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemDataJSONBody defines parameters for PutInventoryItemData.
type PutInventoryItemDataJSONBody = interface{}

// PutInventoryItemDataParams defines parameters for PutInventoryItemData.
type PutInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PostInventoriesJSONRequestBody defines body for PostInventories for application/json ContentType.
type PostInventoriesJSONRequestBody = NewInventory

// PutInventoryItemJSONRequestBody defines body for PutInventoryItem for application/json ContentType.
type PutInventoryItemJSONRequestBody PutInventoryItemJSONBody

// PutInventoryItemDataJSONRequestBody defines body for PutInventoryItemData for application/json ContentType.
type PutInventoryItemDataJSONRequestBody = PutInventoryItemDataJSONBody

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate
	// (POST /auth)
	PostAuth(w http.ResponseWriter, r *http.Request)
	// List Authorities
	// (GET /authorities)
	GetAuthorities(w http.ResponseWriter, r *http.Request, params GetAuthoritiesParams)
	// Create New Authority
	// (POST /authorities)
	PostAuthorities(w http.ResponseWriter, r *http.Request, params PostAuthoritiesParams)
	// Create New Authority CSR
	// (POST /authorities/csr)
	PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request, params PostAuthoritiesCsrParams)
	// Delete Authority
	// (DELETE /authorities/{authorityID})
	DeleteAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params DeleteAuthorityParams)
	// Get Authority
	// (GET /authorities/{authorityID})
	GetAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params GetAuthorityParams)
	// List Authority Provisioners
	// (GET /authorities/{authorityID}/provisioners)
	ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params ListAuthorityProvisionersParams)
	// Create Authority Provisioner
	// (POST /authorities/{authorityID}/provisioners)
	PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityProvisionersParams)
	// Delete Provisioner
	// (DELETE /authorities/{authorityID}/provisioners/{provisionerID})
	DeleteProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerID ProvisionerID, params DeleteProvisionerParams)
	// Get Provisioner
	// (GET /authorities/{authorityID}/provisioners/{provisionerID})
	GetProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerID ProvisionerID, params GetProvisionerParams)
	// Post Authority External Root
	// (POST /authorities/{authorityID}/root)
	PostAuthorityRoot(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityRootParams)
	// Get SSH Grants
	// (GET /grants)
	GetSshGrants(w http.ResponseWriter, r *http.Request, params GetSshGrantsParams)
	// Create SSH Grant
	// (POST /grants)
	PostSshGrants(w http.ResponseWriter, r *http.Request, params PostSshGrantsParams)
	// Delete SSH Grant
	// (DELETE /grants/{grantID})
	DeleteSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params DeleteSshGrantParams)
	// Get SSH Grant
	// (GET /grants/{grantID})
	GetSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params GetSshGrantParams)
	// Get SSH Groups
	// (GET /groups)
	GetSshGroups(w http.ResponseWriter, r *http.Request, params GetSshGroupsParams)
	// Get SSH Group
	// (GET /groups/{groupID})
	GetSshGroup(w http.ResponseWriter, r *http.Request, groupID GroupID, params GetSshGroupParams)
	// Get SSH Hosts
	// (GET /hosts)
	GetSshHosts(w http.ResponseWriter, r *http.Request, params GetSshHostsParams)
	// Get SSH Host
	// (GET /hosts/{hostID})
	GetSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params GetSshHostParams)
	// Tag SSH Host
	// (POST /hosts/{hostID}/tags)
	PostHostsHostIDTags(w http.ResponseWriter, r *http.Request, hostID HostID, params PostHostsHostIDTagsParams)
	// Unregister SSH Host
	// (POST /hosts/{hostID}/unregister)
	UnregisterSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params UnregisterSshHostParams)
	// List Inventories
	// (GET /inventories)
	ListInventories(w http.ResponseWriter, r *http.Request, params ListInventoriesParams)
	// Create an Inventory
	// (POST /inventories)
	PostInventories(w http.ResponseWriter, r *http.Request, params PostInventoriesParams)
	// Delete Inventory
	// (DELETE /inventories/{inventorySlug})
	DeleteInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params DeleteInventoryParams)
	// Get Inventory
	// (GET /inventories/{inventorySlug})
	GetInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params GetInventoryParams)
	// List Inventory Items
	// (GET /inventories/{inventorySlug}/items)
	ListInventoryItems(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params ListInventoryItemsParams)
	// Delete Inventory Item
	// (DELETE /inventories/{inventorySlug}/items/{itemID})
	DeleteInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params DeleteInventoryItemParams)
	// Get Inventory Item
	// (GET /inventories/{inventorySlug}/items/{itemID})
	GetInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemParams)
	// Save Inventory Item
	// (PUT /inventories/{inventorySlug}/items/{itemID})
	PutInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemParams)
	// Get Inventory Item Data
	// (GET /inventories/{inventorySlug}/items/{itemID}/data)
	GetInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemDataParams)
	// Save Inventory Item Data
	// (PUT /inventories/{inventorySlug}/items/{itemID}/data)
	PutInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemDataParams)
	// Get SSH Host Tags
	// (GET /tags)
	GetSshHostTags(w http.ResponseWriter, r *http.Request, params GetSshHostTagsParams)
	// Get SSH Users
	// (GET /users)
	GetSshUsers(w http.ResponseWriter, r *http.Request, params GetSshUsersParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuth operation middleware
func (siw *ServerInterfaceWrapper) PostAuth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, MtlsScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuth(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthoritiesCsr operation middleware
func (siw *ServerInterfaceWrapper) PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesCsrParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthoritiesCsr(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteProvisioner operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerID" -------------
	var provisionerID ProvisionerID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerID"), &provisionerID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvisioner(w, r, authorityID, provisionerID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetProvisioner operation middleware
func (siw *ServerInterfaceWrapper) GetProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerID" -------------
	var provisionerID ProvisionerID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerID"), &provisionerID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvisioner(w, r, authorityID, provisionerID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityRoot operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityRoot(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityRootParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityRoot(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrants operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostSshGrants operation middleware
func (siw *ServerInterfaceWrapper) PostSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSshGrant operation middleware
func (siw *ServerInterfaceWrapper) DeleteSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrant operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroups operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroups(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroup operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithLocation("simple", false, "groupID", runtime.ParamLocationPath, chi.URLParam(r, "groupID"), &groupID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroup(w, r, groupID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHosts operation middleware
func (siw *ServerInterfaceWrapper) GetSshHosts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostsParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", r.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "active", Err: err})
		return
	}

	// ------------- Optional query parameter "bastion" -------------

	err = runtime.BindQueryParameter("form", true, false, "bastion", r.URL.Query(), &params.Bastion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bastion", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHosts(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHost operation middleware
func (siw *ServerInterfaceWrapper) GetSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostHostsHostIDTags operation middleware
func (siw *ServerInterfaceWrapper) PostHostsHostIDTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostHostsHostIDTagsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostHostsHostIDTags(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UnregisterSshHost operation middleware
func (siw *ServerInterfaceWrapper) UnregisterSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnregisterSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventories operation middleware
func (siw *ServerInterfaceWrapper) ListInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoriesParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostInventories operation middleware
func (siw *ServerInterfaceWrapper) PostInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostInventoriesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventory operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventory operation middleware
func (siw *ServerInterfaceWrapper) GetInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventoryItems operation middleware
func (siw *ServerInterfaceWrapper) ListInventoryItems(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoryItemsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventoryItems(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHostTags operation middleware
func (siw *ServerInterfaceWrapper) GetSshHostTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostTagsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHostTags(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshUsers operation middleware
func (siw *ServerInterfaceWrapper) GetSshUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshUsersParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshUsers(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth", wrapper.PostAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities", wrapper.GetAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities", wrapper.PostAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/csr", wrapper.PostAuthoritiesCsr)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}", wrapper.DeleteAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}", wrapper.GetAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.ListAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.PostAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerID}", wrapper.DeleteProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerID}", wrapper.GetProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/root", wrapper.PostAuthorityRoot)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants", wrapper.GetSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/grants", wrapper.PostSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/grants/{grantID}", wrapper.DeleteSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants/{grantID}", wrapper.GetSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.GetSshGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{groupID}", wrapper.GetSshGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts", wrapper.GetSshHosts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts/{hostID}", wrapper.GetSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/tags", wrapper.PostHostsHostIDTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/unregister", wrapper.UnregisterSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories", wrapper.ListInventories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/inventories", wrapper.PostInventories)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}", wrapper.DeleteInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}", wrapper.GetInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items", wrapper.ListInventoryItems)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.DeleteInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.GetInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.PutInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.GetInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.PutInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetSshHostTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.GetSshUsers)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"8Pnh/wUAAP//FYekZ0riAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
