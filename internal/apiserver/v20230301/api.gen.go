// Package v20230301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20230301

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AcmeAttestationProvisionerAttestationFormats.
const (
	AcmeAttestationProvisionerAttestationFormatsApple AcmeAttestationProvisionerAttestationFormats = "apple"
	AcmeAttestationProvisionerAttestationFormatsStep  AcmeAttestationProvisionerAttestationFormats = "step"
	AcmeAttestationProvisionerAttestationFormatsTpm   AcmeAttestationProvisionerAttestationFormats = "tpm"
)

// Defines values for AcmeProvisionerChallenges.
const (
	Dns01     AcmeProvisionerChallenges = "dns-01"
	Http01    AcmeProvisionerChallenges = "http-01"
	TlsAlpn01 AcmeProvisionerChallenges = "tls-alpn-01"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
	AuthorityTypeManaged  AuthorityType = "managed"
)

// Defines values for DeviceCollectionDeviceType.
const (
	DeviceCollectionDeviceTypeAwsVm   DeviceCollectionDeviceType = "aws-vm"
	DeviceCollectionDeviceTypeAzureVm DeviceCollectionDeviceType = "azure-vm"
	DeviceCollectionDeviceTypeGcpVm   DeviceCollectionDeviceType = "gcp-vm"
	DeviceCollectionDeviceTypeTpm     DeviceCollectionDeviceType = "tpm"
)

// Defines values for EndpointCertificateInfoType.
const (
	EndpointCertificateInfoTypeSSHHOST EndpointCertificateInfoType = "SSH_HOST"
	EndpointCertificateInfoTypeSSHUSER EndpointCertificateInfoType = "SSH_USER"
	EndpointCertificateInfoTypeX509    EndpointCertificateInfoType = "X509"
)

// Defines values for EndpointConfigurationKind.
const (
	DEVICE   EndpointConfigurationKind = "DEVICE"
	PEOPLE   EndpointConfigurationKind = "PEOPLE"
	WORKLOAD EndpointConfigurationKind = "WORKLOAD"
)

// Defines values for EndpointKeyInfoFormat.
const (
	EndpointKeyInfoFormatDEFAULT EndpointKeyInfoFormat = "DEFAULT"
	EndpointKeyInfoFormatDER     EndpointKeyInfoFormat = "DER"
	EndpointKeyInfoFormatOPENSSH EndpointKeyInfoFormat = "OPENSSH"
	EndpointKeyInfoFormatPKCS8   EndpointKeyInfoFormat = "PKCS8"
)

// Defines values for EndpointKeyInfoType.
const (
	EndpointKeyInfoTypeDEFAULT   EndpointKeyInfoType = "DEFAULT"
	EndpointKeyInfoTypeECDSAP256 EndpointKeyInfoType = "ECDSA_P256"
	EndpointKeyInfoTypeECDSAP384 EndpointKeyInfoType = "ECDSA_P384"
	EndpointKeyInfoTypeECDSAP521 EndpointKeyInfoType = "ECDSA_P521"
	EndpointKeyInfoTypeED25519   EndpointKeyInfoType = "ED25519"
	EndpointKeyInfoTypeRSA2048   EndpointKeyInfoType = "RSA_2048"
	EndpointKeyInfoTypeRSA3072   EndpointKeyInfoType = "RSA_3072"
	EndpointKeyInfoTypeRSA4096   EndpointKeyInfoType = "RSA_4096"
)

// Defines values for EndpointReloadInfoMethod.
const (
	AUTOMATIC EndpointReloadInfoMethod = "AUTOMATIC"
	CUSTOM    EndpointReloadInfoMethod = "CUSTOM"
	DBUS      EndpointReloadInfoMethod = "DBUS"
	SIGNAL    EndpointReloadInfoMethod = "SIGNAL"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for ProvisionerType.
const (
	ACME            ProvisionerType = "ACME"
	ACMEATTESTATION ProvisionerType = "ACME_ATTESTATION"
	AWS             ProvisionerType = "AWS"
	AZURE           ProvisionerType = "AZURE"
	GCP             ProvisionerType = "GCP"
	JWK             ProvisionerType = "JWK"
	OIDC            ProvisionerType = "OIDC"
	X5C             ProvisionerType = "X5C"
)

// Defines values for ProvisionerWebhookCertType.
const (
	ProvisionerWebhookCertTypeALL  ProvisionerWebhookCertType = "ALL"
	ProvisionerWebhookCertTypeSSH  ProvisionerWebhookCertType = "SSH"
	ProvisionerWebhookCertTypeX509 ProvisionerWebhookCertType = "X509"
)

// Defines values for ProvisionerWebhookKind.
const (
	ENRICHING ProvisionerWebhookKind = "ENRICHING"
)

// Defines values for ProvisionerWebhookServerType.
const (
	EXTERNAL          ProvisionerWebhookServerType = "EXTERNAL"
	HOSTEDATTESTATION ProvisionerWebhookServerType = "HOSTED_ATTESTATION"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// AcmeAttestationProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [device-attest-01 challenge of the ACME protocol](https://smallstep.com/blog/acme-managed-device-attestation-explained/).
type AcmeAttestationProvisioner struct {
	// AttestationFormats The allowed attestation formats for the device-attest-01 challenge. Valid values are `apple`, `step`, and `tpm`. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default.
	AttestationFormats []AcmeAttestationProvisionerAttestationFormats `json:"attestationFormats"`

	// AttestationRoots A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
	AttestationRoots *[]string `json:"attestationRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// AcmeAttestationProvisionerAttestationFormats defines model for AcmeAttestationProvisioner.AttestationFormats.
type AcmeAttestationProvisionerAttestationFormats string

// AcmeProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [ACME protocol](https://smallstep.com/docs/step-ca/acme-basics/#acme-challenges).
type AcmeProvisioner struct {
	// Challenges Which ACME challenge types are allowed.
	Challenges []AcmeProvisionerChallenges `json:"challenges"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be `true` for all new provisioners.
	RequireEAB bool `json:"requireEAB"`
}

// AcmeProvisionerChallenges defines model for AcmeProvisioner.Challenges.
type AcmeProvisionerChallenges string

// AgentConfiguration The agent configuration describes the attestation authority used by the agent to grant workload certificates. This object is experimental and subject to change.
type AgentConfiguration struct {
	// AttestationSlug The slug of the attestation authority the agent connects to to get a certificate.
	AttestationSlug *string `json:"attestationSlug,omitempty"`

	// AuthorityID UUID identifying the authority the agent uses to generate endpoint certificates.
	AuthorityID string `json:"authorityID"`

	// Id A UUID identifying this agent configuration. Read only.
	Id *string `json:"id,omitempty"`

	// Name The name of this agent configuration.
	Name string `json:"name"`

	// Provisioner The name of the provisioner on the authority the agent uses to generate endpoint certificates.
	Provisioner string `json:"provisioner"`
}

// AttestationAuthority An attestation authority used with the device-attest-01 ACME challenge to verify a device's hardware identity. This object is experimental and subject to change.
type AttestationAuthority struct {
	// AttestorIntermediates The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by devices.
	AttestorIntermediates *string `json:"attestorIntermediates,omitempty"`

	// AttestorRoots The pem-encoded list of certificates used to verify the attestation certificates submitted by devices.
	AttestorRoots string `json:"attestorRoots"`

	// CreatedAt Timestamp in RFC3339 format when the attestation authority was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this attestation authority. Read only.
	Id *string `json:"id,omitempty"`

	// Name The name of the attestation authority.
	Name string `json:"name"`

	// Root The pem-encoded root certificate of this attestation authority. This is generated server-side when the attestation authority is created. This certificate should be used in the `attestationRoots` field of an ACME_ATTESTATION provisioner with the `tpm` format.
	Root *string `json:"root,omitempty"`

	// Slug A short name for this attestation authority. Read only.
	Slug *string `json:"slug,omitempty"`
}

// Authority An X509 authority hosted by Smallstep.
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only).
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created.
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached.
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority.
	Id string `json:"id"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Root The root certificate in pem format.
	Root *string `json:"root,omitempty"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root.
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority.
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format.
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR.
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// AwsAccounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
type AwsAccounts = []string

// AwsDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
type AwsDisableCustomSANs = bool

// AwsProvisioner The [AWS provisioner](https://smallstep.com/docs/step-ca/provisioners/#aws) grants a certificate to an Amazon EC2 instance using the Instance Identity Document.
type AwsProvisioner struct {
	// Accounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
	Accounts AwsAccounts `json:"accounts"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
	DisableCustomSANs *AwsDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`
}

// AwsVM Configuration for an AWS provisioner for a device collection of AWS VMs.
type AwsVM struct {
	// Accounts The list of AWS account IDs that are allowed to use an AWS cloud provisioner.
	Accounts AwsAccounts `json:"accounts"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid. These are the private IP and the DNS ip-<private-ip>.<region>.compute.internal.
	DisableCustomSANs *AwsDisableCustomSANs `json:"disableCustomSANs,omitempty"`
}

// AzureAudience Defaults to https://management.azure.com/ but it can be changed if necessary.
type AzureAudience = string

// AzureDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
type AzureDisableCustomSANs = bool

// AzureProvisioner The [Azure provisioner](https://smallstep.com/docs/step-ca/provisioners/#azure) grants certificates to Microsoft Azure instances using the managed identities tokens.
type AzureProvisioner struct {
	// Audience Defaults to https://management.azure.com/ but it can be changed if necessary.
	Audience *AzureAudience `json:"audience,omitempty"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
	DisableCustomSANs *AzureDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to true this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// ResourceGroups The list of resource group names that are allowed to use this provisioner.
	ResourceGroups AzureResourceGroups `json:"resourceGroups"`

	// TenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
	TenantID AzureTenantID `json:"tenantID"`
}

// AzureResourceGroups The list of resource group names that are allowed to use this provisioner.
type AzureResourceGroups = []string

// AzureTenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
type AzureTenantID = string

// AzureVM defines model for azureVM.
type AzureVM struct {
	// Audience Defaults to https://management.azure.com/ but it can be changed if necessary.
	Audience *AzureAudience `json:"audience,omitempty"`

	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the token will be valid, in Azure only the virtual machine name is available.
	DisableCustomSANs *AzureDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// ResourceGroups The list of resource group names that are allowed to use this provisioner.
	ResourceGroups AzureResourceGroups `json:"resourceGroups"`

	// TenantID The Azure account tenant ID for this provisioner. This ID is the Directory ID available in the Azure Active Directory properties.
	TenantID AzureTenantID `json:"tenantID"`
}

// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
type BasicAuth struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// Collection A collection of instances.
type Collection struct {
	// CreatedAt Timestamp in RFC3339 format when the collections was created
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the collection.
	DisplayName string `json:"displayName"`

	// InstanceCount The number of instances in the collection.
	InstanceCount int `json:"instanceCount"`

	// SchemaURI Reference to a schema that all instances in the collection must conform to.
	SchemaURI *string `json:"schemaURI,omitempty"`

	// Slug A lowercase name identifying the collection.
	Slug string `json:"slug"`

	// UpdatedAt Timestamp in RFC3339 format when the collections was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// CollectionInstance An instance in a collection.
type CollectionInstance struct {
	// CreatedAt Timestamp in RFC3339 format when the instance was added to the collection.
	CreatedAt time.Time `json:"createdAt"`

	// Data The instance data.
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp in RFC3339 format when the instance was last changed.
	UpdatedAt time.Time `json:"updatedAt"`
}

// DeviceCollection Configuration to create a new device collection.
type DeviceCollection struct {
	// AdminEmails Users that will have admin access to manage the agents authority, which will be created if it does not already exist. Ignored if the agent authority already exists. Never returned in API responses.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// DeviceType Must match the deviceTypeConfiguration. Cannot be changed.
	DeviceType              DeviceCollectionDeviceType               `json:"deviceType"`
	DeviceTypeConfiguration DeviceCollection_DeviceTypeConfiguration `json:"deviceTypeConfiguration"`
	DisplayName             string                                   `json:"displayName"`
	Slug                    string                                   `json:"slug"`
}

// DeviceCollectionDeviceType Must match the deviceTypeConfiguration. Cannot be changed.
type DeviceCollectionDeviceType string

// DeviceCollection_DeviceTypeConfiguration defines model for DeviceCollection.DeviceTypeConfiguration.
type DeviceCollection_DeviceTypeConfiguration struct {
	union json.RawMessage
}

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizationalUnit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// EndpointCertificateInfo Details on a managed certificate.
type EndpointCertificateInfo struct {
	// CrtFile The filepath where the certificate is to be stored.
	CrtFile *string `json:"crtFile,omitempty"`

	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// Gid GID of the files where the certificate is stored.
	Gid *int `json:"gid,omitempty"`

	// KeyFile The filepath where the key is to be stored.
	KeyFile *string `json:"keyFile,omitempty"`

	// Mode Permission bits of the files where the certificate is stored.
	Mode *int `json:"mode,omitempty"`

	// RootFile The filepath where the root certificate is to be stored.
	RootFile *string `json:"rootFile,omitempty"`

	// Type The type of certificate.
	Type EndpointCertificateInfoType `json:"type"`

	// Uid UID of the files where the certificate is stored.
	Uid *int `json:"uid,omitempty"`
}

// EndpointCertificateInfoType The type of certificate.
type EndpointCertificateInfoType string

// EndpointConfiguration Configuration for a managed endpoint. This object is experimental and subject to change.
type EndpointConfiguration struct {
	// AuthorityID UUID identifying the authority that will issue certificates for the endpoint.
	AuthorityID string `json:"authorityID"`

	// CertificateInfo Details on a managed certificate.
	CertificateInfo EndpointCertificateInfo `json:"certificateInfo"`

	// Hooks The collection of commands to run when a certificate for a managed endpoint is signed or renewed.
	Hooks *EndpointHooks `json:"hooks,omitempty"`

	// Id A UUID identifying this endpoint configuration. Read only.
	Id *string `json:"id,omitempty"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// Kind The kind of endpoint this configuration applies to.
	Kind EndpointConfigurationKind `json:"kind"`

	// Name The name of the endpoint configuration.
	Name string `json:"name"`

	// Provisioner Name of the provisioner on the authority that will authorize certificates for the endpoint.
	Provisioner string `json:"provisioner"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`
}

// EndpointConfigurationKind The kind of endpoint this configuration applies to.
type EndpointConfigurationKind string

// EndpointHook A list of commands to run before and after a certificate is granted.
type EndpointHook struct {
	// After List of commands to run after the operation.
	After *[]string `json:"after,omitempty"`

	// Before List of commands to run before the operation.
	Before *[]string `json:"before,omitempty"`

	// OnError List of commands to run when the operation fails.
	OnError *[]string `json:"onError,omitempty"`

	// Shell The shell to use to execute the commands.
	Shell *string `json:"shell,omitempty"`
}

// EndpointHooks The collection of commands to run when a certificate for a managed endpoint is signed or renewed.
type EndpointHooks struct {
	// Renew A list of commands to run before and after a certificate is granted.
	Renew *EndpointHook `json:"renew,omitempty"`

	// Sign A list of commands to run before and after a certificate is granted.
	Sign *EndpointHook `json:"sign,omitempty"`
}

// EndpointKeyInfo The attributes of the cryptographic key.
type EndpointKeyInfo struct {
	// Format The format used to encode the private key. For X509 keys the default format is SEC 1 for ECDSA keys, PKCS#1 for RSA keys and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format.
	Format *EndpointKeyInfoFormat `json:"format,omitempty"`

	// PubFile A CSR or SSH public key to use instead of generating one.
	PubFile *string `json:"pubFile,omitempty"`

	// Type The key type used. The current DEFAULT type is ECDSA_P256.
	Type *EndpointKeyInfoType `json:"type,omitempty"`
}

// EndpointKeyInfoFormat The format used to encode the private key. For X509 keys the default format is SEC 1 for ECDSA keys, PKCS#1 for RSA keys and PKCS#8 for ED25519 keys. For SSH keys the default format is always the OPENSSH format.
type EndpointKeyInfoFormat string

// EndpointKeyInfoType The key type used. The current DEFAULT type is ECDSA_P256.
type EndpointKeyInfoType string

// EndpointReloadInfo The properties used to reload a service.
type EndpointReloadInfo struct {
	// Method Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`.
	Method EndpointReloadInfoMethod `json:"method"`

	// PidFile File that holds the pid of the process to signal. Required when method is SIGNAL.
	PidFile *string `json:"pidFile,omitempty"`

	// Signal The signal to send to a process when a certificate should be reloaded. Required when method is SIGNAL.
	Signal *int `json:"signal,omitempty"`

	// UnitName The systemd unit name to reload when a certificate should be reloaded. Required when method is DBUS.
	UnitName *string `json:"unitName,omitempty"`
}

// EndpointReloadInfoMethod Ways an endpoint can reload a certificate. `AUTOMATIC` means the process is able to detect and reload new certificates automatically. `CUSTOM` means a custom command must be run to trigger the workload to reload the certificates. `SIGNAL` will configure the agent to send a signal to the process in `pidFile`. `DBUS` will use the systemd system bus to issue a `try-reload-or-restart` job for unit specified by `unitName`.
type EndpointReloadInfoMethod string

// EndpointSSHCertificateData Contains the information to include when granting an SSH certificate to a managed endpoint.
type EndpointSSHCertificateData struct {
	// KeyID The key ID to include in the endpoint certificate.
	KeyID string `json:"keyID"`

	// Principals The principals to include in the endpoint certificate.
	Principals []string `json:"principals"`
}

// EndpointX509CertificateData Contains the information to include when granting an x509 certificate to a managed endpoint.
type EndpointX509CertificateData struct {
	// CommonName The Common Name to be used in the subject of the endpoint certificate.
	CommonName string `json:"commonName"`

	// Sans The list of SANs to include in the endpoint certificate.
	Sans []string `json:"sans"`
}

// EnrollmentToken A JWT that can be used to enroll devices with the Smallstep Agent
type EnrollmentToken struct {
	// Id The unique identifier of the token
	Id *string `json:"id,omitempty"`

	// Secret The JWT itself; this value cannot be retrieved after initially generated and should be kept secret
	Secret *string `json:"secret,omitempty"`

	// Title The name of the token
	Title *string `json:"title,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error.
	Message string `json:"message"`
}

// GcpDisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
type GcpDisableCustomSANs = bool

// GcpProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
type GcpProjectIDs = []string

// GcpProvisioner The [GCP provisioner](https://smallstep.com/docs/step-ca/provisioners/#gcp) grants a certificate to a Google Compute Engine instance using its identity token. At least one service account or project ID must be set.
type GcpProvisioner struct {
	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
	DisableCustomSANs *GcpDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// DisableTrustOnFirstUse By default only one certificate will be granted per instance, but if the option is set to `true` this limit is not set and different tokens can be used to get different certificates.
	DisableTrustOnFirstUse *bool `json:"disableTrustOnFirstUse,omitempty"`

	// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	InstanceAge *InstanceAge `json:"instanceAge,omitempty"`

	// ProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
	ProjectIDs *GcpProjectIDs `json:"projectIDs,omitempty"`

	// ServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
	ServiceAccounts *GcpServiceAccounts `json:"serviceAccounts,omitempty"`
}

// GcpServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
type GcpServiceAccounts = []string

// GcpVM Configuration for the GCP provisioner for device collections of GCP instances. At least one service account or project ID must be set.
type GcpVM struct {
	// DisableCustomSANs By default custom SANs are valid, but if this option is set to `true` only the SANs available in the instance identity document will be valid, these are the DNS `<instance-name>.c.<project-id>.internal` and `<instance-name>.<zone>.c.<project-id>.internal`.
	DisableCustomSANs *GcpDisableCustomSANs `json:"disableCustomSANs,omitempty"`

	// ProjectIDs The list of project identifiers that are allowed to use a GCP cloud provisioner.
	ProjectIDs *GcpProjectIDs `json:"projectIDs,omitempty"`

	// ServiceAccounts The list of service accounts that are allowed to use a GCP cloud provisioner.
	ServiceAccounts *GcpServiceAccounts `json:"serviceAccounts,omitempty"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to.
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant.
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names.
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts.
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values.
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider.
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group.
	Id *string `json:"id,omitempty"`

	// Name The name of the group.
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username.
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered.
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion.
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any.
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp in RFC3339 format when the host was registered.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation.
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host.
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp in RFC3339 format when the host was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// InstanceAge The maximum age of an instance that should be allowed to obtain a certificate. Limits certificate issuance to new instances to mitigate the risk of credential-misuse from instances that don't need a certificate. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
type InstanceAge = string

// JwkProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#jwk) that uses public-key cryptography to sign and validate a JSON Web Token (JWT).
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key.
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key.
	Key interface{} `json:"key"`
}

// ManagedConfiguration The agent and managed endpoints used in one host. This object is experimental and subject to change.
type ManagedConfiguration struct {
	// AgentConfigurationID UUID identifying the agent configuration.
	AgentConfigurationID string `json:"agentConfigurationID"`

	// HostID UUID identifying the host this managed configuration is for. Will be generated on server-side if not provided.
	HostID *string `json:"hostID,omitempty"`

	// Id UUID identifying this managed configuration. Read only.
	Id *string `json:"id,omitempty"`

	// ManagedEndpoints The list of endpoints managed by this configuration.
	ManagedEndpoints []ManagedEndpoint `json:"managedEndpoints"`

	// Name The name of this managed configuration.
	Name string `json:"name"`
}

// ManagedEndpoint All the information used by an agent to grant a certificate to an endpoint. Exactly one of `x509CertificateData` or `sshCertificateData` must be set and must match the endpoint configuration certificate info type. This object is experimental and subject to change.
type ManagedEndpoint struct {
	// EndpointConfigurationID UUID identifying the endpoint configuration.
	EndpointConfigurationID string `json:"endpointConfigurationID"`

	// Id UUID identifying this managed endpoint. Read only.
	Id *string `json:"id,omitempty"`

	// SshCertificateData Contains the information to include when granting an SSH certificate to a managed endpoint.
	SshCertificateData *EndpointSSHCertificateData `json:"sshCertificateData,omitempty"`

	// X509CertificateData Contains the information to include when granting an x509 certificate to a managed endpoint.
	X509CertificateData *EndpointX509CertificateData `json:"x509CertificateData,omitempty"`
}

// NameConstraints X509 certificate name constratins.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical.
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority.
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority.
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority.
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority.
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority.
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority.
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root.
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority.
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority.
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority.
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com.
	Subdomain string `json:"subdomain"`
}

// NewCollection Body of a request to create a new collection.
type NewCollection struct {
	// DisplayName A user-friendly name for the collection.
	DisplayName *string `json:"displayName,omitempty"`

	// SchemaURI Reference to a schema that all instances in the collection must conform to.
	SchemaURI *string `json:"schemaURI,omitempty"`

	// Slug A lowercase name identifying the collection.
	Slug string `json:"slug"`
}

// NewEnrollmentToken The body of a request to generate a new device enrollment token.
type NewEnrollmentToken struct {
	// Title The name of the device enrollment token
	Title *string `json:"title,omitempty"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to.
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag.
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag.
	Value *string `json:"value,omitempty"`
}

// OidcProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#oauthoidc-single-sign-on) that is configured to trust and accept an OAuth provider's ID tokens for authentication. By default, the issued certificate will use the subject (sub) claim from the identity token as its subject. The value of the token's email claim is also included as an email SAN in the certificate.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID.
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group.
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group.
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group.
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user.
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory.
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell.
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user.
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user.
	Username *string `json:"username,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner.
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner.
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh      *SshOptions           `json:"ssh,omitempty"`
	Webhooks *[]ProvisionerWebhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates.
	X509 *X509Options `json:"x509,omitempty"`
}

// ProvisionerWebhook A [webhook](https://smallstep.com/docs/step-ca/webhooks/) to call when a certificate request is being processed.
type ProvisionerWebhook struct {
	// BasicAuth Configures provisioner webhook requests to include an Authorization header with these credentials. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BasicAuth *BasicAuth `json:"basicAuth,omitempty"`

	// BearerToken Webhook requests will include an Authorization header with the token. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers. At most one of `bearerToken` and `basicAuth` may be set.
	BearerToken *string                    `json:"bearerToken,omitempty"`
	CertType    ProvisionerWebhookCertType `json:"certType"`

	// CollectionSlug For HOSTED_ATTESTATION webhooks, the collectionSlug is a reference to the collection that holds the devices that may be issued certificates. This collection must already exist. Required for `HOSTED_ATTESTATION` webhook servers; not allowed for `EXTERNAL`.
	CollectionSlug *string `json:"collectionSlug,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server. Optional for `EXTERNAL` webhook servers; not allowed with hosted webhook servers.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created. Will be sent to the webhook server in every request in the `X-Smallstep-Webhook-ID` header.
	Id *string `json:"id,omitempty"`

	// Kind The webhook kind indicates how and when it is called.
	//
	// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
	Kind ProvisionerWebhookKind `json:"kind"`

	// Name The name of the webhook. For `ENRICHING` webhooks, the returned data can be referenced in the certificate under the path `.Webhooks.<name>`. Must be unique to the provisioner.
	Name string `json:"name"`

	// Secret The shared secret used to authenticate the payload sent to the webhook server. Generated server-side. This is returned only for `EXTERNAL` webhook servers and only once, at the time of creation.
	Secret *string `json:"secret,omitempty"`

	// ServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
	//
	// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
	ServerType ProvisionerWebhookServerType `json:"serverType"`

	// Url The URL of the webhook server. Required for `EXTERNAL` webhook servers; read-only for hosted webhook servers.
	Url *string `json:"url,omitempty"`
}

// ProvisionerWebhookCertType defines model for ProvisionerWebhook.CertType.
type ProvisionerWebhookCertType string

// ProvisionerWebhookKind The webhook kind indicates how and when it is called.
//
// ENRICHING webhooks are called before rendering the certificate template. They have two functions. First, they must allow the certificate request or it will be aborted. Second, they can return additional data to be referenced in the certificate template. The payload sent to the webhook server varies based on whether an X509 or SSH certificate is to be signed and based on the type of provisioner.
type ProvisionerWebhookKind string

// ProvisionerWebhookServerType An EXTERNAL webhook server is not operated by Smallstep. The caller must use the returned ID and secret to configure the server.
//
// A HOSTED_ATTESTATION webhook server is hosted by Smallstep and must be used with an `ENRICHING` webhook type and an ACME Attestation provisioner. The webhook server will verify the attested permanent identifier exists as the ID of an instance in the configured collection. The data of the instance in the collection will be added to the template data.
type ProvisionerWebhookServerType string

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag.
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag.
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag.
	Value *string `json:"value,omitempty"`
}

// Tpm Configuration for a device collection of machines with TPMs.
type Tpm struct {
	// AttestorIntermediates The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority.
	AttestorIntermediates *string `json:"attestorIntermediates,omitempty"`

	// AttestorRoots The pem-encoded list of certificates used to verify the attestation certificates submitted by agents. Ignored if the team already has an attestation authority. Required if the team does not already have an attestation authority.
	AttestorRoots *string `json:"attestorRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider.
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name.
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name.
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name.
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user.
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// Workload A workload represents anything that uses a certificate.
type Workload struct {
	// AdminEmails Users that will have admin access to manage the workloads authority, which will be created if it does not already exist. Ignored if the workloads authority already exists. Never returned in responses.
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CertificateInfo Details on a managed certificate.
	CertificateInfo *EndpointCertificateInfo `json:"certificateInfo,omitempty"`

	// DeviceMetadataKeySANs SANs that will be populated from the instance data of the device in the device collection.
	// For example, if the device instance data in the collection is `{"internal_host": "foo.internal", "external_host", "foo.example.com"}` at the time the workload certificate is issued and this field is set to `["internal_host", "external_host"]`, then the certificate would include the SANs `foo.internal` and `foo.example.com`.
	DeviceMetadataKeySANs *[]string `json:"deviceMetadataKeySANs,omitempty"`

	// DisplayName A friendly name for the workload. Also used as the Common Name if no static SANs are provide.
	DisplayName string `json:"displayName"`

	// Hooks The collection of commands to run when a certificate for a managed endpoint is signed or renewed.
	Hooks *EndpointHooks `json:"hooks,omitempty"`

	// KeyInfo The attributes of the cryptographic key.
	KeyInfo *EndpointKeyInfo `json:"keyInfo,omitempty"`

	// ReloadInfo The properties used to reload a service.
	ReloadInfo *EndpointReloadInfo `json:"reloadInfo,omitempty"`

	// Slug Used as the identifier for the workload.
	Slug string `json:"slug"`

	// StaticSANs SANs that will be added to every certificate issued for this workload. The first will be used as the default Common Name.
	StaticSANs   *[]string `json:"staticSANs,omitempty"`
	WorkloadType string    `json:"workloadType"`
}

// X509Issuer A Customized X509 issuer for an authority.
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm.
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer.
	Name string `json:"name"`

	// NameConstraints X509 certificate name constratins.
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm.
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates.
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// X5cProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#x5c---x509-certificate) that authenticates a certificate request with an existing x509 certificate.
type X5cProvisioner struct {
	// Roots A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
	Roots []string `json:"roots"`
}

// Accept defines model for accept.
type Accept = string

// AgentConfigurationID defines model for agentConfigurationID.
type AgentConfigurationID = string

// AttestationAuthorityID defines model for attestationAuthorityID.
type AttestationAuthorityID = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// CollectionSlug defines model for collectionSlug.
type CollectionSlug = string

// EndpointConfigurationID defines model for endpointConfigurationID.
type EndpointConfigurationID = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InstanceID defines model for instanceID.
type InstanceID = string

// ManagedConfigurationHostID defines model for managedConfigurationHostID.
type ManagedConfigurationHostID = string

// ManagedConfigurationID defines model for managedConfigurationID.
type ManagedConfigurationID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// WebhookNameOrID defines model for webhookNameOrID.
type WebhookNameOrID = string

// WorkloadSlug defines model for workloadSlug.
type WorkloadSlug = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N422 defines model for 422.
type N422 = Error

// N500 defines model for 500.
type N500 = Error

// ListAgentConfigurationsParams defines parameters for ListAgentConfigurations.
type ListAgentConfigurationsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAgentConfigurationsParams defines parameters for PostAgentConfigurations.
type PostAgentConfigurationsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAgentConfigurationParams defines parameters for DeleteAgentConfiguration.
type DeleteAgentConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAgentConfigurationParams defines parameters for GetAgentConfiguration.
type GetAgentConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutAgentConfigurationParams defines parameters for PutAgentConfiguration.
type PutAgentConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAttestationAuthoritiesParams defines parameters for GetAttestationAuthorities.
type GetAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesParams defines parameters for PostAttestationAuthorities.
type PostAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAttestationAuthorityParams defines parameters for DeleteAttestationAuthority.
type DeleteAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAttestationAuthorityParams defines parameters for GetAttestationAuthority.
type GetAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
	TeamSlug *string                   `json:"teamSlug,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostWebhooksParams defines parameters for PostWebhooks.
type PostWebhooksParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWebhookParams defines parameters for DeleteWebhook.
type DeleteWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostCollectionsParams defines parameters for PostCollections.
type PostCollectionsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteCollectionParams defines parameters for DeleteCollection.
type DeleteCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCollectionParams defines parameters for GetCollection.
type GetCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCollectionParams defines parameters for PutCollection.
type PutCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteCollectionInstanceParams defines parameters for DeleteCollectionInstance.
type DeleteCollectionInstanceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCollectionInstanceParams defines parameters for GetCollectionInstance.
type GetCollectionInstanceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCollectionInstanceJSONBody defines parameters for PutCollectionInstance.
type PutCollectionInstanceJSONBody struct {
	Data interface{} `json:"data"`
}

// PutCollectionInstanceParams defines parameters for PutCollectionInstance.
type PutCollectionInstanceParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetCollectionInstanceDataParams defines parameters for GetCollectionInstanceData.
type GetCollectionInstanceDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutCollectionInstanceDataJSONBody defines parameters for PutCollectionInstanceData.
type PutCollectionInstanceDataJSONBody = interface{}

// PutCollectionInstanceDataParams defines parameters for PutCollectionInstanceData.
type PutCollectionInstanceDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListCollectionInstancesParams defines parameters for ListCollectionInstances.
type ListCollectionInstancesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteDeviceCollectionParams defines parameters for DeleteDeviceCollection.
type DeleteDeviceCollectionParams struct {
	// Purge Delete all workloads and devices in the collection.
	// The API will return 422 if the device collection is not empty and the purge flag is not set.
	Purge *bool `form:"purge,omitempty" json:"purge,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetDeviceCollectionParams defines parameters for GetDeviceCollection.
type GetDeviceCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutDeviceCollectionParams defines parameters for PutDeviceCollection.
type PutDeviceCollectionParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteWorkloadParams defines parameters for DeleteWorkload.
type DeleteWorkloadParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetWorkloadParams defines parameters for GetWorkload.
type GetWorkloadParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutWorkloadParams defines parameters for PutWorkload.
type PutWorkloadParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostDeviceEnrollmentTokenParams defines parameters for PostDeviceEnrollmentToken.
type PostDeviceEnrollmentTokenParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListEndpointConfigurationsParams defines parameters for ListEndpointConfigurations.
type ListEndpointConfigurationsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostEndpointConfigurationsParams defines parameters for PostEndpointConfigurations.
type PostEndpointConfigurationsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteEndpointConfigurationParams defines parameters for DeleteEndpointConfiguration.
type DeleteEndpointConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetEndpointConfigurationParams defines parameters for GetEndpointConfiguration.
type GetEndpointConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutEndpointConfigurationParams defines parameters for PutEndpointConfiguration.
type PutEndpointConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to `true` the results will only include active hosts. If set to `false` the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to `true` the results will include only bastion hosts and if set to `false` the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListManagedConfigurationsParams defines parameters for ListManagedConfigurations.
type ListManagedConfigurationsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostManagedConfigurationsParams defines parameters for PostManagedConfigurations.
type PostManagedConfigurationsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteManagedConfigurationHostIdParams defines parameters for DeleteManagedConfigurationHostId.
type DeleteManagedConfigurationHostIdParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetManagedConfigurationHostIdParams defines parameters for GetManagedConfigurationHostId.
type GetManagedConfigurationHostIdParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutManagedConfigurationParams defines parameters for PutManagedConfiguration.
type PutManagedConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteManagedConfigurationParams defines parameters for DeleteManagedConfiguration.
type DeleteManagedConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetManagedConfigurationParams defines parameters for GetManagedConfiguration.
type GetManagedConfigurationParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAgentConfigurationsJSONRequestBody defines body for PostAgentConfigurations for application/json ContentType.
type PostAgentConfigurationsJSONRequestBody = AgentConfiguration

// PutAgentConfigurationJSONRequestBody defines body for PutAgentConfiguration for application/json ContentType.
type PutAgentConfigurationJSONRequestBody = AgentConfiguration

// PostAttestationAuthoritiesJSONRequestBody defines body for PostAttestationAuthorities for application/json ContentType.
type PostAttestationAuthoritiesJSONRequestBody = AttestationAuthority

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostWebhooksJSONRequestBody defines body for PostWebhooks for application/json ContentType.
type PostWebhooksJSONRequestBody = ProvisionerWebhook

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostCollectionsJSONRequestBody defines body for PostCollections for application/json ContentType.
type PostCollectionsJSONRequestBody = NewCollection

// PutCollectionJSONRequestBody defines body for PutCollection for application/json ContentType.
type PutCollectionJSONRequestBody = Collection

// PutCollectionInstanceJSONRequestBody defines body for PutCollectionInstance for application/json ContentType.
type PutCollectionInstanceJSONRequestBody PutCollectionInstanceJSONBody

// PutCollectionInstanceDataJSONRequestBody defines body for PutCollectionInstanceData for application/json ContentType.
type PutCollectionInstanceDataJSONRequestBody = PutCollectionInstanceDataJSONBody

// PutDeviceCollectionJSONRequestBody defines body for PutDeviceCollection for application/json ContentType.
type PutDeviceCollectionJSONRequestBody = DeviceCollection

// PutWorkloadJSONRequestBody defines body for PutWorkload for application/json ContentType.
type PutWorkloadJSONRequestBody = Workload

// PostDeviceEnrollmentTokenJSONRequestBody defines body for PostDeviceEnrollmentToken for application/json ContentType.
type PostDeviceEnrollmentTokenJSONRequestBody = NewEnrollmentToken

// PostEndpointConfigurationsJSONRequestBody defines body for PostEndpointConfigurations for application/json ContentType.
type PostEndpointConfigurationsJSONRequestBody = EndpointConfiguration

// PutEndpointConfigurationJSONRequestBody defines body for PutEndpointConfiguration for application/json ContentType.
type PutEndpointConfigurationJSONRequestBody = EndpointConfiguration

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PostManagedConfigurationsJSONRequestBody defines body for PostManagedConfigurations for application/json ContentType.
type PostManagedConfigurationsJSONRequestBody = ManagedConfiguration

// PutManagedConfigurationJSONRequestBody defines body for PutManagedConfiguration for application/json ContentType.
type PutManagedConfigurationJSONRequestBody = ManagedConfiguration

// AsAwsVM returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a AwsVM
func (t DeviceCollection_DeviceTypeConfiguration) AsAwsVM() (AwsVM, error) {
	var body AwsVM
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsVM overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided AwsVM
func (t *DeviceCollection_DeviceTypeConfiguration) FromAwsVM(v AwsVM) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsVM performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided AwsVM
func (t *DeviceCollection_DeviceTypeConfiguration) MergeAwsVM(v AwsVM) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureVM returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a AzureVM
func (t DeviceCollection_DeviceTypeConfiguration) AsAzureVM() (AzureVM, error) {
	var body AzureVM
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureVM overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided AzureVM
func (t *DeviceCollection_DeviceTypeConfiguration) FromAzureVM(v AzureVM) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureVM performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided AzureVM
func (t *DeviceCollection_DeviceTypeConfiguration) MergeAzureVM(v AzureVM) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGcpVM returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a GcpVM
func (t DeviceCollection_DeviceTypeConfiguration) AsGcpVM() (GcpVM, error) {
	var body GcpVM
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpVM overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided GcpVM
func (t *DeviceCollection_DeviceTypeConfiguration) FromGcpVM(v GcpVM) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpVM performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided GcpVM
func (t *DeviceCollection_DeviceTypeConfiguration) MergeGcpVM(v GcpVM) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTpm returns the union data inside the DeviceCollection_DeviceTypeConfiguration as a Tpm
func (t DeviceCollection_DeviceTypeConfiguration) AsTpm() (Tpm, error) {
	var body Tpm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTpm overwrites any union data inside the DeviceCollection_DeviceTypeConfiguration as the provided Tpm
func (t *DeviceCollection_DeviceTypeConfiguration) FromTpm(v Tpm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTpm performs a merge with any union data inside the DeviceCollection_DeviceTypeConfiguration, using the provided Tpm
func (t *DeviceCollection_DeviceTypeConfiguration) MergeTpm(v Tpm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DeviceCollection_DeviceTypeConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeviceCollection_DeviceTypeConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeProvisioner returns the union data inside the Provisioner as a AcmeProvisioner
func (t Provisioner) AsAcmeProvisioner() (AcmeProvisioner, error) {
	var body AcmeProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeProvisioner overwrites any union data inside the Provisioner as the provided AcmeProvisioner
func (t *Provisioner) FromAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeProvisioner
func (t *Provisioner) MergeAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeAttestationProvisioner returns the union data inside the Provisioner as a AcmeAttestationProvisioner
func (t Provisioner) AsAcmeAttestationProvisioner() (AcmeAttestationProvisioner, error) {
	var body AcmeAttestationProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeAttestationProvisioner overwrites any union data inside the Provisioner as the provided AcmeAttestationProvisioner
func (t *Provisioner) FromAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeAttestationProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeAttestationProvisioner
func (t *Provisioner) MergeAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsX5cProvisioner returns the union data inside the Provisioner as a X5cProvisioner
func (t Provisioner) AsX5cProvisioner() (X5cProvisioner, error) {
	var body X5cProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX5cProvisioner overwrites any union data inside the Provisioner as the provided X5cProvisioner
func (t *Provisioner) FromX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX5cProvisioner performs a merge with any union data inside the Provisioner, using the provided X5cProvisioner
func (t *Provisioner) MergeX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAwsProvisioner returns the union data inside the Provisioner as a AwsProvisioner
func (t Provisioner) AsAwsProvisioner() (AwsProvisioner, error) {
	var body AwsProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsProvisioner overwrites any union data inside the Provisioner as the provided AwsProvisioner
func (t *Provisioner) FromAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsProvisioner performs a merge with any union data inside the Provisioner, using the provided AwsProvisioner
func (t *Provisioner) MergeAwsProvisioner(v AwsProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGcpProvisioner returns the union data inside the Provisioner as a GcpProvisioner
func (t Provisioner) AsGcpProvisioner() (GcpProvisioner, error) {
	var body GcpProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGcpProvisioner overwrites any union data inside the Provisioner as the provided GcpProvisioner
func (t *Provisioner) FromGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGcpProvisioner performs a merge with any union data inside the Provisioner, using the provided GcpProvisioner
func (t *Provisioner) MergeGcpProvisioner(v GcpProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureProvisioner returns the union data inside the Provisioner as a AzureProvisioner
func (t Provisioner) AsAzureProvisioner() (AzureProvisioner, error) {
	var body AzureProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureProvisioner overwrites any union data inside the Provisioner as the provided AzureProvisioner
func (t *Provisioner) FromAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureProvisioner performs a merge with any union data inside the Provisioner, using the provided AzureProvisioner
func (t *Provisioner) MergeAzureProvisioner(v AzureProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Agent Configurations
	// (GET /agent-configurations)
	ListAgentConfigurations(w http.ResponseWriter, r *http.Request, params ListAgentConfigurationsParams)
	// Create Agent Configuration
	// (POST /agent-configurations)
	PostAgentConfigurations(w http.ResponseWriter, r *http.Request, params PostAgentConfigurationsParams)
	// Delete Agent Configuration
	// (DELETE /agent-configurations/{agentConfigurationID})
	DeleteAgentConfiguration(w http.ResponseWriter, r *http.Request, agentConfigurationID AgentConfigurationID, params DeleteAgentConfigurationParams)
	// Get Agent Configuration
	// (GET /agent-configurations/{agentConfigurationID})
	GetAgentConfiguration(w http.ResponseWriter, r *http.Request, agentConfigurationID AgentConfigurationID, params GetAgentConfigurationParams)
	// Update Agent Configuration
	// (PUT /agent-configurations/{agentConfigurationID})
	PutAgentConfiguration(w http.ResponseWriter, r *http.Request, agentConfigurationID AgentConfigurationID, params PutAgentConfigurationParams)
	// List Attestation Authorities
	// (GET /attestation-authorities)
	GetAttestationAuthorities(w http.ResponseWriter, r *http.Request, params GetAttestationAuthoritiesParams)
	// Create New Attestation Authority
	// (POST /attestation-authorities)
	PostAttestationAuthorities(w http.ResponseWriter, r *http.Request, params PostAttestationAuthoritiesParams)
	// Delete Attestation Authority
	// (DELETE /attestation-authorities/{attestationAuthorityID})
	DeleteAttestationAuthority(w http.ResponseWriter, r *http.Request, attestationAuthorityID AttestationAuthorityID, params DeleteAttestationAuthorityParams)
	// Get Attestation Authority
	// (GET /attestation-authorities/{attestationAuthorityID})
	GetAttestationAuthority(w http.ResponseWriter, r *http.Request, attestationAuthorityID AttestationAuthorityID, params GetAttestationAuthorityParams)
	// Authenticate
	// (POST /auth)
	PostAuth(w http.ResponseWriter, r *http.Request)
	// List Authorities
	// (GET /authorities)
	GetAuthorities(w http.ResponseWriter, r *http.Request, params GetAuthoritiesParams)
	// Create New Authority
	// (POST /authorities)
	PostAuthorities(w http.ResponseWriter, r *http.Request, params PostAuthoritiesParams)
	// Create New Authority CSR
	// (POST /authorities/csr)
	PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request, params PostAuthoritiesCsrParams)
	// Delete Authority
	// (DELETE /authorities/{authorityID})
	DeleteAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params DeleteAuthorityParams)
	// Get Authority
	// (GET /authorities/{authorityID})
	GetAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params GetAuthorityParams)
	// List Authority Provisioners
	// (GET /authorities/{authorityID}/provisioners)
	ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params ListAuthorityProvisionersParams)
	// Create Authority Provisioner
	// (POST /authorities/{authorityID}/provisioners)
	PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityProvisionersParams)
	// Delete Provisioner
	// (DELETE /authorities/{authorityID}/provisioners/{provisionerNameOrID})
	DeleteProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params DeleteProvisionerParams)
	// Get Provisioner
	// (GET /authorities/{authorityID}/provisioners/{provisionerNameOrID})
	GetProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params GetProvisionerParams)
	// Create Provisioner Webhook
	// (POST /authorities/{authorityID}/provisioners/{provisionerNameOrID}/webhooks)
	PostWebhooks(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params PostWebhooksParams)
	// Delete Provisioner Webhook
	// (DELETE /authorities/{authorityID}/provisioners/{provisionerNameOrID}/webhooks/{webhookNameOrID})
	DeleteWebhook(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params DeleteWebhookParams)
	// Get Provisioner Webhook
	// (GET /authorities/{authorityID}/provisioners/{provisionerNameOrID}/webhooks/{webhookNameOrID})
	GetWebhook(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, webhookNameOrID WebhookNameOrID, params GetWebhookParams)
	// Post Authority External Root
	// (POST /authorities/{authorityID}/root)
	PostAuthorityRoot(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityRootParams)
	// List Collections
	// (GET /collections)
	ListCollections(w http.ResponseWriter, r *http.Request, params ListCollectionsParams)
	// Create a Collection
	// (POST /collections)
	PostCollections(w http.ResponseWriter, r *http.Request, params PostCollectionsParams)
	// Delete Collection
	// (DELETE /collections/{collectionSlug})
	DeleteCollection(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params DeleteCollectionParams)
	// Get Collection
	// (GET /collections/{collectionSlug})
	GetCollection(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params GetCollectionParams)
	// Update Collection
	// (PUT /collections/{collectionSlug})
	PutCollection(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params PutCollectionParams)
	// Delete Collection Instance
	// (DELETE /collections/{collectionSlug}/instances/{instanceID})
	DeleteCollectionInstance(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, instanceID InstanceID, params DeleteCollectionInstanceParams)
	// Get Collection Instance
	// (GET /collections/{collectionSlug}/instances/{instanceID})
	GetCollectionInstance(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, instanceID InstanceID, params GetCollectionInstanceParams)
	// Save Collection Instance
	// (PUT /collections/{collectionSlug}/instances/{instanceID})
	PutCollectionInstance(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, instanceID InstanceID, params PutCollectionInstanceParams)
	// Get Collection Instance Data
	// (GET /collections/{collectionSlug}/instances/{instanceID}/data)
	GetCollectionInstanceData(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, instanceID InstanceID, params GetCollectionInstanceDataParams)
	// Save Collection Instance Data
	// (PUT /collections/{collectionSlug}/instances/{instanceID}/data)
	PutCollectionInstanceData(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, instanceID InstanceID, params PutCollectionInstanceDataParams)
	// List Collection Instances
	// (GET /collections/{collectionSlug}/items)
	ListCollectionInstances(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params ListCollectionInstancesParams)
	// Delete Device Collection
	// (DELETE /device-collections/{collectionSlug})
	DeleteDeviceCollection(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params DeleteDeviceCollectionParams)
	// Get Device Collection
	// (GET /device-collections/{collectionSlug})
	GetDeviceCollection(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params GetDeviceCollectionParams)
	// Create Device Collection
	// (PUT /device-collections/{collectionSlug})
	PutDeviceCollection(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, params PutDeviceCollectionParams)
	// Delete Workload
	// (DELETE /device-collections/{collectionSlug}/workloads/{workloadSlug})
	DeleteWorkload(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params DeleteWorkloadParams)
	// Get Workload
	// (GET /device-collections/{collectionSlug}/workloads/{workloadSlug})
	GetWorkload(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params GetWorkloadParams)
	// Create Workload
	// (PUT /device-collections/{collectionSlug}/workloads/{workloadSlug})
	PutWorkload(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, workloadSlug WorkloadSlug, params PutWorkloadParams)
	// Generate Device Enrollment Token
	// (POST /device-collections/{collectionSlug}/{instanceID}/enrollment-token)
	PostDeviceEnrollmentToken(w http.ResponseWriter, r *http.Request, collectionSlug CollectionSlug, instanceID InstanceID, params PostDeviceEnrollmentTokenParams)
	// List Endpoint Configurations
	// (GET /endpoint-configurations)
	ListEndpointConfigurations(w http.ResponseWriter, r *http.Request, params ListEndpointConfigurationsParams)
	// Create Endpoint Configuration
	// (POST /endpoint-configurations)
	PostEndpointConfigurations(w http.ResponseWriter, r *http.Request, params PostEndpointConfigurationsParams)
	// Delete Endpoint Configuration
	// (DELETE /endpoint-configurations/{endpointConfigurationID})
	DeleteEndpointConfiguration(w http.ResponseWriter, r *http.Request, endpointConfigurationID EndpointConfigurationID, params DeleteEndpointConfigurationParams)
	// Get Endpoint Configuration
	// (GET /endpoint-configurations/{endpointConfigurationID})
	GetEndpointConfiguration(w http.ResponseWriter, r *http.Request, endpointConfigurationID EndpointConfigurationID, params GetEndpointConfigurationParams)
	// Update Endpoint Configuration
	// (PUT /endpoint-configurations/{endpointConfigurationID})
	PutEndpointConfiguration(w http.ResponseWriter, r *http.Request, endpointConfigurationID EndpointConfigurationID, params PutEndpointConfigurationParams)
	// Get SSH Grants
	// (GET /grants)
	GetSshGrants(w http.ResponseWriter, r *http.Request, params GetSshGrantsParams)
	// Create SSH Grant
	// (POST /grants)
	PostSshGrants(w http.ResponseWriter, r *http.Request, params PostSshGrantsParams)
	// Delete SSH Grant
	// (DELETE /grants/{grantID})
	DeleteSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params DeleteSshGrantParams)
	// Get SSH Grant
	// (GET /grants/{grantID})
	GetSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params GetSshGrantParams)
	// Get SSH Groups
	// (GET /groups)
	GetSshGroups(w http.ResponseWriter, r *http.Request, params GetSshGroupsParams)
	// Get SSH Group
	// (GET /groups/{groupID})
	GetSshGroup(w http.ResponseWriter, r *http.Request, groupID GroupID, params GetSshGroupParams)
	// List SSH Hosts
	// (GET /hosts)
	GetSshHosts(w http.ResponseWriter, r *http.Request, params GetSshHostsParams)
	// Get SSH Host
	// (GET /hosts/{hostID})
	GetSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params GetSshHostParams)
	// Tag SSH Host
	// (POST /hosts/{hostID}/tags)
	PostHostsHostIDTags(w http.ResponseWriter, r *http.Request, hostID HostID, params PostHostsHostIDTagsParams)
	// Unregister SSH Host
	// (POST /hosts/{hostID}/unregister)
	UnregisterSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params UnregisterSshHostParams)
	// List Managed Configurations
	// (GET /managed-configurations)
	ListManagedConfigurations(w http.ResponseWriter, r *http.Request, params ListManagedConfigurationsParams)
	// Create Managed Configuration
	// (POST /managed-configurations)
	PostManagedConfigurations(w http.ResponseWriter, r *http.Request, params PostManagedConfigurationsParams)
	// Delete Managed Configuration By Host ID
	// (DELETE /managed-configurations/host/{managedConfigurationHostID})
	DeleteManagedConfigurationHostId(w http.ResponseWriter, r *http.Request, managedConfigurationHostID ManagedConfigurationHostID, params DeleteManagedConfigurationHostIdParams)
	// Get Managed Configuration By Host ID
	// (GET /managed-configurations/host/{managedConfigurationHostID})
	GetManagedConfigurationHostId(w http.ResponseWriter, r *http.Request, managedConfigurationHostID ManagedConfigurationHostID, params GetManagedConfigurationHostIdParams)
	// Update Managed Configuration
	// (PUT /managed-configurations/host/{managedConfigurationHostID})
	PutManagedConfiguration(w http.ResponseWriter, r *http.Request, managedConfigurationHostID ManagedConfigurationHostID, params PutManagedConfigurationParams)
	// Delete Managed Configuration
	// (DELETE /managed-configurations/{managedConfigurationID})
	DeleteManagedConfiguration(w http.ResponseWriter, r *http.Request, managedConfigurationID ManagedConfigurationID, params DeleteManagedConfigurationParams)
	// Get Managed Configuration
	// (GET /managed-configurations/{managedConfigurationID})
	GetManagedConfiguration(w http.ResponseWriter, r *http.Request, managedConfigurationID ManagedConfigurationID, params GetManagedConfigurationParams)
	// List SSH Host Tags
	// (GET /tags)
	GetSshHostTags(w http.ResponseWriter, r *http.Request, params GetSshHostTagsParams)
	// List SSH Users
	// (GET /users)
	GetSshUsers(w http.ResponseWriter, r *http.Request, params GetSshUsersParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListAgentConfigurations operation middleware
func (siw *ServerInterfaceWrapper) ListAgentConfigurations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAgentConfigurationsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAgentConfigurations(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAgentConfigurations operation middleware
func (siw *ServerInterfaceWrapper) PostAgentConfigurations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAgentConfigurationsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAgentConfigurations(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAgentConfiguration operation middleware
func (siw *ServerInterfaceWrapper) DeleteAgentConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "agentConfigurationID" -------------
	var agentConfigurationID AgentConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "agentConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "agentConfigurationID"), &agentConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "agentConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAgentConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAgentConfiguration(w, r, agentConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAgentConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetAgentConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "agentConfigurationID" -------------
	var agentConfigurationID AgentConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "agentConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "agentConfigurationID"), &agentConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "agentConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAgentConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAgentConfiguration(w, r, agentConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutAgentConfiguration operation middleware
func (siw *ServerInterfaceWrapper) PutAgentConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "agentConfigurationID" -------------
	var agentConfigurationID AgentConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "agentConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "agentConfigurationID"), &agentConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "agentConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAgentConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutAgentConfiguration(w, r, agentConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAttestationAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAttestationAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAttestationAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAttestationAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAttestationAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAttestationAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAttestationAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAttestationAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAttestationAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAttestationAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "attestationAuthorityID" -------------
	var attestationAuthorityID AttestationAuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, chi.URLParam(r, "attestationAuthorityID"), &attestationAuthorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "attestationAuthorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAttestationAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAttestationAuthority(w, r, attestationAuthorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAttestationAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAttestationAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "attestationAuthorityID" -------------
	var attestationAuthorityID AttestationAuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, chi.URLParam(r, "attestationAuthorityID"), &attestationAuthorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "attestationAuthorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAttestationAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAttestationAuthority(w, r, attestationAuthorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuth operation middleware
func (siw *ServerInterfaceWrapper) PostAuth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, MtlsScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuth(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthoritiesCsr operation middleware
func (siw *ServerInterfaceWrapper) PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesCsrParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthoritiesCsr(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteProvisioner operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvisioner(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetProvisioner operation middleware
func (siw *ServerInterfaceWrapper) GetProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvisioner(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostWebhooks operation middleware
func (siw *ServerInterfaceWrapper) PostWebhooks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostWebhooksParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostWebhooks(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteWebhook operation middleware
func (siw *ServerInterfaceWrapper) DeleteWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	// ------------- Path parameter "webhookNameOrID" -------------
	var webhookNameOrID WebhookNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "webhookNameOrID"), &webhookNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "webhookNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteWebhookParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteWebhook(w, r, authorityID, provisionerNameOrID, webhookNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetWebhook operation middleware
func (siw *ServerInterfaceWrapper) GetWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	// ------------- Path parameter "webhookNameOrID" -------------
	var webhookNameOrID WebhookNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "webhookNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "webhookNameOrID"), &webhookNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "webhookNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWebhookParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWebhook(w, r, authorityID, provisionerNameOrID, webhookNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityRoot operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityRoot(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityRootParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityRoot(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListCollections operation middleware
func (siw *ServerInterfaceWrapper) ListCollections(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCollectionsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCollections(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostCollections operation middleware
func (siw *ServerInterfaceWrapper) PostCollections(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCollectionsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCollections(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteCollection operation middleware
func (siw *ServerInterfaceWrapper) DeleteCollection(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCollection(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCollection operation middleware
func (siw *ServerInterfaceWrapper) GetCollection(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCollection(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutCollection operation middleware
func (siw *ServerInterfaceWrapper) PutCollection(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutCollection(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteCollectionInstance operation middleware
func (siw *ServerInterfaceWrapper) DeleteCollectionInstance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "instanceID" -------------
	var instanceID InstanceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, chi.URLParam(r, "instanceID"), &instanceID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instanceID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCollectionInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCollectionInstance(w, r, collectionSlug, instanceID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCollectionInstance operation middleware
func (siw *ServerInterfaceWrapper) GetCollectionInstance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "instanceID" -------------
	var instanceID InstanceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, chi.URLParam(r, "instanceID"), &instanceID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instanceID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCollectionInstance(w, r, collectionSlug, instanceID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutCollectionInstance operation middleware
func (siw *ServerInterfaceWrapper) PutCollectionInstance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "instanceID" -------------
	var instanceID InstanceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, chi.URLParam(r, "instanceID"), &instanceID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instanceID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutCollectionInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutCollectionInstance(w, r, collectionSlug, instanceID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCollectionInstanceData operation middleware
func (siw *ServerInterfaceWrapper) GetCollectionInstanceData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "instanceID" -------------
	var instanceID InstanceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, chi.URLParam(r, "instanceID"), &instanceID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instanceID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionInstanceDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCollectionInstanceData(w, r, collectionSlug, instanceID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutCollectionInstanceData operation middleware
func (siw *ServerInterfaceWrapper) PutCollectionInstanceData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "instanceID" -------------
	var instanceID InstanceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, chi.URLParam(r, "instanceID"), &instanceID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instanceID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutCollectionInstanceDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutCollectionInstanceData(w, r, collectionSlug, instanceID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListCollectionInstances operation middleware
func (siw *ServerInterfaceWrapper) ListCollectionInstances(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCollectionInstancesParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCollectionInstances(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteDeviceCollection operation middleware
func (siw *ServerInterfaceWrapper) DeleteDeviceCollection(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceCollectionParams

	// ------------- Optional query parameter "purge" -------------

	err = runtime.BindQueryParameter("form", true, false, "purge", r.URL.Query(), &params.Purge)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "purge", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDeviceCollection(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDeviceCollection operation middleware
func (siw *ServerInterfaceWrapper) GetDeviceCollection(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDeviceCollection(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutDeviceCollection operation middleware
func (siw *ServerInterfaceWrapper) PutDeviceCollection(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutDeviceCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutDeviceCollection(w, r, collectionSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteWorkload operation middleware
func (siw *ServerInterfaceWrapper) DeleteWorkload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "workloadSlug" -------------
	var workloadSlug WorkloadSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "workloadSlug", runtime.ParamLocationPath, chi.URLParam(r, "workloadSlug"), &workloadSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workloadSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteWorkloadParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteWorkload(w, r, collectionSlug, workloadSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetWorkload operation middleware
func (siw *ServerInterfaceWrapper) GetWorkload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "workloadSlug" -------------
	var workloadSlug WorkloadSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "workloadSlug", runtime.ParamLocationPath, chi.URLParam(r, "workloadSlug"), &workloadSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workloadSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorkloadParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorkload(w, r, collectionSlug, workloadSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutWorkload operation middleware
func (siw *ServerInterfaceWrapper) PutWorkload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "workloadSlug" -------------
	var workloadSlug WorkloadSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "workloadSlug", runtime.ParamLocationPath, chi.URLParam(r, "workloadSlug"), &workloadSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workloadSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutWorkloadParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutWorkload(w, r, collectionSlug, workloadSlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostDeviceEnrollmentToken operation middleware
func (siw *ServerInterfaceWrapper) PostDeviceEnrollmentToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "collectionSlug" -------------
	var collectionSlug CollectionSlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "collectionSlug", runtime.ParamLocationPath, chi.URLParam(r, "collectionSlug"), &collectionSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collectionSlug", Err: err})
		return
	}

	// ------------- Path parameter "instanceID" -------------
	var instanceID InstanceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "instanceID", runtime.ParamLocationPath, chi.URLParam(r, "instanceID"), &instanceID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instanceID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostDeviceEnrollmentTokenParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeviceEnrollmentToken(w, r, collectionSlug, instanceID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListEndpointConfigurations operation middleware
func (siw *ServerInterfaceWrapper) ListEndpointConfigurations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEndpointConfigurationsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEndpointConfigurations(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostEndpointConfigurations operation middleware
func (siw *ServerInterfaceWrapper) PostEndpointConfigurations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEndpointConfigurationsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostEndpointConfigurations(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteEndpointConfiguration operation middleware
func (siw *ServerInterfaceWrapper) DeleteEndpointConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "endpointConfigurationID" -------------
	var endpointConfigurationID EndpointConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "endpointConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "endpointConfigurationID"), &endpointConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endpointConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteEndpointConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteEndpointConfiguration(w, r, endpointConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEndpointConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetEndpointConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "endpointConfigurationID" -------------
	var endpointConfigurationID EndpointConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "endpointConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "endpointConfigurationID"), &endpointConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endpointConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEndpointConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEndpointConfiguration(w, r, endpointConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutEndpointConfiguration operation middleware
func (siw *ServerInterfaceWrapper) PutEndpointConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "endpointConfigurationID" -------------
	var endpointConfigurationID EndpointConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "endpointConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "endpointConfigurationID"), &endpointConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endpointConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutEndpointConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutEndpointConfiguration(w, r, endpointConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrants operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostSshGrants operation middleware
func (siw *ServerInterfaceWrapper) PostSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSshGrant operation middleware
func (siw *ServerInterfaceWrapper) DeleteSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrant operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroups operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroups(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroup operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithLocation("simple", false, "groupID", runtime.ParamLocationPath, chi.URLParam(r, "groupID"), &groupID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroup(w, r, groupID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHosts operation middleware
func (siw *ServerInterfaceWrapper) GetSshHosts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostsParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", r.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "active", Err: err})
		return
	}

	// ------------- Optional query parameter "bastion" -------------

	err = runtime.BindQueryParameter("form", true, false, "bastion", r.URL.Query(), &params.Bastion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bastion", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHosts(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHost operation middleware
func (siw *ServerInterfaceWrapper) GetSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostHostsHostIDTags operation middleware
func (siw *ServerInterfaceWrapper) PostHostsHostIDTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostHostsHostIDTagsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostHostsHostIDTags(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UnregisterSshHost operation middleware
func (siw *ServerInterfaceWrapper) UnregisterSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnregisterSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListManagedConfigurations operation middleware
func (siw *ServerInterfaceWrapper) ListManagedConfigurations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListManagedConfigurationsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListManagedConfigurations(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostManagedConfigurations operation middleware
func (siw *ServerInterfaceWrapper) PostManagedConfigurations(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostManagedConfigurationsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostManagedConfigurations(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteManagedConfigurationHostId operation middleware
func (siw *ServerInterfaceWrapper) DeleteManagedConfigurationHostId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "managedConfigurationHostID" -------------
	var managedConfigurationHostID ManagedConfigurationHostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "managedConfigurationHostID", runtime.ParamLocationPath, chi.URLParam(r, "managedConfigurationHostID"), &managedConfigurationHostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "managedConfigurationHostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteManagedConfigurationHostIdParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteManagedConfigurationHostId(w, r, managedConfigurationHostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetManagedConfigurationHostId operation middleware
func (siw *ServerInterfaceWrapper) GetManagedConfigurationHostId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "managedConfigurationHostID" -------------
	var managedConfigurationHostID ManagedConfigurationHostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "managedConfigurationHostID", runtime.ParamLocationPath, chi.URLParam(r, "managedConfigurationHostID"), &managedConfigurationHostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "managedConfigurationHostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetManagedConfigurationHostIdParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetManagedConfigurationHostId(w, r, managedConfigurationHostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutManagedConfiguration operation middleware
func (siw *ServerInterfaceWrapper) PutManagedConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "managedConfigurationHostID" -------------
	var managedConfigurationHostID ManagedConfigurationHostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "managedConfigurationHostID", runtime.ParamLocationPath, chi.URLParam(r, "managedConfigurationHostID"), &managedConfigurationHostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "managedConfigurationHostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutManagedConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutManagedConfiguration(w, r, managedConfigurationHostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteManagedConfiguration operation middleware
func (siw *ServerInterfaceWrapper) DeleteManagedConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "managedConfigurationID" -------------
	var managedConfigurationID ManagedConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "managedConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "managedConfigurationID"), &managedConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "managedConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteManagedConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteManagedConfiguration(w, r, managedConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetManagedConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetManagedConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "managedConfigurationID" -------------
	var managedConfigurationID ManagedConfigurationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "managedConfigurationID", runtime.ParamLocationPath, chi.URLParam(r, "managedConfigurationID"), &managedConfigurationID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "managedConfigurationID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetManagedConfigurationParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetManagedConfiguration(w, r, managedConfigurationID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHostTags operation middleware
func (siw *ServerInterfaceWrapper) GetSshHostTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostTagsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHostTags(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshUsers operation middleware
func (siw *ServerInterfaceWrapper) GetSshUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshUsersParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshUsers(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/agent-configurations", wrapper.ListAgentConfigurations)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/agent-configurations", wrapper.PostAgentConfigurations)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/agent-configurations/{agentConfigurationID}", wrapper.DeleteAgentConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/agent-configurations/{agentConfigurationID}", wrapper.GetAgentConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/agent-configurations/{agentConfigurationID}", wrapper.PutAgentConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/attestation-authorities", wrapper.GetAttestationAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/attestation-authorities", wrapper.PostAttestationAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/attestation-authorities/{attestationAuthorityID}", wrapper.DeleteAttestationAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/attestation-authorities/{attestationAuthorityID}", wrapper.GetAttestationAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth", wrapper.PostAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities", wrapper.GetAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities", wrapper.PostAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/csr", wrapper.PostAuthoritiesCsr)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}", wrapper.DeleteAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}", wrapper.GetAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.ListAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.PostAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}", wrapper.DeleteProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}", wrapper.GetProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}/webhooks", wrapper.PostWebhooks)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}/webhooks/{webhookNameOrID}", wrapper.DeleteWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}/webhooks/{webhookNameOrID}", wrapper.GetWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/root", wrapper.PostAuthorityRoot)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections", wrapper.ListCollections)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/collections", wrapper.PostCollections)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/collections/{collectionSlug}", wrapper.DeleteCollection)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collectionSlug}", wrapper.GetCollection)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/collections/{collectionSlug}", wrapper.PutCollection)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/collections/{collectionSlug}/instances/{instanceID}", wrapper.DeleteCollectionInstance)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collectionSlug}/instances/{instanceID}", wrapper.GetCollectionInstance)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/collections/{collectionSlug}/instances/{instanceID}", wrapper.PutCollectionInstance)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collectionSlug}/instances/{instanceID}/data", wrapper.GetCollectionInstanceData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/collections/{collectionSlug}/instances/{instanceID}/data", wrapper.PutCollectionInstanceData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collectionSlug}/items", wrapper.ListCollectionInstances)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/device-collections/{collectionSlug}", wrapper.DeleteDeviceCollection)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/device-collections/{collectionSlug}", wrapper.GetDeviceCollection)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/device-collections/{collectionSlug}", wrapper.PutDeviceCollection)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/device-collections/{collectionSlug}/workloads/{workloadSlug}", wrapper.DeleteWorkload)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/device-collections/{collectionSlug}/workloads/{workloadSlug}", wrapper.GetWorkload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/device-collections/{collectionSlug}/workloads/{workloadSlug}", wrapper.PutWorkload)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/device-collections/{collectionSlug}/{instanceID}/enrollment-token", wrapper.PostDeviceEnrollmentToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/endpoint-configurations", wrapper.ListEndpointConfigurations)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/endpoint-configurations", wrapper.PostEndpointConfigurations)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/endpoint-configurations/{endpointConfigurationID}", wrapper.DeleteEndpointConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/endpoint-configurations/{endpointConfigurationID}", wrapper.GetEndpointConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/endpoint-configurations/{endpointConfigurationID}", wrapper.PutEndpointConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants", wrapper.GetSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/grants", wrapper.PostSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/grants/{grantID}", wrapper.DeleteSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants/{grantID}", wrapper.GetSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.GetSshGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{groupID}", wrapper.GetSshGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts", wrapper.GetSshHosts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts/{hostID}", wrapper.GetSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/tags", wrapper.PostHostsHostIDTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/unregister", wrapper.UnregisterSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/managed-configurations", wrapper.ListManagedConfigurations)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/managed-configurations", wrapper.PostManagedConfigurations)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/managed-configurations/host/{managedConfigurationHostID}", wrapper.DeleteManagedConfigurationHostId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/managed-configurations/host/{managedConfigurationHostID}", wrapper.GetManagedConfigurationHostId)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/managed-configurations/host/{managedConfigurationHostID}", wrapper.PutManagedConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/managed-configurations/{managedConfigurationID}", wrapper.DeleteManagedConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/managed-configurations/{managedConfigurationID}", wrapper.GetManagedConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetSshHostTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.GetSshUsers)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"o/5fAAAA//8j+h0FnMcBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
