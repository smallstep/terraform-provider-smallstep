// Package v20230301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20230301

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Authority An X509 authority hosted by Smallstep
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only)
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// CreatedAt Timestamp when the authority was created
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority
	Id string `json:"id"`

	// Name The name of the authority
	Name string `json:"name"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error
	Message string `json:"message"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group
	Id *string `json:"id,omitempty"`

	// Name The name of the group
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp when the host was registered
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp when the host was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Inventory A collection of items
type Inventory struct {
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the inventory
	DisplayName string `json:"displayName"`

	// ItemCount The number of items in the inventory
	ItemCount int `json:"itemCount"`

	// Slug A lowercase name identifying the inventory.
	Slug      string    `json:"slug"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// InventoryItem An item in an inventory
type InventoryItem struct {
	// CreatedAt Timestamp of when the item was added to the inventory
	CreatedAt time.Time `json:"createdAt"`

	// Data The item data
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp of when the item was last changed
	UpdatedAt time.Time `json:"updatedAt"`
}

// NameConstraints defines model for name-constraints.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewInventory A collection of items
type NewInventory struct {
	// DisplayName A user-friendly name for the inventory
	DisplayName *string `json:"displayName,omitempty"`

	// Slug A lowercase name identifying the inventory.
	Slug string `json:"slug"`
}

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user
	Username *string `json:"username,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// X509Issuer A Customized X509 issuer for an authority
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer
	Name            string           `json:"name"`
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm
type X509IssuerKeyVersion string

// Accept defines model for accept.
type Accept = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InventorySlug defines model for inventorySlug.
type InventorySlug = string

// ItemID defines model for itemID.
type ItemID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// RequestID defines model for requestID.
type RequestID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N500 defines model for 500.
type N500 = Error

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Bundle *[]openapi_types.File `json:"bundle,omitempty"`
	TeamID *string               `json:"teamID,omitempty"`
}

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to true the results will only include active hosts. If set to false the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to true the results will include only bastion hosts and if set to false the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoriesParams defines parameters for ListInventories.
type ListInventoriesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostInventoriesParams defines parameters for PostInventories.
type PostInventoriesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryParams defines parameters for DeleteInventory.
type DeleteInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryParams defines parameters for GetInventory.
type GetInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoryItemsParams defines parameters for ListInventoryItems.
type ListInventoryItemsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryItemParams defines parameters for DeleteInventoryItem.
type DeleteInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemParams defines parameters for GetInventoryItem.
type GetInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemJSONBody defines parameters for PutInventoryItem.
type PutInventoryItemJSONBody struct {
	Data interface{} `json:"data"`
}

// PutInventoryItemParams defines parameters for PutInventoryItem.
type PutInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemDataParams defines parameters for GetInventoryItemData.
type GetInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemDataJSONBody defines parameters for PutInventoryItemData.
type PutInventoryItemDataJSONBody = interface{}

// PutInventoryItemDataParams defines parameters for PutInventoryItemData.
type PutInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PostInventoriesJSONRequestBody defines body for PostInventories for application/json ContentType.
type PostInventoriesJSONRequestBody = NewInventory

// PutInventoryItemJSONRequestBody defines body for PutInventoryItem for application/json ContentType.
type PutInventoryItemJSONRequestBody PutInventoryItemJSONBody

// PutInventoryItemDataJSONRequestBody defines body for PutInventoryItemData for application/json ContentType.
type PutInventoryItemDataJSONRequestBody = PutInventoryItemDataJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate
	// (POST /auth)
	PostAuth(w http.ResponseWriter, r *http.Request)
	// List Authorities
	// (GET /authorities)
	GetAuthorities(w http.ResponseWriter, r *http.Request, params GetAuthoritiesParams)
	// Create New Authority
	// (POST /authorities)
	PostAuthorities(w http.ResponseWriter, r *http.Request, params PostAuthoritiesParams)
	// Create New Authority CSR
	// (POST /authorities/csr)
	PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request, params PostAuthoritiesCsrParams)
	// Delete Authority
	// (DELETE /authorities/{authorityID})
	DeleteAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params DeleteAuthorityParams)
	// Get Authority
	// (GET /authorities/{authorityID})
	GetAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params GetAuthorityParams)
	// Post Authority External Root
	// (POST /authorities/{authorityID}/root)
	PostAuthorityRoot(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityRootParams)
	// Get SSH Grants
	// (GET /grants)
	GetSshGrants(w http.ResponseWriter, r *http.Request, params GetSshGrantsParams)
	// Create SSH Grant
	// (POST /grants)
	PostSshGrants(w http.ResponseWriter, r *http.Request, params PostSshGrantsParams)
	// Delete SSH Grant
	// (DELETE /grants/{grantID})
	DeleteSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params DeleteSshGrantParams)
	// Get SSH Grant
	// (GET /grants/{grantID})
	GetSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params GetSshGrantParams)
	// Get SSH Groups
	// (GET /groups)
	GetSshGroups(w http.ResponseWriter, r *http.Request, params GetSshGroupsParams)
	// Get SSH Group
	// (GET /groups/{groupID})
	GetSshGroup(w http.ResponseWriter, r *http.Request, groupID GroupID, params GetSshGroupParams)
	// Get SSH Hosts
	// (GET /hosts)
	GetSshHosts(w http.ResponseWriter, r *http.Request, params GetSshHostsParams)
	// Get SSH Host
	// (GET /hosts/{hostID})
	GetSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params GetSshHostParams)
	// Tag SSH Host
	// (POST /hosts/{hostID}/tags)
	PostHostsHostIDTags(w http.ResponseWriter, r *http.Request, hostID HostID, params PostHostsHostIDTagsParams)
	// Unregister SSH Host
	// (POST /hosts/{hostID}/unregister)
	UnregisterSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params UnregisterSshHostParams)
	// List Inventories
	// (GET /inventories)
	ListInventories(w http.ResponseWriter, r *http.Request, params ListInventoriesParams)
	// Create an Inventory
	// (POST /inventories)
	PostInventories(w http.ResponseWriter, r *http.Request, params PostInventoriesParams)
	// Delete Inventory
	// (DELETE /inventories/{inventorySlug})
	DeleteInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params DeleteInventoryParams)
	// Get Inventory
	// (GET /inventories/{inventorySlug})
	GetInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params GetInventoryParams)
	// List Inventory Items
	// (GET /inventories/{inventorySlug}/items)
	ListInventoryItems(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params ListInventoryItemsParams)
	// Delete Inventory Item
	// (DELETE /inventories/{inventorySlug}/items/{itemID})
	DeleteInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params DeleteInventoryItemParams)
	// Get Inventory Item
	// (GET /inventories/{inventorySlug}/items/{itemID})
	GetInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemParams)
	// Save Inventory Item
	// (PUT /inventories/{inventorySlug}/items/{itemID})
	PutInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemParams)
	// Get Inventory Item Data
	// (GET /inventories/{inventorySlug}/items/{itemID}/data)
	GetInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemDataParams)
	// Save Inventory Item Data
	// (PUT /inventories/{inventorySlug}/items/{itemID}/data)
	PutInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemDataParams)
	// Get SSH Host Tags
	// (GET /tags)
	GetSshHostTags(w http.ResponseWriter, r *http.Request, params GetSshHostTagsParams)
	// Get SSH Users
	// (GET /users)
	GetSshUsers(w http.ResponseWriter, r *http.Request, params GetSshUsersParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostAuth operation middleware
func (siw *ServerInterfaceWrapper) PostAuth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, MtlsScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuth(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthoritiesCsr operation middleware
func (siw *ServerInterfaceWrapper) PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesCsrParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthoritiesCsr(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityRoot operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityRoot(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityRootParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityRoot(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrants operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostSshGrants operation middleware
func (siw *ServerInterfaceWrapper) PostSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSshGrant operation middleware
func (siw *ServerInterfaceWrapper) DeleteSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrant operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroups operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroups(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroup operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithLocation("simple", false, "groupID", runtime.ParamLocationPath, chi.URLParam(r, "groupID"), &groupID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroup(w, r, groupID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHosts operation middleware
func (siw *ServerInterfaceWrapper) GetSshHosts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostsParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", r.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "active", Err: err})
		return
	}

	// ------------- Optional query parameter "bastion" -------------

	err = runtime.BindQueryParameter("form", true, false, "bastion", r.URL.Query(), &params.Bastion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bastion", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHosts(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHost operation middleware
func (siw *ServerInterfaceWrapper) GetSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostHostsHostIDTags operation middleware
func (siw *ServerInterfaceWrapper) PostHostsHostIDTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostHostsHostIDTagsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostHostsHostIDTags(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UnregisterSshHost operation middleware
func (siw *ServerInterfaceWrapper) UnregisterSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnregisterSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventories operation middleware
func (siw *ServerInterfaceWrapper) ListInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoriesParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostInventories operation middleware
func (siw *ServerInterfaceWrapper) PostInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostInventoriesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventory operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventory operation middleware
func (siw *ServerInterfaceWrapper) GetInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventoryItems operation middleware
func (siw *ServerInterfaceWrapper) ListInventoryItems(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoryItemsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventoryItems(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHostTags operation middleware
func (siw *ServerInterfaceWrapper) GetSshHostTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostTagsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHostTags(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshUsers operation middleware
func (siw *ServerInterfaceWrapper) GetSshUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshUsersParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshUsers(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth", wrapper.PostAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities", wrapper.GetAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities", wrapper.PostAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/csr", wrapper.PostAuthoritiesCsr)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}", wrapper.DeleteAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}", wrapper.GetAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/root", wrapper.PostAuthorityRoot)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants", wrapper.GetSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/grants", wrapper.PostSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/grants/{grantID}", wrapper.DeleteSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants/{grantID}", wrapper.GetSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.GetSshGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{groupID}", wrapper.GetSshGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts", wrapper.GetSshHosts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts/{hostID}", wrapper.GetSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/tags", wrapper.PostHostsHostIDTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/unregister", wrapper.UnregisterSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories", wrapper.ListInventories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/inventories", wrapper.PostInventories)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}", wrapper.DeleteInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}", wrapper.GetInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items", wrapper.ListInventoryItems)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.DeleteInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.GetInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.PutInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.GetInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.PutInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetSshHostTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.GetSshUsers)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wIAAP//LWIeIzOyAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
