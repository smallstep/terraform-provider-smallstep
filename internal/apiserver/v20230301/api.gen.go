// Package v20230301 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package v20230301

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	JWTScopes  = "JWT.Scopes"
	MtlsScopes = "mtls.Scopes"
)

// Defines values for AcmeAttestationProvisionerAttestationFormats.
const (
	Apple AcmeAttestationProvisionerAttestationFormats = "apple"
	Step  AcmeAttestationProvisionerAttestationFormats = "step"
	Tpm   AcmeAttestationProvisionerAttestationFormats = "tpm"
)

// Defines values for AcmeProvisionerChallenges.
const (
	Dns01     AcmeProvisionerChallenges = "dns-01"
	Http01    AcmeProvisionerChallenges = "http-01"
	TlsAlpn01 AcmeProvisionerChallenges = "tls-alpn-01"
)

// Defines values for AuthorityType.
const (
	AuthorityTypeAdvanced AuthorityType = "advanced"
	AuthorityTypeDevops   AuthorityType = "devops"
)

// Defines values for NewAuthorityType.
const (
	NewAuthorityTypeAdvanced NewAuthorityType = "advanced"
	NewAuthorityTypeDevops   NewAuthorityType = "devops"
)

// Defines values for ProvisionerType.
const (
	ACME            ProvisionerType = "ACME"
	ACMEATTESTATION ProvisionerType = "ACME_ATTESTATION"
	JWK             ProvisionerType = "JWK"
	OIDC            ProvisionerType = "OIDC"
	X5C             ProvisionerType = "X5C"
)

// Defines values for WebhookCertType.
const (
	ALL  WebhookCertType = "ALL"
	SSH  WebhookCertType = "SSH"
	X509 WebhookCertType = "X509"
)

// Defines values for X509IssuerKeyVersion.
const (
	ECSIGNP256SHA256       X509IssuerKeyVersion = "EC_SIGN_P256_SHA256"
	ECSIGNP384SHA384       X509IssuerKeyVersion = "EC_SIGN_P384_SHA384"
	RSASIGNPKCS12048SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_2048_SHA256"
	RSASIGNPKCS13072SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_3072_SHA256"
	RSASIGNPKCS14096SHA256 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA256"
	RSASIGNPKCS14096SHA512 X509IssuerKeyVersion = "RSA_SIGN_PKCS1_4096_SHA512"
	RSASIGNPSS2048SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_2048_SHA256"
	RSASIGNPSS3072SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_3072_SHA256"
	RSASIGNPSS4096SHA256   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA256"
	RSASIGNPSS4096SHA512   X509IssuerKeyVersion = "RSA_SIGN_PSS_4096_SHA512"
)

// Defines values for PostAuthJSONBodyAudience.
const (
	StepAgent PostAuthJSONBodyAudience = "step-agent"
)

// AcmeAttestationProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [device-attest-01 challenge of the ACME protocol](https://smallstep.com/blog/acme-managed-device-attestation-explained/).
type AcmeAttestationProvisioner struct {
	// AttestationFormats The allowed attestation formats for the device-attest-01 challenge. Valid values are apple, step, and tpm. The apple format is for Apple devices, and adds trust for Apple's CAs. The step format is for non-TPM devices that can issue attestation certificates, such as YubiKey PIV. It adds trust for Yubico's root CA. The tpm format is for TPMs and does not trust any CAs by default.
	AttestationFormats []AcmeAttestationProvisionerAttestationFormats `json:"attestationFormats"`

	// AttestationRoots A trust bundle of root certificates in PEM format that will be used to verify attestation certificates. The default value depends on the value of attestationFormats. If provided, this PEM bundle will override the CA trust established by setting attestationFormats to apple or step. At least one root certificate is required when using the tpm attestationFormat.
	AttestationRoots *[]string `json:"attestationRoots,omitempty"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner.
	RequireEAB *bool `json:"requireEAB,omitempty"`
}

// AcmeAttestationProvisionerAttestationFormats defines model for AcmeAttestationProvisioner.AttestationFormats.
type AcmeAttestationProvisionerAttestationFormats string

// AcmeProvisioner A [provisioner](https://smallstep.com/docs/step-ca/provisioners/#acme) that enables automation with the [ACME protocol](https://smallstep.com/docs/step-ca/acme-basics/#acme-challenges).
type AcmeProvisioner struct {
	// Challenges Which ACME challenge types are allowed.
	Challenges []AcmeProvisionerChallenges `json:"challenges"`

	// ForceCN Force one of the SANs to become the Common Name, if a Common Name is not provided.
	ForceCN *bool `json:"forceCN,omitempty"`

	// RequireEAB Only ACME clients that have been preconfigured with valid EAB credentials will be able to create an account with this provisioner. Must be true for all new provisioners.
	RequireEAB bool `json:"requireEAB"`
}

// AcmeProvisionerChallenges defines model for AcmeProvisioner.Challenges.
type AcmeProvisionerChallenges string

// AttestationAuthority An attestation authority used with the device-attest-01 ACME challenge to verify a device's hardware identity. This object is experimental and subject to change.
type AttestationAuthority struct {
	// AttestorIntermediates The pem-encoded list of intermediate certificates used to build a chain of trust to verify the attestation certificates submitted by devices.
	AttestorIntermediates *string `json:"attestorIntermediates,omitempty"`

	// AttestorRoots The pem-encoded list of certificates used to verify the attestation certificates submitted by devices.
	AttestorRoots string `json:"attestorRoots"`

	// Catalog The slug of an inventory that holds the list of devices belonging to the team
	Catalog string `json:"catalog"`

	// CreatedAt Timestamp in RFC3339 format when the attestation authority was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this attestation authority. Generated server-side.
	Id *string `json:"id,omitempty"`

	// Name The name of the attestation authority
	Name string `json:"name"`

	// Root The pem-encoded root certificate of this attestation authority. This is generated server-side when the attestation authority is created. This certificate should be used in the `attestationRoots` field of an ACME_ATTESTATION provisioner with the `tpm` format.
	Root *string `json:"root,omitempty"`

	// Slug A short name for this attestation authority. Read only.
	Slug *string `json:"slug,omitempty"`
}

// Authority An X509 authority hosted by Smallstep
type Authority struct {
	// ActiveRevocation Whether CRL and OCSP are enabled (advanced authorities only)
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that have admin access to manage the authority
	AdminEmails *[]string `json:"adminEmails,omitempty"`

	// CreatedAt Timestamp when the authority was created
	CreatedAt time.Time `json:"createdAt"`

	// Domain The domain where the authority can be reached
	Domain string `json:"domain"`

	// Fingerprint The SHA-256 digest of the authority's root certificate in hex format
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id A UUID identifying this authority
	Id string `json:"id"`

	// Name The name of the authority
	Name string `json:"name"`

	// Type One of the available authority types
	Type AuthorityType `json:"type"`
}

// AuthorityCsr A certificate signing request for an X509 advanced authority with an external root
type AuthorityCsr struct {
	// AuthorityID A UUID identifying the authority
	AuthorityID string `json:"authorityID"`

	// Csr A certificate sigining request for the authority's intermediate issuer in pem format
	Csr string `json:"csr"`

	// Id A UUID identifying this CSR
	Id string `json:"id"`
}

// AuthorityType One of the available authority types
type AuthorityType string

// DistinguishedName Name used in x509 certificates
type DistinguishedName struct {
	CommonName         *string `json:"commonName,omitempty"`
	Country            *string `json:"country,omitempty"`
	EmailAddress       *string `json:"emailAddress,omitempty"`
	Locality           *string `json:"locality,omitempty"`
	Organization       *string `json:"organization,omitempty"`
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`
	PostalCode         *string `json:"postalCode,omitempty"`
	Province           *string `json:"province,omitempty"`
	SerialNumber       *string `json:"serialNumber,omitempty"`
	StreetAddress      *string `json:"streetAddress,omitempty"`
}

// Email Email is a subresource of an SSH User.
type Email struct {
	Email   *string `json:"email,omitempty"`
	Primary *bool   `json:"primary,omitempty"`
}

// Error defines model for error.
type Error struct {
	// Message A description of the error
	Message string `json:"message"`
}

// Grant A grant gives permission to all users in a group to access a host with a matching tag.
type Grant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID *string `json:"groupID,omitempty"`

	// Id A UUID identifying this grant
	Id *string `json:"id,omitempty"`

	// Name Matched against host tag names
	Name *string `json:"name,omitempty"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// Group A group is a set of users that have been synced from an identity provider
type Group struct {
	HostGrants *[]Grant `json:"hostGrants,omitempty"`

	// Id A UUID identifying the group
	Id *string `json:"id,omitempty"`

	// Name The name of the group
	Name        *string       `json:"name,omitempty"`
	PosixGroups *[]PosixGroup `json:"posixGroups,omitempty"`

	// Principals Additional principals that will be appended to users' certilficates, in addition to the user's email and POSIX username
	Principals *[]string `json:"principals,omitempty"`
}

// Host A host where Smallstep has been installed to manage SSH access.
type Host struct {
	// Active A host is active until it is unregistered
	Active *bool `json:"active,omitempty"`

	// Bastion Whether or not this host is a bastion
	Bastion *bool `json:"bastion,omitempty"`

	// BastionHostname The hostname of the bastion server required to access this host, if any
	BastionHostname *string `json:"bastionHostname,omitempty"`

	// CreatedAt Timestamp when the host was registered
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Hostname The hostname detected during installation
	Hostname *string `json:"hostname,omitempty"`

	// Id A UUID identifying this host
	Id   *string `json:"id,omitempty"`
	Tags *[]Tag  `json:"tags,omitempty"`

	// UpdatedAt Timestamp when the host was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Inventory A collection of items
type Inventory struct {
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName A user-friendly name for the inventory
	DisplayName string `json:"displayName"`

	// ItemCount The number of items in the inventory
	ItemCount int `json:"itemCount"`

	// Slug A lowercase name identifying the inventory.
	Slug      string    `json:"slug"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// InventoryItem An item in an inventory
type InventoryItem struct {
	// CreatedAt Timestamp of when the item was added to the inventory
	CreatedAt time.Time `json:"createdAt"`

	// Data The item data
	Data interface{} `json:"data"`
	Id   string      `json:"id"`

	// UpdatedAt Timestamp of when the item was last changed
	UpdatedAt time.Time `json:"updatedAt"`
}

// JwkProvisioner defines model for jwkProvisioner.
type JwkProvisioner struct {
	// EncryptedKey The JWE encrypted private key
	EncryptedKey *string `json:"encryptedKey,omitempty"`

	// Key The public JSON web key
	Key interface{} `json:"key"`
}

// NameConstraints defines model for name-constraints.
type NameConstraints struct {
	// Critical Whether or not name constraints are marked critical
	Critical                *bool     `json:"critical,omitempty"`
	ExcludedDNSDomains      *[]string `json:"excludedDNSDomains,omitempty"`
	ExcludedEmailAddresses  *[]string `json:"excludedEmailAddresses,omitempty"`
	ExcludedIPRanges        *[]string `json:"excludedIPRanges,omitempty"`
	ExcludedURIDomains      *[]string `json:"excludedURIDomains,omitempty"`
	PermittedDNSDomains     *[]string `json:"permittedDNSDomains,omitempty"`
	PermittedEmailAddresses *[]string `json:"permittedEmailAddresses,omitempty"`
	PermittedIPRanges       *[]string `json:"permittedIPRanges,omitempty"`
	PermittedURIDomains     *[]string `json:"permittedURIDomains,omitempty"`
}

// NewAuthority The body of a request to create a new authority
type NewAuthority struct {
	// ActiveRevocation Whether to enable CRL and OCSP on an advanced authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer *X509Issuer `json:"intermediateIssuer,omitempty"`

	// Name The name of the authority
	Name string `json:"name"`

	// RootIssuer A Customized X509 issuer for an authority
	RootIssuer *X509Issuer `json:"rootIssuer,omitempty"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`

	// Type Create either a devops or advanced authority
	Type NewAuthorityType `json:"type"`
}

// NewAuthorityType Create either a devops or advanced authority
type NewAuthorityType string

// NewAuthorityCsr Body of a request to create a new X509 advanced authority with an external root
type NewAuthorityCsr struct {
	// ActiveRevocation Whether to enable CRL and OCSP on the authority
	ActiveRevocation *bool `json:"activeRevocation,omitempty"`

	// IntermediateIssuer A Customized X509 issuer for an authority
	IntermediateIssuer X509Issuer `json:"intermediateIssuer"`

	// Name The name of the authority
	Name string `json:"name"`

	// Subdomain The new authority will be available at <subdomain>.<team slug>.ca.smallstep.com
	Subdomain string `json:"subdomain"`
}

// NewGrant The body of a request to add a grant to a group.
type NewGrant struct {
	// GroupID A UUID identifying the group this grant is attached to
	GroupID string `json:"groupID"`

	// Name Matched against host tag names
	Name string `json:"name"`

	// Sudo Whether users in the group will have sudo permission on matching hosts
	Sudo *bool `json:"sudo,omitempty"`

	// Value Matched against host tag values
	Value *string `json:"value,omitempty"`
}

// NewInventory A collection of items
type NewInventory struct {
	// DisplayName A user-friendly name for the inventory
	DisplayName *string `json:"displayName,omitempty"`

	// Slug A lowercase name identifying the inventory.
	Slug string `json:"slug"`
}

// NewTag The body of a request to add a tag to a host.
type NewTag struct {
	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// OidcProvisioner defines model for oidcProvisioner.
type OidcProvisioner struct {
	// Admins The emails of admin users in an OpenID Connect provisioner. These users will not have restrictions in the certificates to sign.
	Admins *[]string `json:"admins,omitempty"`

	// ClientID The id used to validate the audience in an OpenID Connect token.
	ClientID string `json:"clientID"`

	// ClientSecret The secret used to obtain the OpenID Connect tokens.
	ClientSecret string `json:"clientSecret"`

	// ConfigurationEndpoint OpenID Connect configuration URL.
	ConfigurationEndpoint string `json:"configurationEndpoint"`

	// Domains The domains used to validate the email claim in an OpenID Connect provisioner.
	Domains *[]string `json:"domains,omitempty"`

	// Groups The group list used to validate the groups extension in an OpenID Connect token.
	Groups *[]string `json:"groups,omitempty"`

	// ListenAddress The callback address used in the OpenID Connect flow.
	ListenAddress *string `json:"listenAddress,omitempty"`

	// TenantID The tenant-id used to replace the templatized tenantid value in the OpenID Configuration.
	TenantID *string `json:"tenantID,omitempty"`
}

// PosixGroup A POSIX group represents a group that exists on a host with the given group name and gid.
// A managed group will be created or deleted on the host by Smallstep.
// Unmanaged groups must already exist on the host.
//
// An SSH Group may have multiple POSIX groups.
// An SSH User belonging to the group will be a member of the POSIX group when they access the host.
type PosixGroup struct {
	// Gid The numeric group ID
	Gid *int `json:"gid,omitempty"`

	// Id A UUID identifying the POSIX group
	Id *string `json:"id,omitempty"`

	// Managed Whether Smallstep should create and delete the group
	Managed *bool `json:"managed,omitempty"`

	// Name The name of the group
	Name *string `json:"name,omitempty"`
}

// PosixUser A POSIX user is the login user on the SSH Host. It will be generated automatically if not supplied by the team's Identity Provider.
type PosixUser struct {
	// Gid The numeric group ID of the user
	Gid *int `json:"gid,omitempty"`

	// HomeDir The user's home directory
	HomeDir *string `json:"homeDir,omitempty"`

	// Shell The user's shell
	Shell *string `json:"shell,omitempty"`

	// Uid The numeric ID of the user
	Uid *int `json:"uid,omitempty"`

	// Username The login name of the user
	Username *string `json:"username,omitempty"`
}

// Provisioner defines model for provisioner.
type Provisioner struct {
	// Claims A set of constraints configuring how this provisioner can be used to issue certificates.
	Claims *ProvisionerClaims `json:"claims,omitempty"`

	// CreatedAt Timestamp of when the provisioner was created in RFC 3339 format. Generated server-side.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id A UUID identifying this provisioner. Generated server-side when the provisioner is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the provisioner.
	Name string `json:"name"`

	// Options Options that apply when issuing certificates with this provisioner
	Options *ProvisionerOptions `json:"options,omitempty"`

	// Type The type of provisioner.
	Type  ProvisionerType `json:"type"`
	union json.RawMessage
}

// ProvisionerType The type of provisioner.
type ProvisionerType string

// ProvisionerClaims A set of constraints configuring how this provisioner can be used to issue certificates.
type ProvisionerClaims struct {
	// AllowRenewalAfterExpiry Allow renewals for expired certificates generated by this provisioner.
	AllowRenewalAfterExpiry *bool `json:"allowRenewalAfterExpiry,omitempty"`

	// DefaultHostSSHCertDuration The default duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultHostSSHCertDuration *string `json:"defaultHostSSHCertDuration,omitempty"`

	// DefaultTLSCertDuration The default duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultTLSCertDuration *string `json:"defaultTLSCertDuration,omitempty"`

	// DefaultUserSSHCertDuration The default duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	DefaultUserSSHCertDuration *string `json:"defaultUserSSHCertDuration,omitempty"`

	// DisableRenewal Disable renewal for all certificates generated by this provisioner.
	DisableRenewal *bool `json:"disableRenewal,omitempty"`

	// EnableSSHCA Allow this provisioner to be used to generate SSH certificates.
	EnableSSHCA *bool `json:"enableSSHCA,omitempty"`

	// MaxHostSSHCertDuration The maximum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxHostSSHCertDuration *string `json:"maxHostSSHCertDuration,omitempty"`

	// MaxTLSCertDuration The maximum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxTLSCertDuration *string `json:"maxTLSCertDuration,omitempty"`

	// MaxUserSSHCertDuration The maximum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MaxUserSSHCertDuration *string `json:"maxUserSSHCertDuration,omitempty"`

	// MinHostSSHCertDuration The minimum duration for an SSH host certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinHostSSHCertDuration *string `json:"minHostSSHCertDuration,omitempty"`

	// MinTLSCertDuration The minimum duration for an x509 certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinTLSCertDuration *string `json:"minTLSCertDuration,omitempty"`

	// MinUserSSHCertDuration The minimum duration for an SSH user certificate generated by this provisioner. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	MinUserSSHCertDuration *string `json:"minUserSSHCertDuration,omitempty"`
}

// ProvisionerOptions Options that apply when issuing certificates with this provisioner
type ProvisionerOptions struct {
	// Ssh Options that apply when issuing SSH certificates
	Ssh *SshOptions `json:"ssh,omitempty"`

	// Webhooks Configuration for a webhook to be called when issuing certificates with this provisioner
	Webhooks *Webhook `json:"webhooks,omitempty"`

	// X509 Options that apply when issuing x509 certificates
	X509 *X509Options `json:"x509,omitempty"`
}

// SshOptions Options that apply when issuing SSH certificates
type SshOptions struct {
	// Template A JSON representation of the SSH certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#ssh-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// Tag A key-value pair attached to a host.
// Smallstep determines access by comparing host tags to group grants when a user attempts to SSH to a host.
type Tag struct {
	// Id A UUID identifying this host tag
	Id *string `json:"id,omitempty"`

	// Name The key for the host tag
	Name *string `json:"name,omitempty"`

	// Value The value for the host tag
	Value *string `json:"value,omitempty"`
}

// User SSH Users are synced from the team's Identity Provider, or from the default Smallstep directory if no external Identity Provider has been configured.
type User struct {
	// Active Whether the user has been deactivated in the team's Identity Provider
	Active *bool `json:"active,omitempty"`

	// DisplayName The user's display name
	DisplayName *string  `json:"displayName,omitempty"`
	Emails      *[]Email `json:"emails,omitempty"`

	// FamilyName The user's family name
	FamilyName *string `json:"familyName,omitempty"`

	// GivenName The user's given name
	GivenName *string  `json:"givenName,omitempty"`
	Groups    *[]Group `json:"groups,omitempty"`

	// Id A UUID identifying the user
	Id         *string      `json:"id,omitempty"`
	PosixUsers *[]PosixUser `json:"posixUsers,omitempty"`
}

// Webhook Configuration for a webhook to be called when issuing certificates with this provisioner
type Webhook struct {
	// CertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
	CertType *WebhookCertType `json:"certType,omitempty"`

	// DisableTLSClientAuth The CA will not send a client certificate when requested by the webhook server.
	DisableTLSClientAuth *bool `json:"disableTLSClientAuth,omitempty"`

	// Id UUID identifying this webhook. Generated server-side when the webhook is created.
	Id *string `json:"id,omitempty"`

	// Name The name of the webhook.
	Name *string `json:"name,omitempty"`

	// Url The URL of the webhook server.
	Url *string `json:"url,omitempty"`
}

// WebhookCertType Whether to call this webhook when signing X509 certificates, SSH certificates, or ALL certificates. Default is ALL.
type WebhookCertType string

// X509Issuer A Customized X509 issuer for an authority
type X509Issuer struct {
	// Duration The certificate lifetime. Parsed as a [Golang duration](https://pkg.go.dev/time#ParseDuration).
	Duration *string `json:"duration,omitempty"`

	// KeyVersion The signature algorithm
	KeyVersion    X509IssuerKeyVersion `json:"keyVersion"`
	MaxPathLength *int                 `json:"maxPathLength,omitempty"`

	// Name The name of the issuer
	Name            string           `json:"name"`
	NameConstraints *NameConstraints `json:"nameConstraints,omitempty"`

	// Subject Name used in x509 certificates
	Subject *DistinguishedName `json:"subject,omitempty"`
}

// X509IssuerKeyVersion The signature algorithm
type X509IssuerKeyVersion string

// X509Options Options that apply when issuing x509 certificates
type X509Options struct {
	// Template A JSON representation of the x509 certificate to be created. [More info](https://smallstep.com/docs/step-ca/templates/#x509-templates).
	Template *string `json:"template,omitempty"`

	// TemplateData A map of data that can be used by the certificate template.
	TemplateData *interface{} `json:"templateData,omitempty"`
}

// X5cProvisioner Authenticate a certificate request with an existing x509 certificate.
type X5cProvisioner struct {
	// Roots A list of pem-encoded x509 certificates. Any certificate bundle that chains up to any of these roots can be used in a certificate request.
	Roots []string `json:"roots"`
}

// Accept defines model for accept.
type Accept = string

// AttestationAuthorityID defines model for attestationAuthorityID.
type AttestationAuthorityID = string

// AuthorityID defines model for authorityID.
type AuthorityID = string

// GrantID defines model for grantID.
type GrantID = string

// GroupID defines model for groupID.
type GroupID = string

// HostID defines model for hostID.
type HostID = string

// InventorySlug defines model for inventorySlug.
type InventorySlug = string

// ItemID defines model for itemID.
type ItemID = string

// Pagination defines model for pagination.
type Pagination struct {
	// After Fetch a page of results other than the first page.
	// Must be copied from a previously returned X-Next-Cursor header.
	After *string `json:"after"`

	// First Limits the number of results returned.
	// Defaults to 100.
	First *int `json:"first"`
}

// ProvisionerNameOrID defines model for provisionerNameOrID.
type ProvisionerNameOrID = string

// RequestID defines model for requestID.
type RequestID = string

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N409 defines model for 409.
type N409 = Error

// N412 defines model for 412.
type N412 = Error

// N500 defines model for 500.
type N500 = Error

// GetAttestationAuthoritiesParams defines parameters for GetAttestationAuthorities.
type GetAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesParams defines parameters for PostAttestationAuthorities.
type PostAttestationAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAttestationAuthorityParams defines parameters for DeleteAttestationAuthority.
type DeleteAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAttestationAuthorityParams defines parameters for GetAttestationAuthority.
type GetAttestationAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthJSONBody defines parameters for PostAuth.
type PostAuthJSONBody struct {
	Audience *PostAuthJSONBodyAudience `json:"audience,omitempty"`
	Bundle   *[]openapi_types.File     `json:"bundle,omitempty"`
	TeamID   *string                   `json:"teamID,omitempty"`
}

// PostAuthJSONBodyAudience defines parameters for PostAuth.
type PostAuthJSONBodyAudience string

// GetAuthoritiesParams defines parameters for GetAuthorities.
type GetAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesParams defines parameters for PostAuthorities.
type PostAuthoritiesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthoritiesCsrParams defines parameters for PostAuthoritiesCsr.
type PostAuthoritiesCsrParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteAuthorityParams defines parameters for DeleteAuthority.
type DeleteAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetAuthorityParams defines parameters for GetAuthority.
type GetAuthorityParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListAuthorityProvisionersParams defines parameters for ListAuthorityProvisioners.
type ListAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityProvisionersParams defines parameters for PostAuthorityProvisioners.
type PostAuthorityProvisionersParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteProvisionerParams defines parameters for DeleteProvisioner.
type DeleteProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetProvisionerParams defines parameters for GetProvisioner.
type GetProvisionerParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAuthorityRootJSONBody defines parameters for PostAuthorityRoot.
type PostAuthorityRootJSONBody struct {
	// AdminEmails Users that will have admin access to manage the authority
	AdminEmails []string `json:"adminEmails"`

	// Id The `id` returned from a previous call to `/authorities/csr`
	Id string `json:"id"`

	// IntermediatePEM The signed intermediate certificate
	IntermediatePEM string `json:"intermediatePEM"`

	// RootName A name for the external root issuer
	RootName string `json:"rootName"`

	// RootPEM The root certificate in pem format
	RootPEM string `json:"rootPEM"`
}

// PostAuthorityRootParams defines parameters for PostAuthorityRoot.
type PostAuthorityRootParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantsParams defines parameters for GetSshGrants.
type GetSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostSshGrantsParams defines parameters for PostSshGrants.
type PostSshGrantsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteSshGrantParams defines parameters for DeleteSshGrant.
type DeleteSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGrantParams defines parameters for GetSshGrant.
type GetSshGrantParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupsParams defines parameters for GetSshGroups.
type GetSshGroupsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshGroupParams defines parameters for GetSshGroup.
type GetSshGroupParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostsParams defines parameters for GetSshHosts.
type GetSshHostsParams struct {
	// Active If unset or set to true the results will only include active hosts. If set to false the results will include both active and inactive hosts.
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Bastion Filter (non-)bastion hosts. If unset the results will include both bastion and non-bastion hosts. If set to true the results will include only bastion hosts and if set to false the results will include only non-bastion hosts.
	Bastion *bool `form:"bastion,omitempty" json:"bastion,omitempty"`

	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostParams defines parameters for GetSshHost.
type GetSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostHostsHostIDTagsParams defines parameters for PostHostsHostIDTags.
type PostHostsHostIDTagsParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// UnregisterSshHostParams defines parameters for UnregisterSshHost.
type UnregisterSshHostParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoriesParams defines parameters for ListInventories.
type ListInventoriesParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostInventoriesParams defines parameters for PostInventories.
type PostInventoriesParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryParams defines parameters for DeleteInventory.
type DeleteInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryParams defines parameters for GetInventory.
type GetInventoryParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// ListInventoryItemsParams defines parameters for ListInventoryItems.
type ListInventoryItemsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// DeleteInventoryItemParams defines parameters for DeleteInventoryItem.
type DeleteInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemParams defines parameters for GetInventoryItem.
type GetInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemJSONBody defines parameters for PutInventoryItem.
type PutInventoryItemJSONBody struct {
	Data interface{} `json:"data"`
}

// PutInventoryItemParams defines parameters for PutInventoryItem.
type PutInventoryItemParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetInventoryItemDataParams defines parameters for GetInventoryItemData.
type GetInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PutInventoryItemDataJSONBody defines parameters for PutInventoryItemData.
type PutInventoryItemDataJSONBody = interface{}

// PutInventoryItemDataParams defines parameters for PutInventoryItemData.
type PutInventoryItemDataParams struct {
	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshHostTagsParams defines parameters for GetSshHostTags.
type GetSshHostTagsParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// GetSshUsersParams defines parameters for GetSshUsers.
type GetSshUsersParams struct {
	// Pagination Paginate over a list of objects. Example: `?pagination[first]=30&pagination[after]=MTIzNA==`, which after encoding would be `?pagination%5Bfirst%5D=30&pagination%5Bafter%5D=MTIzNA==`
	Pagination *Pagination `json:"pagination,omitempty"`

	// XRequestId A request ID provided by the client. If not provided, the server will generate one. Will be reflected in responses.
	XRequestId *RequestID `json:"X-Request-Id,omitempty"`

	// Accept The content type the client is willing to accept. Also includes API version.
	Accept *Accept `json:"Accept,omitempty"`
}

// PostAttestationAuthoritiesJSONRequestBody defines body for PostAttestationAuthorities for application/json ContentType.
type PostAttestationAuthoritiesJSONRequestBody = AttestationAuthority

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody PostAuthJSONBody

// PostAuthoritiesJSONRequestBody defines body for PostAuthorities for application/json ContentType.
type PostAuthoritiesJSONRequestBody = NewAuthority

// PostAuthoritiesCsrJSONRequestBody defines body for PostAuthoritiesCsr for application/json ContentType.
type PostAuthoritiesCsrJSONRequestBody = NewAuthorityCsr

// PostAuthorityProvisionersJSONRequestBody defines body for PostAuthorityProvisioners for application/json ContentType.
type PostAuthorityProvisionersJSONRequestBody = Provisioner

// PostAuthorityRootJSONRequestBody defines body for PostAuthorityRoot for application/json ContentType.
type PostAuthorityRootJSONRequestBody PostAuthorityRootJSONBody

// PostSshGrantsJSONRequestBody defines body for PostSshGrants for application/json ContentType.
type PostSshGrantsJSONRequestBody = NewGrant

// PostHostsHostIDTagsJSONRequestBody defines body for PostHostsHostIDTags for application/json ContentType.
type PostHostsHostIDTagsJSONRequestBody = NewTag

// PostInventoriesJSONRequestBody defines body for PostInventories for application/json ContentType.
type PostInventoriesJSONRequestBody = NewInventory

// PutInventoryItemJSONRequestBody defines body for PutInventoryItem for application/json ContentType.
type PutInventoryItemJSONRequestBody PutInventoryItemJSONBody

// PutInventoryItemDataJSONRequestBody defines body for PutInventoryItemData for application/json ContentType.
type PutInventoryItemDataJSONRequestBody = PutInventoryItemDataJSONBody

// AsOidcProvisioner returns the union data inside the Provisioner as a OidcProvisioner
func (t Provisioner) AsOidcProvisioner() (OidcProvisioner, error) {
	var body OidcProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOidcProvisioner overwrites any union data inside the Provisioner as the provided OidcProvisioner
func (t *Provisioner) FromOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOidcProvisioner performs a merge with any union data inside the Provisioner, using the provided OidcProvisioner
func (t *Provisioner) MergeOidcProvisioner(v OidcProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJwkProvisioner returns the union data inside the Provisioner as a JwkProvisioner
func (t Provisioner) AsJwkProvisioner() (JwkProvisioner, error) {
	var body JwkProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJwkProvisioner overwrites any union data inside the Provisioner as the provided JwkProvisioner
func (t *Provisioner) FromJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJwkProvisioner performs a merge with any union data inside the Provisioner, using the provided JwkProvisioner
func (t *Provisioner) MergeJwkProvisioner(v JwkProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeProvisioner returns the union data inside the Provisioner as a AcmeProvisioner
func (t Provisioner) AsAcmeProvisioner() (AcmeProvisioner, error) {
	var body AcmeProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeProvisioner overwrites any union data inside the Provisioner as the provided AcmeProvisioner
func (t *Provisioner) FromAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeProvisioner
func (t *Provisioner) MergeAcmeProvisioner(v AcmeProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAcmeAttestationProvisioner returns the union data inside the Provisioner as a AcmeAttestationProvisioner
func (t Provisioner) AsAcmeAttestationProvisioner() (AcmeAttestationProvisioner, error) {
	var body AcmeAttestationProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAcmeAttestationProvisioner overwrites any union data inside the Provisioner as the provided AcmeAttestationProvisioner
func (t *Provisioner) FromAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAcmeAttestationProvisioner performs a merge with any union data inside the Provisioner, using the provided AcmeAttestationProvisioner
func (t *Provisioner) MergeAcmeAttestationProvisioner(v AcmeAttestationProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsX5cProvisioner returns the union data inside the Provisioner as a X5cProvisioner
func (t Provisioner) AsX5cProvisioner() (X5cProvisioner, error) {
	var body X5cProvisioner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromX5cProvisioner overwrites any union data inside the Provisioner as the provided X5cProvisioner
func (t *Provisioner) FromX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeX5cProvisioner performs a merge with any union data inside the Provisioner, using the provided X5cProvisioner
func (t *Provisioner) MergeX5cProvisioner(v X5cProvisioner) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Provisioner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Claims != nil {
		object["claims"], err = json.Marshal(t.Claims)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'claims': %w", err)
		}
	}

	if t.CreatedAt != nil {
		object["createdAt"], err = json.Marshal(t.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'createdAt': %w", err)
		}
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(t.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if t.Options != nil {
		object["options"], err = json.Marshal(t.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Provisioner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["claims"]; found {
		err = json.Unmarshal(raw, &t.Claims)
		if err != nil {
			return fmt.Errorf("error reading 'claims': %w", err)
		}
	}

	if raw, found := object["createdAt"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'createdAt': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &t.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Attestation Authorities
	// (GET /attestation-authorities)
	GetAttestationAuthorities(w http.ResponseWriter, r *http.Request, params GetAttestationAuthoritiesParams)
	// Create New Attestation Authority
	// (POST /attestation-authorities)
	PostAttestationAuthorities(w http.ResponseWriter, r *http.Request, params PostAttestationAuthoritiesParams)
	// Delete Attestation Authority
	// (DELETE /attestation-authorities/{attestationAuthorityID})
	DeleteAttestationAuthority(w http.ResponseWriter, r *http.Request, attestationAuthorityID AttestationAuthorityID, params DeleteAttestationAuthorityParams)
	// Get Attestation Authority
	// (GET /attestation-authorities/{attestationAuthorityID})
	GetAttestationAuthority(w http.ResponseWriter, r *http.Request, attestationAuthorityID AttestationAuthorityID, params GetAttestationAuthorityParams)
	// Authenticate
	// (POST /auth)
	PostAuth(w http.ResponseWriter, r *http.Request)
	// List Authorities
	// (GET /authorities)
	GetAuthorities(w http.ResponseWriter, r *http.Request, params GetAuthoritiesParams)
	// Create New Authority
	// (POST /authorities)
	PostAuthorities(w http.ResponseWriter, r *http.Request, params PostAuthoritiesParams)
	// Create New Authority CSR
	// (POST /authorities/csr)
	PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request, params PostAuthoritiesCsrParams)
	// Delete Authority
	// (DELETE /authorities/{authorityID})
	DeleteAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params DeleteAuthorityParams)
	// Get Authority
	// (GET /authorities/{authorityID})
	GetAuthority(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params GetAuthorityParams)
	// List Authority Provisioners
	// (GET /authorities/{authorityID}/provisioners)
	ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params ListAuthorityProvisionersParams)
	// Create Authority Provisioner
	// (POST /authorities/{authorityID}/provisioners)
	PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityProvisionersParams)
	// Delete Provisioner
	// (DELETE /authorities/{authorityID}/provisioners/{provisionerNameOrID})
	DeleteProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params DeleteProvisionerParams)
	// Get Provisioner
	// (GET /authorities/{authorityID}/provisioners/{provisionerNameOrID})
	GetProvisioner(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, provisionerNameOrID ProvisionerNameOrID, params GetProvisionerParams)
	// Post Authority External Root
	// (POST /authorities/{authorityID}/root)
	PostAuthorityRoot(w http.ResponseWriter, r *http.Request, authorityID AuthorityID, params PostAuthorityRootParams)
	// Get SSH Grants
	// (GET /grants)
	GetSshGrants(w http.ResponseWriter, r *http.Request, params GetSshGrantsParams)
	// Create SSH Grant
	// (POST /grants)
	PostSshGrants(w http.ResponseWriter, r *http.Request, params PostSshGrantsParams)
	// Delete SSH Grant
	// (DELETE /grants/{grantID})
	DeleteSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params DeleteSshGrantParams)
	// Get SSH Grant
	// (GET /grants/{grantID})
	GetSshGrant(w http.ResponseWriter, r *http.Request, grantID GrantID, params GetSshGrantParams)
	// Get SSH Groups
	// (GET /groups)
	GetSshGroups(w http.ResponseWriter, r *http.Request, params GetSshGroupsParams)
	// Get SSH Group
	// (GET /groups/{groupID})
	GetSshGroup(w http.ResponseWriter, r *http.Request, groupID GroupID, params GetSshGroupParams)
	// Get SSH Hosts
	// (GET /hosts)
	GetSshHosts(w http.ResponseWriter, r *http.Request, params GetSshHostsParams)
	// Get SSH Host
	// (GET /hosts/{hostID})
	GetSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params GetSshHostParams)
	// Tag SSH Host
	// (POST /hosts/{hostID}/tags)
	PostHostsHostIDTags(w http.ResponseWriter, r *http.Request, hostID HostID, params PostHostsHostIDTagsParams)
	// Unregister SSH Host
	// (POST /hosts/{hostID}/unregister)
	UnregisterSshHost(w http.ResponseWriter, r *http.Request, hostID HostID, params UnregisterSshHostParams)
	// List Inventories
	// (GET /inventories)
	ListInventories(w http.ResponseWriter, r *http.Request, params ListInventoriesParams)
	// Create an Inventory
	// (POST /inventories)
	PostInventories(w http.ResponseWriter, r *http.Request, params PostInventoriesParams)
	// Delete Inventory
	// (DELETE /inventories/{inventorySlug})
	DeleteInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params DeleteInventoryParams)
	// Get Inventory
	// (GET /inventories/{inventorySlug})
	GetInventory(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params GetInventoryParams)
	// List Inventory Items
	// (GET /inventories/{inventorySlug}/items)
	ListInventoryItems(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, params ListInventoryItemsParams)
	// Delete Inventory Item
	// (DELETE /inventories/{inventorySlug}/items/{itemID})
	DeleteInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params DeleteInventoryItemParams)
	// Get Inventory Item
	// (GET /inventories/{inventorySlug}/items/{itemID})
	GetInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemParams)
	// Save Inventory Item
	// (PUT /inventories/{inventorySlug}/items/{itemID})
	PutInventoryItem(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemParams)
	// Get Inventory Item Data
	// (GET /inventories/{inventorySlug}/items/{itemID}/data)
	GetInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params GetInventoryItemDataParams)
	// Save Inventory Item Data
	// (PUT /inventories/{inventorySlug}/items/{itemID}/data)
	PutInventoryItemData(w http.ResponseWriter, r *http.Request, inventorySlug InventorySlug, itemID ItemID, params PutInventoryItemDataParams)
	// Get SSH Host Tags
	// (GET /tags)
	GetSshHostTags(w http.ResponseWriter, r *http.Request, params GetSshHostTagsParams)
	// Get SSH Users
	// (GET /users)
	GetSshUsers(w http.ResponseWriter, r *http.Request, params GetSshUsersParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAttestationAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAttestationAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAttestationAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAttestationAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAttestationAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAttestationAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAttestationAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAttestationAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAttestationAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAttestationAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "attestationAuthorityID" -------------
	var attestationAuthorityID AttestationAuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, chi.URLParam(r, "attestationAuthorityID"), &attestationAuthorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "attestationAuthorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAttestationAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAttestationAuthority(w, r, attestationAuthorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAttestationAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAttestationAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "attestationAuthorityID" -------------
	var attestationAuthorityID AttestationAuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "attestationAuthorityID", runtime.ParamLocationPath, chi.URLParam(r, "attestationAuthorityID"), &attestationAuthorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "attestationAuthorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAttestationAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAttestationAuthority(w, r, attestationAuthorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuth operation middleware
func (siw *ServerInterfaceWrapper) PostAuth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, MtlsScopes, []string{""})

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuth(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthorities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorities operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorities(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthoritiesCsr operation middleware
func (siw *ServerInterfaceWrapper) PostAuthoritiesCsr(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthoritiesCsrParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthoritiesCsr(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteAuthority operation middleware
func (siw *ServerInterfaceWrapper) DeleteAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAuthority operation middleware
func (siw *ServerInterfaceWrapper) GetAuthority(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthorityParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthority(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) ListAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityProvisioners operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityProvisioners(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityProvisionersParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityProvisioners(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteProvisioner operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvisioner(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetProvisioner operation middleware
func (siw *ServerInterfaceWrapper) GetProvisioner(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	// ------------- Path parameter "provisionerNameOrID" -------------
	var provisionerNameOrID ProvisionerNameOrID

	err = runtime.BindStyledParameterWithLocation("simple", false, "provisionerNameOrID", runtime.ParamLocationPath, chi.URLParam(r, "provisionerNameOrID"), &provisionerNameOrID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provisionerNameOrID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvisionerParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvisioner(w, r, authorityID, provisionerNameOrID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostAuthorityRoot operation middleware
func (siw *ServerInterfaceWrapper) PostAuthorityRoot(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "authorityID" -------------
	var authorityID AuthorityID

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorityID", runtime.ParamLocationPath, chi.URLParam(r, "authorityID"), &authorityID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authorityID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostAuthorityRootParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAuthorityRoot(w, r, authorityID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrants operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostSshGrants operation middleware
func (siw *ServerInterfaceWrapper) PostSshGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSshGrantsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSshGrants(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSshGrant operation middleware
func (siw *ServerInterfaceWrapper) DeleteSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGrant operation middleware
func (siw *ServerInterfaceWrapper) GetSshGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantID" -------------
	var grantID GrantID

	err = runtime.BindStyledParameterWithLocation("simple", false, "grantID", runtime.ParamLocationPath, chi.URLParam(r, "grantID"), &grantID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGrantParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGrant(w, r, grantID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroups operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroups(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshGroup operation middleware
func (siw *ServerInterfaceWrapper) GetSshGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupID" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithLocation("simple", false, "groupID", runtime.ParamLocationPath, chi.URLParam(r, "groupID"), &groupID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshGroupParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshGroup(w, r, groupID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHosts operation middleware
func (siw *ServerInterfaceWrapper) GetSshHosts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostsParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", r.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "active", Err: err})
		return
	}

	// ------------- Optional query parameter "bastion" -------------

	err = runtime.BindQueryParameter("form", true, false, "bastion", r.URL.Query(), &params.Bastion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bastion", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHosts(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHost operation middleware
func (siw *ServerInterfaceWrapper) GetSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostHostsHostIDTags operation middleware
func (siw *ServerInterfaceWrapper) PostHostsHostIDTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostHostsHostIDTagsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostHostsHostIDTags(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UnregisterSshHost operation middleware
func (siw *ServerInterfaceWrapper) UnregisterSshHost(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "hostID" -------------
	var hostID HostID

	err = runtime.BindStyledParameterWithLocation("simple", false, "hostID", runtime.ParamLocationPath, chi.URLParam(r, "hostID"), &hostID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterSshHostParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnregisterSshHost(w, r, hostID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventories operation middleware
func (siw *ServerInterfaceWrapper) ListInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoriesParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostInventories operation middleware
func (siw *ServerInterfaceWrapper) PostInventories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostInventoriesParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInventories(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventory operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventory operation middleware
func (siw *ServerInterfaceWrapper) GetInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventory(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListInventoryItems operation middleware
func (siw *ServerInterfaceWrapper) ListInventoryItems(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInventoryItemsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInventoryItems(w, r, inventorySlug, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) DeleteInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItem operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItem(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItem(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) GetInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutInventoryItemData operation middleware
func (siw *ServerInterfaceWrapper) PutInventoryItemData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "inventorySlug" -------------
	var inventorySlug InventorySlug

	err = runtime.BindStyledParameterWithLocation("simple", false, "inventorySlug", runtime.ParamLocationPath, chi.URLParam(r, "inventorySlug"), &inventorySlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventorySlug", Err: err})
		return
	}

	// ------------- Path parameter "itemID" -------------
	var itemID ItemID

	err = runtime.BindStyledParameterWithLocation("simple", false, "itemID", runtime.ParamLocationPath, chi.URLParam(r, "itemID"), &itemID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "itemID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutInventoryItemDataParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutInventoryItemData(w, r, inventorySlug, itemID, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshHostTags operation middleware
func (siw *ServerInterfaceWrapper) GetSshHostTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshHostTagsParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshHostTags(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSshUsers operation middleware
func (siw *ServerInterfaceWrapper) GetSshUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, JWTScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSshUsersParams

	// ------------- Optional query parameter "pagination" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "pagination", r.URL.Query(), &params.Pagination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId RequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Request-Id", runtime.ParamLocationHeader, valueList[0], &XRequestId)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept Accept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, valueList[0], &Accept)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSshUsers(w, r, params)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/attestation-authorities", wrapper.GetAttestationAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/attestation-authorities", wrapper.PostAttestationAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/attestation-authorities/{attestationAuthorityID}", wrapper.DeleteAttestationAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/attestation-authorities/{attestationAuthorityID}", wrapper.GetAttestationAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth", wrapper.PostAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities", wrapper.GetAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities", wrapper.PostAuthorities)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/csr", wrapper.PostAuthoritiesCsr)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}", wrapper.DeleteAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}", wrapper.GetAuthority)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.ListAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/provisioners", wrapper.PostAuthorityProvisioners)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}", wrapper.DeleteProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/authorities/{authorityID}/provisioners/{provisionerNameOrID}", wrapper.GetProvisioner)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/authorities/{authorityID}/root", wrapper.PostAuthorityRoot)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants", wrapper.GetSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/grants", wrapper.PostSshGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/grants/{grantID}", wrapper.DeleteSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/grants/{grantID}", wrapper.GetSshGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.GetSshGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{groupID}", wrapper.GetSshGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts", wrapper.GetSshHosts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/hosts/{hostID}", wrapper.GetSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/tags", wrapper.PostHostsHostIDTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/hosts/{hostID}/unregister", wrapper.UnregisterSshHost)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories", wrapper.ListInventories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/inventories", wrapper.PostInventories)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}", wrapper.DeleteInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}", wrapper.GetInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items", wrapper.ListInventoryItems)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.DeleteInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.GetInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}", wrapper.PutInventoryItem)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.GetInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/inventories/{inventorySlug}/items/{itemID}/data", wrapper.PutInventoryItemData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/tags", wrapper.GetSshHostTags)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.GetSshUsers)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9eVPbSN44/la6tM9T80wNMvKNqdr6rTEOOJzBJif5JW2pbSvoQt2ycVK892/1Iakl",
	"tXyQkGF3mX8mWH335776h2b6buB7yCNY2/+hzRC0UMj++V7vhQgSZOldQv+2EDZDOyC272n72sh2ESbQ",
	"DYA/AYsZ8gCZIRAi7EehiYCd/B34HkZg7FtLsIAYmHxMbUdD99ANHKTtazXDaOlGVTdqo2pz32jsG82P",
	"RnvfMLQdLUR3kR0iS9snYYR2NGzOkAvpeiZ+6EKi7WsWJEgntou0HY0sAzoiJqHtTbWHhx3tvX6O7one",
	"i0Lsh4p9zBAw2Tcwh06EAPFBhBGY+CHbgYfuCQjgFNF9hghHDsGZxZ+NBt/Pu//8pyavTbWMK3QXIUz0",
	"gVVcRReE/CsYHIIg9Oe2hSwwXrIlmI6NPFIBgwnwfJJ83mEfMQrnKAQL23HAFHkohAQB30MV8I7+NKZ3",
	"MHGQSZBFLyW+EFzJbAKOTQtN1m5h6ELHwQQFejew9bcoxGz5hd1cDsCcfxTHud1qakatphstvWpopRde",
	"ctfXgfXLQdaBmICID/y74PZhRwtgCF1EBDZC00QBKYFf3yPII4AOIkEMsDGDC9ub0mvgI1RA18E+sD3T",
	"iSyEgXRXOZAIAsc2IZ1md+5ZFRzffWWe3s9f37DvaTuaTZfCaYe2o3nQpSN0+ZJXAxUkhF4KnaYbkZkf",
	"2mQ5OCzuc3BIb41uTuoBYNwlXkMAySxdQcngq25HscINl7VmKY+efxpCj6ye+4g2Uc8b9952Tj8K1s3p",
	"R0HZnLz3dnPOfLxmm8PhMTj2cclORf/tJrW9OfKIHy6HTjQtzo2daApsC3nEniwZHs0ooRB91OvIDrnl",
	"cghyy88AeoA2oJSK/nPNMvhQ280fwKntQaKk6pf8GwI+ZTgQODYmdFX++BsyCa6APqcd++Dr/5eO82li",
	"h5h8/mfduIkMo9aSvsAJQeHnf8YM9OsOWMxscwbY7wB5pm/RI1/4kWNR1iEP+7/NAzbw/zYPFUP/b/OA",
	"DUK/JsPfeIy+BY5vofgs2LndRYgdojg46Qzkw/Iix4FjJ+kahH6AQmIjTp7pdMUze4UI3VBegAA+mSEq",
	"X0DOc9hWWKPKjXcWYUK3a/qBjSwwCX2XjhCiue1H2FmCEJEo9JAFMqIN4OS3IrapEE/yO8hd/47GllHc",
	"xKnt2gRzaShyxyiUdxIvpnLjHaIJZL8RH1QNI7eSurGjufDediNX268aBv3T9sSfpYuzPYKmKGTAKX7i",
	"8EbXi8mS7dFCKLhIfmXyEeVnKDyHLroIVQjVt8UNIECvHfghuL5OKY00hhq7VJNsh2pC4FMt7tlIg0q2",
	"npFkV+2RbVJMQL83DIP+T0grDGskGYNJEvs/pPH+J0QTbV/7x26qouzyr3gXhaEf8jmyZ3cArfj0tJ2s",
	"OpMVwFWji+a7mbarJd/Vw6i7sWU3jOrTn8a1J+SO70x0fdbHUX/643jlh2PbspD33M+i8fRnce4TMPEj",
	"79nDRefpz6LnexPHNp87xajWfgOKQNtBFrgMkel7li3EoGd8Ks3fwVUGHkGhB52YwfKGz/hcHmLGLIwH",
	"LuqmuvClJN0ohI9PknDz+f9mhAR4f3c31f9N3921fBPvsolNuCu1x7v/oJP9SWVbApBHRTpMdWPf5Rr7",
	"wiYzJqp8stDcNpHOdXTdqAJzBh0HeVxSpk26vbM+FXCIb/pO2UrGjj/dpXPqLvTgFFl6ZmA2q07Ffmh7",
	"yNr9k4o6Odk9bfiK2Waw2swCHcdfICtjgODGHJyYC8s3VQFvoWNb3MqIAQwRoICKdgDdyg6AngVI4FYA",
	"m4p+EYMDmw/fZb/xCTBvDy0LAxJShSFp8QcGvS7mw9CRc6N4vqePLs/icfg9mVSdxDjKGldMekQTikl0",
	"PhxRTQaDD9HYPkFLcDl4WwEDkl8D/Wz6f2AQ+j4BvS5fCAnc3DpGl2eY7cHyEWaSLB8Deku6firtWlyf",
	"oBdGlVl2K8ij+sInhuOISp8EBdqORgJX+6zQaFzbG/Cu1eQrDENI1b3Is+8iJD5TeT1rjbryfRUgdMU6",
	"x5FnOVynoxuVz4pK1pf9s3jD7IQXQvyOMLKofjRHoT1Zlh43PzVxAMIwbaEAeRYGPtcZ+Y/+BBTBlykH",
	"smJgY7YgsWa2FqrEh7bF7YW9eFd0oLFj4xnXNzAihKrgxSmYQZEBpB8yMKuALgEOgphQfaNwKPTaY+2I",
	"214jHNtTKHAUZsjceuFeM1dJNVc/NFHvXKGA0w9sRbENqXvOFj9Gpu+K3fuu63uA6nE7wJ4AKP9CFy7r",
	"WZXUWDv2fQdBT3tIFL9+96C4hAvPWXJSxlU3gXMzOEdgjJBHVXvT9yb2NGKHQwnknJGKfvcAmCFi5ifo",
	"4ASIKFGle+C+FAA9AE3TjzwSU1cbyxqsaskPsrL6SUUCKTrZhOmDbPGHjGAAiY2Ay4yWXFDPKVF+Hqxm",
	"I0aSmYcxlDHEtimm0RNCjhUsJP1Y3OU7ZtTiAJBwOHpYgglwrqKkcnShulHVdjTLw/wfxME6dAKP/vUr",
	"KN4L5qzCHBAb4+hpMb4FHQd4aCG3whsgmAQgmT3nsWwdSikcGgq88tROEs59ErQoyCp5GE3ZlGj7BwYz",
	"GFoLCrfcKk6WlFXZWFiB6Z2j+wCFtos8Ah3G4XHEv9Fzn0EqCpWIYH7I5GwXWTZlgmopLECuzmzDyEpM",
	"0LbULcuKY347jmzHApAuwPYYRDN+l24x71nKjIKjsWsTwpmikJwqmgL74n2UCA9l61cu+ZcuzIQEOv5U",
	"vSTm5RD+hdipIFDNdyxu+Y2XGsuNY+T43lS4FhkXR9BVzswd/qsdsrYHrl716vV6J5aaEv+sGpKzoQSb",
	"uFR3NFvpeGdm36yLx8bqWSvgSNhULaEI6ti2kPLAubFUddrc3rzal1kYjspT6+GpIHWxacq3wzDXxomp",
	"OLOtdVdgJzcgBpInxrPYa8PAWfjWv+bl669gYiPHEsBH6c+X7mjUH466o8HFuUxkU7L1lQTuVwEmyqPH",
	"Sldel64pJPz4ubpWfjBXCFrA95xlRRlnIFN2dtEpguVpgEzgVcQ7T+R3tHtdpqCparKS3r9vGh3pbmY+",
	"FkQhsRDI3his7X/6oUGT2HN0hea+KVx+3GshYaxWM2qGbtT1am1k1Pbrxn6zXmkbex81jk7aBDWsanvc",
	"0NvjRltvNNpjvdOGDb3RrBqwWa+Nm81O6jo4W4KuNYeeiSwgHwGOxpbvQuZucJc6FG3Sw0l+efhcYB2F",
	"XRQFMMScPb2rU8aPLnrDSyZ6cZnRAv8XD5+coI0wu/4/lTILtFzb67vQdhQ0/hqjUBZUWGMWfIGZ+MSt",
	"FMWQgY11nY0Iaoq7P0Uy41tRER7+jc4U5rbD7AnM1wTNmXyNsqvRm6IwCG2vhKwNj7t6rdkClj1FnPNk",
	"pogNDBkV0wMzdC8ow08zgFXUeEPivmoI/sNqc2QywIg2zhMe24oRK7knMawMIzL9KSU6MnnRTaxU1TLU",
	"3Z569KRiNyUTjGMilMelJSfd0APoXlhR6dUp6JEcaKNN2gi2mtWqDhtmW28YqK13DAPptbrVQB0E67XJ",
	"mO6UrlbT6X8H/aPBOej1r0aDV4Ned9QHV/031/3hiH298c4Gx/OzwdH77rTfPTvo3x9+754fTM/fHnTP",
	"Rgeu892sv3XMbwcfzw7Ojg6Wd0fDs0anO+0f9Xr83zded9E/7hqD7sHgtXdWe4+8lusefVxEi8VVbfek",
	"0zCW7rfD9sdj362TetSH7cXw+gBZdnd58I1Uw1c33ve5Z7nHvaP6+eR296/5R3Q1+evq7fI8DPzvZ4f2",
	"9PVh1z6Y3t7Nbu2jzsI46L1p3L8adUdnB/2jbvXauvH6b96cnHXtXrri7snBdHo3u/12cfnmzWF3en7c",
	"PTzod+2DD+OD6MOo3l7+RY4Wjb9c5yM67dx459Ol82HX7b5t+g4KaifN9rfe68VgetgbVUfm21OCZ/iy",
	"1u8574368NYKqicn0V1w++rq3fLD2/rl3Y032+v/88Zjx9o/P1xx5FuxCQVtXxV6pcTcNVi3GWzbBeDO",
	"056MwsEspyElPwFyfxH56Q2v1koejABk48ro/lQYnx1PgfUjQY7yCnhKzObQZgEaEl4zIwbHY2GwsNDc",
	"D6iKmzBs5WpGnEoV2Y2Nie1NI2aA1NVUlpkWYqHynlIcWSPKxpx8+qH54RR69nchGnDWjRWgZjLDxbmY",
	"sgg4fuSRcKn8hqgk0LWsEGE1B3d8EzpCcit8zC5wTQPofIk8myjbBT4m0Omx6CbVZypLe6b6I0ahDZ1z",
	"Ft2jbkBChEj5Jh/Saz6UL5FZgpJDUsTh0J+pKgGpLpvE4nJ9YDg8BlSc4pFE2ftKxlNs1HZh5qpko0y8",
	"SjaxUvrGxA8cezpjp8yoV2DjzvzWM8bzYO6yUbj/jy4jBrUfmoswhlPEo/VcYTeCwiBFsVzcgrSJpEuR",
	"LEh/xygYOx1XU4V4TAnx+tmOKfqz4FDV7OwDmNpzhEGAQtfGcTA3dByKfSHzckDAQj3j6GJMr5GqHoLj",
	"AxcSc8ZoGpxWigw/iTLVWtVmvYX2Gnq90TT1xp5R1/eqRkO3zLHRNqvtdqM9iXlJY6/WmMCqpbfqhqk3",
	"LKutw1oH6ZP2uDGpthqNqmWkKoc1ZvqF5cfaDfOb8AgulTpRGvlawm7EAVCazQ+NK5VM8AXE/1k+MBWR",
	"vRuKoGf0wKnsNYW2hwm/DAKnTC7FSmWZHU2ZypTcdLpVZkplmg3tKkOH76UXTifGSuVJnP/GK+f+UiXY",
	"x/AdxwUncdAKQPejQA3odE+c/iCmZkQ5/Y0ZmvGSibQ8FtNLbJ+xbTsswjZdP1tOHtQtc2/ShtZEb05q",
	"e3qjPoH6Xqfd1psN2KrXx2OjPh4nYlO90WhVm4bersGa3jCqSIcIQX3cbLVRo2lMJjUrBXVMKN7HV6px",
	"cE8B3kJzBu9s5A0RLg5ep1xTYyzGvmeB32JXdKxOpyMGHdf36jWjbuqG1aBb26vqexMT6eMaajVrrUYL",
	"dujWhJ8+Rsg4otLHZBqimDfbnmkHkCrYn9JPn4v4Kp/zj1SLXqVWcZxSaNYbI6bAhcerhqXdMye84X5Y",
	"H50PqdiVfJaF3Vk8xAc6IG2W9VjDIECexU3SDDf+4AKXk0QGUEYgxomNwbThHxgwJs1sLpcXw8F79rPQ",
	"WDe1d+TQ/Ch7cCmGUzhQ3R5nR8xGkZjCwAxijteU1EDH4bsTlhk6DedmlTKbWQy6Y4j5RBPo4PRvSosE",
	"VGsbm9NmaSf6z4qYtmL6bkwOWntj2Gp0mrpldJp6AzYtfa/ZbOqNjlmrt1tVy+hQpCVwyhfLOu21G+Mm",
	"nFR1ODYtvWE0Jzps1ut6DcEaqjaMemuyV6QhGaKxI4ZqGNVJbYwM3Wo0LL3Rgi19r75X11G9Oqk39xrj",
	"FqylQwmHQDzSAo0ZaotEKuk4Wnq1Oqo29hv1/Xqt0mxXP5aa+UpvmFJw1gJEHqESJfsp8kI0tTFBoWyF",
	"kphRcoFlDJBFzBDOi5OJQNxtxZApDKhoQXzZMT0QneLwsiRSIhWskhVwR6u3fLSvJTENctSAGGQOaTPD",
	"4Gyz7VmI8GBzK6I9Y3yD2dN7nGg045lARfrBwH9D2kmg0sYqAek2B5nLFNwwQzUvxqjIW5rsozJf+I6D",
	"zFhV4Psu6LcyaGxo/LVx4MDlufKau4yY65PQRp7lLGW3SjZDqnjHBLk9qk6XsMkkxYRtJBY+FUMmuSHl",
	"Lh/HX6DQhFhw39JMLqUfKQMEG96lrInJ5yeWKO9eRld5MklxGxQ3rQAJnY6p9AqpssUUuvRGZEPOmWXj",
	"UoCHlpAM8le0IYRBAtVQwGZgn6UMkweZQmTbp6k78Z7XwuFGOK7cNUNzHsqwBZoXTHdie5tDARjQi1aA",
	"wrfFbS7QKmcs8cxwGRBknaCl+rxfv+uDpBWVBeeQIHCLlCd3WzZKEI0d2wSvhxfnYIHGor90f7ljoN+l",
	"jb5+d7IuAIaisW76HiYhtIXQnwdmm9gmdNbydEYRpKGYS9CF4S2yQDzIjZrHo3uWPW0dng8Pmecly3DW",
	"uvDi/n3JcogeOcbg8grGgWfb976+GjxqB0ztJ+TxR5AM8DNnkAzyuENIuj/uFCTWzYzSPQksKaiihb7C",
	"aU/xhZUY8CcAJs4GKTaNhZklA2zivhdaSMY9/UmjfPpfsjbxORHRD5m5fpUrPjHoi62Lv6lKUBY+sPn0",
	"f2MsAPGF9z8bFeAzXll0Yf5UGEBqMds2FiCAhKCQDvf/f7q5WeiVz3/9K/7H/2i/IPpT9mMNmBtrncB8",
	"3zQ6Ovd4/SJPeOj75FFzS5CiXICMPqk5I/VjEXATGUbdTMZhf6IK/5WqrywyTvxqwkomXniVUz+XXcYR",
	"GvGUYxZLSbHOD9WAttqXtkksUnowSUCADKsSxz1HC6Zy5HCwyHZlWqaOEDhYS8t+NjyghN6oYdiKwtjn",
	"VzUMw5hpTG5JMqu0fu/LcHB0/uWy1mx9GR53a80Ws03eX0IyO0XelMx4YnoSuiQHpwIxEztsdko5HyLt",
	"0PPdgGrqDw/yMP14myuoXnwUT0TjSnBSom3PgTA8N/xej2yKU8sh21qPPMW0ErdcqcQALYu54qDH/+Tm",
	"ZYX1UgChx32yPxLbHP8//YX7DpggQf9M3RY1CyJoVtt6q9m29Eat3dHHe42O3pqgjgUhhNV69e9xp714",
	"wrJwmVbfYSeTA0BuRC9xk1Hg+2lL0xOZjZ7AxJM7ODbDptYXelQETrfGUnqRDEeZkb8URZnbeo2rupzE",
	"3qJlcqgx+KjOtAQCR0l64fpBHorgxVyxI7lxemy+bZkrTRUiQEe5JuZOwuxgmSCdxiF44CJA3uCQ6mAe",
	"Mkk2iWc0QxiJ1gxpqfrPEDdEdB8MoBPkziRYEJ8FO26XjcizlVRUj5m2rDTFAzq2RaUJzgstG3m8EF1x",
	"Q8S/RZ46tYPNNkRmiEqYBmbfkln9MYFir6pJShJIRJ4Vkzn6nhX4ytDd3ICZXuD66rRSHmWMV4UZY/WZ",
	"cQej6UDbXQ8HW93hNPHBFpfEyT/LiFGuivdl8qzH+MHqG918UXRK5ElRWIpagNBxxtC8peSGtsrkX+RW",
	"MHH8hfJCCPJgOQDzr7oExyEKHGgikQfkBg4k9nf6ibWMk96Lq0hhYz11TpAqB/FloCkR8ovBYW+dYVF2",
	"oiu4DPdf84sPURAizPIRkwAoloJ6b2PC8rPlKCgGEPYceaIp41JUGJ/aVuXG6wojgCULFWMUR+pTLdFC",
	"DmL/lLxNcmZH5ca79jKjYB5/Bp0QQWvJFyZ3r9x4N17XA4lHHbhwySmiGznEDhwk7xhXktbXGIXF3K/s",
	"0iFwUezDoV/ls4uN6cvUr4nKWOETRpdkRFSV01F4olBom2LlDPKKnqctYkakc1DabuKFl4mgafyCyK5K",
	"slgtASOq2BJJ4Pyp2BSJ0fONqEMx1BGUi0W4aNvuvb+oRjVeaZDhG+XJ5ehGv1IFgOUf+lPB8WNAjkUN",
	"VoUihr00ky1OBKcEcQlsXi0NR0Hg2GkxNaoE/oHBII7nuhTxXCuhcea76NAOtX1tl/5zN4GtHQ3PkOPQ",
	"D2Pb2x1DPNN2tCjpmIS//Bp4jC+MHaIKNpOFqkYTITq0DbDsEJmlgjff04oxeAuVi23dVjbYRHpoqoE4",
	"WMjgmx2oFHqvsYIPqIF3Mlsak7vxt45Zn9Q58GYlWOg4FxMGJDlXFJVL1odvpYP1eIdNIzlk52QmVTLN",
	"9BKZtUBKrV2Rxfrr82gzcvjR6jRTeQtScunjo+zUNTCkyHrWcZsLuhA9Sm29TD5aBmwJueljuy6VRrQd",
	"7fW7E22HJf2L/8mZr9qO9r7ZW2/wFdbdRNHPSTU/NN9DAjRX7TCvldGeq9rn/M3rmucLgWzSvqRc1bqu",
	"983sRljEaPaKPkkN8PZFR/7kfmJEZr6FecBwzOB7XSoQTVGuHBATAy17MkEh8ghwfQtxJVaUZkwE4Ay/",
	"yYUN1nRjT681RtXGfrW5X6t9ZBAlu/U1tHw9Gx+Z9oX9+s2b27ejM7s6uP4+qJ7b5OBsNGgMq6Z92nv9",
	"zTq+pW3urBoOoXc+H9sDPHDfRh+Wg9bgtr88H308fmMYtO3izD2zL771F2eH3cVZb2Gbh6+/D7759vj4",
	"6tW7a6eF3nYCWHv9AVZf2df9D8ab29l3a/m6Uxm+IaP66G1fH7yfHDSa8KTz5vryclg7fX33fvF6YXdf",
	"HZ5fRN/nx4Phq5PDxSQ8dN7dvqnM6vDN3vfD4G7evR51B+3Kyd3RO3305e3rvcH9/eDk9pjMTi/2po23",
	"jZo3eIvPO3eXH0j9rfPmftC8MN7bR9/ves6HJqrr3nJy9P7LePIOvXdP+yfX5u3Cm7y66MKL4fncG9SG",
	"57WP1VbHnMMjeH7eC6yP9wvdr7+tmgeXB3tti8BZ27ps73ln+O1scnL4PoTf7k00Dt8e9g8b9dPp8fHQ",
	"fHOmf5m1ppP6Jfx+8N09OcCT49mJ1f4WXRjz2nkL3duOfojH4a3vtbzh8dhpjduX7freaTgeTb9cWL3+",
	"l4/96nt42kKWfe29G9n9+97t8vCicbu8vvv4PcL104neMs1aKziaTUJvcDt2mqRlWuZ7z9Sdxmjemk8P",
	"7Y+3H+6Cbv8MnvQno/OO+6Y9/fbtrt5H5OPHE+Ow6Z8eRZeLL6YbLSp+7cS7/Y7dw9vz0733bw7mp8P6",
	"6SLJr7DaaFzrGLppGRO9AWFVH8NOU2+bcNKA1mRvAk0tCQKBzlTb1/pD7j4xwznlsDr/65aN59/1F/XD",
	"VwfNOwgDaxTe3X7xg+9Xrw7fH8Gz0cGrzmASvZs0Qt8+o33IkjlnNMb5KeWzp5Qva/vah25wFrVR96Tr",
	"Tk7P7SkZ1olD9l7VXbNx/8E0I68bvDlq2/Me3Qsd5vjNdHDwUb8wDdJ9P/rW/uCizuz07ZteGNSjiX/r",
	"ulVi3nUuIkPiKtrZEpRGolCqzZzfwkz1SUPe9F9Zx8HnQsxvXTcaeeRNjB6ftEL32PjARtfimP2mVd1r",
	"1qs1fdIyDb3RqLX0PTip6VbVGLeajT3LhBOtYCTgxZaNTBJ+uULMmNODpDtnia9WFFZUhRZ4JoUcWxPr",
	"6NwivigIB3HKeGxR4NXoMiXR5MQ+JnP5iyvkoQV0uhOCwv59YIfLWO0TpdOofjAcHvdQSA4lh2Brjwrm",
	"os3odJj7XmtIn6mgqBiixprYGI4dJJaRBGBwrxvt1I3X48L7lWtx4X1xHek39SL4Ol3bUw/d2BOfFSOL",
	"L+pxG7NiqlrpeReunzYEIW/Ja/0h2hRZWa6YampMF1tfsmz1pSpNh6J+XuwLjvPUqebIrChy3u/q9YBL",
	"GFLQhBhA8OnId6A3TcZNhYjgdlqZ+hULzXep9PwP1ite5J9q42cJFG6zoXwa7N+9GSVYbXtDTNd/FpvK",
	"YXl+I4f8ewzzSZmwnwX3DBlRo1mBjLL6bAkVTUrA0/PME9PihGVESnVzopT/88YtFVXdZjPPBq/KWMC2",
	"N/NscKqMaSk3xJ+JeOagpmCz22zm+YBaiVSw7c08E1B7UIqyQAivKkdQ0dqj8HJyjzFz+8AgcJbcikWl",
	"VirhFtX//H4LURMYz9bZoTCeSfanBRrPfP92rfVKtKNdKIxtEsaVzFJyePF31ZMs6Rq3PrU8k8oK/MKv",
	"SKf7ccMmvtH2wY8fgPivse+BymgZIPDwsANuqG46sHKfT9BycCi+p7muuUaXaRIsb5n4cPMt+8kH0TJO",
	"GRC7zDXvZb+ChwfwQM9PbOpQJMJk856p8rej+QHWPj8UBPL0PIoKGEvASNyUUC4ikTtkITAkhfw+nfkh",
	"ArY38TeyjMWLwLv/wHimJ3/+WeJWzu42v2wXMpu2BQlM65LH4kz8/I28djFepZBkooJauvMVkKsM5umC",
	"W7TUufc6gHYox6KlMTypY85CBIWu7SEc+zfHS0CxDIZxLBggcMriSrgbh0W5YY4IkBNNSOjGeI1tuuhV",
	"4ULcMGB2Gp12c6yPTdjWGx001jsNZOgNVJ3U0V6tMd5r5ypirAkt2jYPsyzA6LmFKK0LT1L7I2PHN08R",
	"kmtBrPIh7gA/TFvFmo4EK7HTjTsn0/Dnwkhpvnpa7XhtbnomDE/7ZvlIE1V45Po57MO/srnmSQGduEQ0",
	"dG0nHuiQjcMCGsQvr/0ZXco0LQvxzGtfVOs1WDcbht5sGy290a4jfdypt/Vm02jV22PTgM3GM619waZi",
	"yYNsOQwo09XwV9Xy7mlx9aWuad5L8k2zDg+fN8/BTwLOhfs1hVcLsT6xJ3IVuqgtPqtiSSUPtGgHREy2",
	"ukTX5lnhHDlU7wxIqLBiObxZ6Wok7FkxCA8aKh1juxohpdVBtohfUXvWs6C4VckSNuC6ih9KR30q/yrS",
	"bTIxh0wjAaJxLO3wkh/bi+ySOErb86J5Wvf0NLUFUyWQhad1IzJLLMIMb1FrYqBau66jvWpLb0yaY32v",
	"0ajrRseYGOaeaTWsScZM/05scUeLQoq6sUAmkevdON6vaLFNV7giQYR25zuNj4idSlzg832+vt5OQUpn",
	"bK57epp7v0Q8BglsTD/K/m9+XHRkbYfesPIZA/VpqrCl101jejHyWJF3/vyxLCqyXYlg7FSYjPfMwxHU",
	"RjEVgqgFITHa2jiHeNZfEuMQT6oMvwlL4naur05z/YtHoJCeUngsYKOc/aOgJ70IE99lMaEMpETJTGEu",
	"WJHkukHKVoovV75PFMKstdKGIUOJY08QsV30hOYVeUPKWG176kESsYdBpvRQZm6mwqb6DJJf63sN+mt9",
	"j0owV8Ou+PmkN6x+qRmNvbRL7mPdaNdKPzaMTmvtx2a1lvk4HJbOOByWzjccls4mfaJzfVbbSeX0vR+K",
	"eLLN0MqO0/vSFNzKX2VY2svWI1jF+Ar1Cx4yGYSruiqKo5akpEkwJnlyGeIlaYtKDH606aZQh3WV7Ubs",
	"N2chGYpXQrg1BcOCCYW9P5PYd64xnDIL0KcbzbKnNoHOMEadG+2zsN2cZBtyIkd5yY3GbDYJb7nRPqvs",
	"MUJruwinlH/Hj2T/CjtMwd77ywwxjBQ/a0sMg8QVpphcEFdxfRGZUd5r8txieSFxvlWaU8yxpnDexTdo",
	"wrIH3+KnT+SXNgoAXwFdb5lZinhtjR/fjOew8FKp3lJAAeYPpeHM8bK6qoo9VbarmifThTD/FMX75pqE",
	"CFYT2IwoUx7S++RH9PrdKHlMk4lJCIZybwqojAyTkpIIauGMEVsGV5C/yxM/ZSKi6djDHbpjz2kjNqXI",
	"VEozLJhFpXc6kKDdjUgEndHpkD/oSVEpfigUcmob20BwFAR+SP6Vz/8VkkVqshnyhgWBXAyQSyAuvCL6",
	"D3AkHtQbEhgSZN14r9jL70s/+oO9KxW7bQl7DuVywPeZWpFGCLpgyAfByavySz8KwSfJsgTxbOzD0Coj",
	"HTAI/mQ5ICNKxJd+xACQhEvwyRH4wrLlPv/fLsUQRrjw7hQRHeMZU9vwn0x4YzPz1+vpaqk2Ubnxvn79",
	"euOZUegA/Rj80ZXDHPfBAb/Aaq3+B4hXN4UELeCykl+lvcvmEiOy2CYTeRil2Y9aN4DmDIFaxSjcymKx",
	"qED2ueKH013RF++eDnr982Ffp30Y+3W5uUu66O7lQJPU0Nzv80Qi5bFddd2o8nhi5MHA1va1eqXKFhRA",
	"MmOYsCu/Riq9MsIC/nneXnLSA6osHiGieC/GFu+HSa+q17Z8/3Yj/Vz5zliRyhQgPCWWqod1bFGf/Vk/",
	"N22U9U9OfZc2Sl9wX9eWgUZzk3Fpo4cMRJ7S05SfXMwCgqj0Kb8spH2mEgoMoYtIbBxUzZo22RX8hRUo",
	"X9sYmiYKhJalLLnay5QvUr4cpXidiJuzsyhw6eNVOMAWfeBby1/2/LMa6kXVsgzKVZ98zh3VA8TK0+Q1",
	"htKUj/9WFGuUO7flth0tfUp9Tdtq7SdQV+ABK/qhQOBlKfo+7JRyi90fKnAZHD5wNHSQSg055KmBsOxR",
	"yPGS5zZmkY/3KnmyLIcNDYXUrEb81C/AUlpfeMEWACXucQtgkr5TrjBV1Qc4orImwLY3ddBWAKIWUJY/",
	"K578ClrZXbmf/1bq2NikbeMnAJSC0nak7rdIKhu0VBJV7eEzI8XC86CWdqhOq9BoYWqhEFXx8zqdWtqh",
	"cz1etsk/nsXricgPSjOYg1Mk6iPkjQjcZJHREpKU0LHtwXDFU3apS5Eg6PLaEQpXQs7MUMBd7u7JHyBV",
	"3kP+rLf2s9JYznzHLuORaxWvKT4p2tY3aVvfHm2FdYehHbfXfGIu/xSfZTMbS41m5c086U1SxU+7myq3",
	"v1ujfaQa+6K6/pTqqlZXpV+flbq6qjLnVlrrk6uq2eLCT62jrlVMX5TRfx9lVCWVZRAyR8V3RbnX52NU",
	"2gg31WVlKzfeFSJR6GEAQW94tfHrngyw41f9sD316PyeJb3AL2ohfc2c3b5t7dJ5vwIkClOBMZr4hReT",
	"k9pJYweV5L+upzU9HP4OcsPq//4ukhNPpiI7W9zfCx16tnQoroS7ES36Abe2eqUTrTZ1bWfferFp/Uqb",
	"1lqetIn1qruBxeq3mKk2sk11X+xRv8MetQFkPQ8blNLwpCR7mXpEko6dBTSmf0HHkUOYcTZ/KWsUzSIL",
	"7Z4cnlwx6bdo60G26sg6fZ0KA5PIcdJQnbI954vOv2DeU2BeRvdfghz4xHiY+fmZIuJGColcgGFjBJNl",
	"9yKC/XoRPoNSTyu856baKXm8IZtb8YKJKzFxG0H+54RzJd6Wo+3mrGr3h/TXOXTRRbihEB/LTDKijcXj",
	"AX5YLtNnN7Beqh9GLGmXspJlUnY5x4uepwS90VVtIkRvfsRHiKw8X+N30pM0teeFqvweyXpDiHt+PH19",
	"cwWZWiuTh75PfpOV9FfJMK9sDzr2d5F0IHITcibWbvaVrowtldIHYf6MU0SFYVR2hccGut7wCgQhmtt+",
	"hJ0lCJkVVs6j/5o3Oqc208qN13WwL2ZjrdkCMi53lvqXeU9GGHxHSksrL42vNLUCOCHM5GtjkNA8VsaB",
	"0tq1ltgly0P7ZW78/4BXBkuqgH+1ra85QIAJjIjUVF8BF8qi1JLN97J/Vp5cxzIsJPuwdPFlrxOWPWWU",
	"AbYsati5PKvsgKULLEC17YEAuaJy92bPCicrTucqHk/uRUClQmD8Pgdit+hATJ9Rf+HhT8HDKcWSzj15",
	"lVAQr3Jz/FRU9lhld0peGVMSyyNEhngmKoT8DnMSf1BvQ0NSEvrhOHF1nriio3hcJVvJIqnj8vx9TE+u",
	"jVDBML17CYxYnv/fHOrRtay4ON1R+lYiK+lSwtGzUPo0blUBm1lSLhjnk1lopEmLpY744YgAjhd31vYW",
	"lMwbixkESOnn7g/2/429mOnFrHJixgD7eGtHuvZna+soP95VBo71Ryixpae0ZpTiXuIalDf4Ivw8lQFj",
	"FRhtx6YEJm/CpB7H0TjZiAs+lYtd0uODTI5m6iALTpCL1rGkXTuuvxWI+luyJFO58QYirZg9kzyDmNXX",
	"ScvPZQKrCmOJejhUI+XqXbyqQjm8tAhe/IDduvjKGEvZaWx7UwGc2p4II//8eyRPZd0tFfLH2dzJo3w4",
	"j/7n6J7ovSjEfrgeceXGjAC8cO6NCII4+L9DcE3RnEoHrGjiQynCZ5iaHwVrmBp/q+8JmRqD87VMjS/j",
	"hak9LVMTDzP+JFPjVTuflKnxx9HXmhKOabNSXnAsXlh/5qyA7nV7TpBu/YUV/F5WEIPV38AJdvKYMJiA",
	"yGPPKoXsdSXiAxJG3KYfIhw5RIhbvucsge2ZTmQhwOu1suB4XAGDSdyVFaUs9o27jX0yi/tCzwK2lxmI",
	"WZO1fe0uQiwfMK6Ty4vDSvWfCsUUi/t6ZTsEheD/PN/T/xxDzBwt6Xr5nlcvNO5FV0qHKY6y8sDisdjB",
	"ZfryvW96aKx/cf6SwxKNVp9WSiF3f9D/rZUGZFZ7LF6JLhUJaIOnlAg4uVsjEIhFvMgDTykPiEP+OTrG",
	"AfA3SAMJrO/yBf94Zgstsy6P4FSU6Veakhk3OWZrG9F9PZ1BmcDpUwf4iSnKAvvkKvuMAkNA4FQq1gZd",
	"Xm1zl5fwN313LGSx7Jv1GNhEcthHOK57/0IwnoJgUBAuJRgKBI28EE1tTFD474Om18ma5a1m8TVt8zfy",
	"Sf48Xlo+/7+bXT4SotW3XQRs25sjj/hhtmhBSUKF1Fihk9JmA2m4Z6+XxttZbqec5k/hRT39jXUVsgAW",
	"w7P867Oqq4DcgCwTiFmWeNuzm3oq8UgC96cVkjITlYlK2TN5SVB+wrwG6CVosyxFmhwz2P2RXNDQiaYr",
	"ffWXKHQhXU3iTadTJv15gCp7bQMBRpipcMuqEdueipFwb7e85PUufQpW6Yz51OT/JBj7uRCC9YBQEkpw",
	"hUhoo7l8yi4i0IIEqu3TK+7P+H2kJk2PeCE4m+lRP2tB3gTCnkWuQIbACUPMCgq4m8iU5UKyoG5ehv6t",
	"EZWXPGT8twq8Om2+pdRburUX+ff5IWJGVl6CGMT+nfBxZzuFcSPs3f1B/7dx6CFtLLIzVuNzTmKhx725",
	"1EIn+U8WWH5ffGQW4B8t4cQ3LyLJxM1gOE+S21fBgiz6qAHhCcQfQdDVMlAqsdFWL+LPk/qdNobB50Fz",
	"GTl8jLS0owVReaoBx58srgA/BCEKHGiizANFCVDmDCORAo9+RV6hJZ5+yj7XJGeTsRafFXVwH/5+XE4I",
	"k1Rrkp6syBqLU3T+67WdR6LwEM435iPbiRy7MdxtxHz+wNIbZKt5EEv0tTGwMaAwPIcO4ik+LCgaET0L",
	"WVJiL7qndILPERtn+LQ2BuI34gfAQXPkxO+3xacHxr61rGzAANlTaz+HOI9kbKJMtd4l60FUavvMVBE6",
	"4jXH7o12IrX9z2OoQEDTC1fdgKuupAxBtAll2Jgo8NcHoWetJxB5zp4QiEdx959ny0/Hal8I0L8Hi19N",
	"VSifj0OySmMQ5dAfvCLyUHx+5q5xFuf0mIjtePsvRsHfH7Mdn/3flcHDnqxcn6cXpaVbnk+aHl/UL8vS",
	"Y+Vpnj+a011vh+efKLDFT6TKw/z54gv4G9A+hrO/BeXzj+mwR5LFWzrsvXE+OX+bdhcGNhs++1Rt6QO4",
	"DAPEtgohNlKdoDOGlyF/lzr7/Ej8UK70YzERg57iFcJ+FJpyJ3qQxcZ8MjkCjOdKCPeK6CtLD2VjWNlK",
	"vb63YgOZ0nIPnx/+XwAAAP//9YhUs7sAAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
